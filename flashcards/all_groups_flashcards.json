{
  "1": {
    "group": 1,
    "totalCards": 159,
    "sections": [
      {
        "section": "Detailed Study Guide",
        "subsections": [
          {
            "subsection": "General",
            "cardCount": 1,
            "cards": [
              {
                "id": "1-Detailed-Study-Guide--Detailed-Study-Guide",
                "title": "Detailed Study Guide",
                "front": "Detailed Study Guide",
                "back": "1. [Introduction and Core Concepts](#introduction-and-core-concepts)\n2. [Computer Components Overview](#computer-components-overview)\n3. [Instruction Cycle](#instruction-cycle)\n4. [Interrupts](#interrupts)\n5. [System Interconnection: The Bus](#system-interconnection-the-bus)\n6. [Bus Architecture and Design](#bus-architecture-and-design)\n7. [Modern Interconnect Technologies](#modern-interconnect-technologies)\n8. [Key Concepts Summary](#key-concepts-summary)\n9. [Practice Problems and Examples](#practice-problems-and-examples)",
                "type": "list",
                "section": "Detailed Study Guide",
                "subsection": ""
              }
            ]
          }
        ]
      },
      {
        "section": "Introduction and Core Concepts",
        "subsections": [
          {
            "subsection": "The Program Concept",
            "cardCount": 6,
            "cards": [
              {
                "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Fundamental-Principle",
                "title": "Fundamental Principle",
                "front": "Fundamental Principle",
                "back": "Modern computers use **programmable hardware** rather than hardwired systems.",
                "type": "definition",
                "section": "Introduction and Core Concepts",
                "subsection": "The Program Concept"
              },
              {
                "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Hardwired-vs--Programmable-Systems",
                "title": "Hardwired vs. Programmable Systems",
                "front": "Hardwired vs. Programmable Systems",
                "back": "",
                "type": "concept",
                "section": "Introduction and Core Concepts",
                "subsection": "The Program Concept"
              },
              {
                "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Hardwired-Systems",
                "title": "Hardwired Systems",
                "front": "Hardwired Systems",
                "back": "1. Inflexible - designed for one specific task\n2. Require physical rewiring to change functionality\n3. Example: Early calculators, dedicated control systems",
                "type": "list",
                "section": "Introduction and Core Concepts",
                "subsection": "The Program Concept"
              },
              {
                "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Programmable-Systems--General-Purpose-Hardware-",
                "title": "Programmable Systems (General-Purpose Hardware)",
                "front": "Programmable Systems (General-Purpose Hardware)",
                "back": "1. Flexible - can perform different tasks\n2. Same hardware executes different programs\n3. Change functionality by supplying new control signals (instructions)\n4. Example: Modern computers, smartphones, tablets",
                "type": "list",
                "section": "Introduction and Core Concepts",
                "subsection": "The Program Concept"
              },
              {
                "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-What-is-a-Program-",
                "title": "What is a Program?",
                "front": "What is a Program?",
                "back": "1. A **sequence of steps** (instructions)\n2. Each step performs an **arithmetic or logical operation**\n3. Each operation requires a **different set of control signals**\n4. The sequence of control signals determines the program's behavior",
                "type": "list",
                "section": "Introduction and Core Concepts",
                "subsection": "The Program Concept"
              },
              {
                "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "The same hardware can execute completely different programs by changing the sequence of instructions.",
                "type": "definition",
                "section": "Introduction and Core Concepts",
                "subsection": "The Program Concept"
              }
            ]
          },
          {
            "subsection": "The Control Unit",
            "cardCount": 3,
            "cards": [
              {
                "id": "1-Introduction-and-Core-Concepts-The-Control-Unit-Function",
                "title": "Function",
                "front": "Function",
                "back": "The Control Unit translates instruction codes into control signals.",
                "type": "definition",
                "section": "Introduction and Core Concepts",
                "subsection": "The Control Unit"
              },
              {
                "id": "1-Introduction-and-Core-Concepts-The-Control-Unit-Process",
                "title": "Process",
                "front": "Process",
                "back": "1. Each operation has a **unique code** (opcode)\n2. Examples: ADD, MOVE, SUBTRACT, JUMP\n3. The hardware accepts this code\n4. The hardware issues the appropriate **control signals** to execute the operation",
                "type": "list",
                "section": "Introduction and Core Concepts",
                "subsection": "The Control Unit"
              },
              {
                "id": "1-Introduction-and-Core-Concepts-The-Control-Unit-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. Instruction code: `ADD`\n2. Control signals generated:\n3. Enable ALU addition mode\n4. Route operands to ALU inputs\n5. Route result to destination register\n6. Update status flags",
                "type": "list",
                "section": "Introduction and Core Concepts",
                "subsection": "The Control Unit"
              }
            ]
          }
        ]
      },
      {
        "section": "Computer Components Overview",
        "subsections": [
          {
            "subsection": "The Four Essential Components",
            "cardCount": 4,
            "cards": [
              {
                "id": "1-Computer-Components-Overview-The-Four-Essential-Components-1--Central-Processing-Unit--CPU-",
                "title": "1. Central Processing Unit (CPU)",
                "front": "1. Central Processing Unit (CPU)",
                "back": "1. **Control Unit (CU):** Manages instruction execution, generates control signals\n2. **Arithmetic and Logic Unit (ALU):** Performs arithmetic and logical operations\n3. **Registers:** Fast, temporary storage within the CPU",
                "type": "list",
                "section": "Computer Components Overview",
                "subsection": "The Four Essential Components"
              },
              {
                "id": "1-Computer-Components-Overview-The-Four-Essential-Components-2--Main-Memory",
                "title": "2. Main Memory",
                "front": "2. Main Memory",
                "back": "1. Stores both **instructions** and **data**\n2. Temporary storage (volatile - loses data when power is off)\n3. Organized as a sequence of addressable locations\n4. Each location can store a word (typically 32 or 64 bits)",
                "type": "list",
                "section": "Computer Components Overview",
                "subsection": "The Four Essential Components"
              },
              {
                "id": "1-Computer-Components-Overview-The-Four-Essential-Components-3--Input-Output--I-O--Modules",
                "title": "3. Input/Output (I/O) Modules",
                "front": "3. Input/Output (I/O) Modules",
                "back": "1. Interface between the computer and external devices\n2. Handle data transfer to/from peripherals\n3. Examples: Keyboard, mouse, display, printer, disk drives, network interfaces",
                "type": "list",
                "section": "Computer Components Overview",
                "subsection": "The Four Essential Components"
              },
              {
                "id": "1-Computer-Components-Overview-The-Four-Essential-Components-4--System-Interconnection",
                "title": "4. System Interconnection",
                "front": "4. System Interconnection",
                "back": "1. **Bus:** Communication pathway connecting all components\n2. Enables data, address, and control signal transfer\n3. Critical for system performance",
                "type": "list",
                "section": "Computer Components Overview",
                "subsection": "The Four Essential Components"
              }
            ]
          },
          {
            "subsection": "Component Relationships",
            "cardCount": 1,
            "cards": [
              {
                "id": "1-Computer-Components-Overview-Component-Relationships-Key-Point",
                "title": "Key Point",
                "front": "Key Point",
                "back": "All components communicate through the system bus. The bus is the shared communication pathway.",
                "type": "definition",
                "section": "Computer Components Overview",
                "subsection": "Component Relationships"
              }
            ]
          }
        ]
      },
      {
        "section": "Instruction Cycle",
        "subsections": [
          {
            "subsection": "Basic Instruction Cycle",
            "cardCount": 7,
            "cards": [
              {
                "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Phase-1--Fetch-Cycle",
                "title": "Phase 1: Fetch Cycle",
                "front": "Phase 1: Fetch Cycle",
                "back": "",
                "type": "concept",
                "section": "Instruction Cycle",
                "subsection": "Basic Instruction Cycle"
              },
              {
                "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Retrieve the next instruction from memory",
                "type": "definition",
                "section": "Instruction Cycle",
                "subsection": "Basic Instruction Cycle"
              },
              {
                "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Steps",
                "title": "Steps",
                "front": "Steps",
                "back": "1. **Read Program Counter (PC):** PC contains the address of the next instruction\n2. **Fetch Instruction:** Read instruction from memory location pointed to by PC\n3. **Increment PC:** PC = PC + 1 (or appropriate increment based on instruction size)\n4. **Load Instruction Register (IR):** Store fetched instruction in IR for decoding",
                "type": "list",
                "section": "Instruction Cycle",
                "subsection": "Basic Instruction Cycle"
              },
              {
                "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Example",
                "title": "Example",
                "front": "Example",
                "back": "PC = 1000 (address of next instruction) Fetch instruction from memory[1000] PC = 1001 (or 1004 if 32-bit instructions) IR = instruction from memory[1000]",
                "type": "definition",
                "section": "Instruction Cycle",
                "subsection": "Basic Instruction Cycle"
              },
              {
                "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Phase-2--Execute-Cycle",
                "title": "Phase 2: Execute Cycle",
                "front": "Phase 2: Execute Cycle",
                "back": "",
                "type": "concept",
                "section": "Instruction Cycle",
                "subsection": "Basic Instruction Cycle"
              },
              {
                "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Interpret and execute the instruction",
                "type": "definition",
                "section": "Instruction Cycle",
                "subsection": "Basic Instruction Cycle"
              },
              {
                "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Types-of-Operations",
                "title": "Types of Operations",
                "front": "Types of Operations",
                "back": "1. **Processor-Memory:**\n2. Data transfer between CPU and main memory\n3. Read data from memory\n4. Write data to memory\n5. **Data Processing:**\n6. Arithmetic operations (ADD, SUBTRACT, MULTIPLY, DIVIDE)\n7. Logical operations (AND, OR, NOT, XOR)\n8. Shift operations (left, right, rotate)\n9. **Control:**\n10. Alteration of instruction sequence\n11. Jump instructions (unconditional)\n12. Branch instructions (conditional)\n13. Subroutine calls and returns\n14. **Processor-I/O:**\n15. Data transfer between CPU and I/O module\n16. Input operations\n17. Output operations",
                "type": "list",
                "section": "Instruction Cycle",
                "subsection": "Basic Instruction Cycle"
              }
            ]
          },
          {
            "subsection": "Instruction Cycle State Diagram",
            "cardCount": 1,
            "cards": [
              {
                "id": "1-Instruction-Cycle-Instruction-Cycle-State-Diagram-Key-States",
                "title": "Key States",
                "front": "Key States",
                "back": "1. **Fetch:** Get instruction from memory\n2. **Execute:** Perform the operation\n3. **Interrupt Check:** (Added when interrupts are enabled)",
                "type": "list",
                "section": "Instruction Cycle",
                "subsection": "Instruction Cycle State Diagram"
              }
            ]
          },
          {
            "subsection": "Multiple Memory Access in Execute Cycle",
            "cardCount": 4,
            "cards": [
              {
                "id": "1-Instruction-Cycle-Multiple-Memory-Access-in-Execute-Cycle-Important",
                "title": "Important",
                "front": "Important",
                "back": "The execute cycle may require **multiple memory accesses**. **Example: PDP-11 Instruction `ADD B, A`** This instruction adds the value at memory location B to the value at memory location A.",
                "type": "definition",
                "section": "Instruction Cycle",
                "subsection": "Multiple Memory Access in Execute Cycle"
              },
              {
                "id": "1-Instruction-Cycle-Multiple-Memory-Access-in-Execute-Cycle-Execute-Cycle-Steps",
                "title": "Execute Cycle Steps",
                "front": "Execute Cycle Steps",
                "back": "1. **Read memory location A** → Load into register R1\n2. **Read memory location B** → Load into register R2\n3. **Add R1 + R2** → Result in R1\n4. **Write R1** → Store result back to memory location A",
                "type": "list",
                "section": "Instruction Cycle",
                "subsection": "Multiple Memory Access in Execute Cycle"
              },
              {
                "id": "1-Instruction-Cycle-Multiple-Memory-Access-in-Execute-Cycle-Total-Memory-Accesses",
                "title": "Total Memory Accesses",
                "front": "Total Memory Accesses",
                "back": "3 (2 reads, 1 write)",
                "type": "definition",
                "section": "Instruction Cycle",
                "subsection": "Multiple Memory Access in Execute Cycle"
              },
              {
                "id": "1-Instruction-Cycle-Multiple-Memory-Access-in-Execute-Cycle-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "Complex instructions require multiple memory operations, making the execute cycle more complicated.",
                "type": "definition",
                "section": "Instruction Cycle",
                "subsection": "Multiple Memory Access in Execute Cycle"
              }
            ]
          },
          {
            "subsection": "Instruction Cycle Timing",
            "cardCount": 2,
            "cards": [
              {
                "id": "1-Instruction-Cycle-Instruction-Cycle-Timing-Without-Interrupts",
                "title": "Without Interrupts",
                "front": "Without Interrupts",
                "back": "Instruction 1: [Fetch] [Execute] [Fetch] [Execute] [Fetch] [Execute] ... Instruction 2: [Fetch] [Execute] [Fetch] [Execute] ... Instruction 3: [Fetch] [Execute] ...",
                "type": "definition",
                "section": "Instruction Cycle",
                "subsection": "Instruction Cycle Timing"
              },
              {
                "id": "1-Instruction-Cycle-Instruction-Cycle-Timing-Performance-Consideration",
                "title": "Performance Consideration",
                "front": "Performance Consideration",
                "back": "1. Fetch time depends on memory speed\n2. Execute time depends on instruction complexity\n3. Total cycle time = Fetch time + Execute time",
                "type": "list",
                "section": "Instruction Cycle",
                "subsection": "Instruction Cycle Timing"
              }
            ]
          }
        ]
      },
      {
        "section": "Interrupts",
        "subsections": [
          {
            "subsection": "What are Interrupts?",
            "cardCount": 2,
            "cards": [
              {
                "id": "1-Interrupts-What-are-Interrupts--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "A mechanism by which other modules (e.g., I/O devices) can interrupt the normal sequence of instruction execution.",
                "type": "definition",
                "section": "Interrupts",
                "subsection": "What are Interrupts?"
              },
              {
                "id": "1-Interrupts-What-are-Interrupts--Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "1. **Improve Processing Efficiency:**\n2. External devices are much slower than the processor\n3. Don't want CPU to wait idle for I/O operations\n4. Example: Printer takes milliseconds to print; CPU can do millions of operations in that time\n5. **Error Handling:**\n6. Stop execution when errors occur\n7. Errors may or may not be recoverable\n8. Allows graceful error handling\n9. **Real-Time Response:**\n10. Respond to time-critical events immediately\n11. Example: User input, network packets, sensor data",
                "type": "list",
                "section": "Interrupts",
                "subsection": "What are Interrupts?"
              }
            ]
          },
          {
            "subsection": "Classes of Interrupts",
            "cardCount": 4,
            "cards": [
              {
                "id": "1-Interrupts-Classes-of-Interrupts-1--Program-Interrupts",
                "title": "1. Program Interrupts",
                "front": "1. Program Interrupts",
                "back": "1. Generated by program execution\n2. **Examples:**\n3. **Overflow:** Arithmetic operation result exceeds register capacity\n4. **Division by Zero:** Attempt to divide by zero\n5. **Illegal Instruction:** Invalid opcode encountered\n6. **Privilege Violation:** User program attempts privileged operation",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Classes of Interrupts"
              },
              {
                "id": "1-Interrupts-Classes-of-Interrupts-2--Timer-Interrupts",
                "title": "2. Timer Interrupts",
                "front": "2. Timer Interrupts",
                "back": "1. Generated by internal processor timer\n2. **Uses:**\n3. **Pre-emptive Multi-tasking:** OS switches between processes\n4. **Time Slicing:** Fair CPU time allocation\n5. **Real-Time Systems:** Periodic task scheduling\n6. **Example:** Every 10ms, timer interrupt triggers OS scheduler",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Classes of Interrupts"
              },
              {
                "id": "1-Interrupts-Classes-of-Interrupts-3--I-O-Interrupts",
                "title": "3. I/O Interrupts",
                "front": "3. I/O Interrupts",
                "back": "1. Generated by I/O controllers\n2. **Examples:**\n3. **Device Ready:** I/O operation completed\n4. **Device Error:** I/O operation failed\n5. **Data Available:** Input device has data ready\n6. **Example:** Printer finishes printing, interrupts CPU to request next page",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Classes of Interrupts"
              },
              {
                "id": "1-Interrupts-Classes-of-Interrupts-4--Hardware-Failure-Interrupts",
                "title": "4. Hardware Failure Interrupts",
                "front": "4. Hardware Failure Interrupts",
                "back": "1. Generated by hardware malfunctions\n2. **Examples:**\n3. **Power Failure:** Power supply issues detected\n4. **Memory Parity Error:** Data corruption detected in memory\n5. **Hardware Malfunction:** Component failure detected",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Classes of Interrupts"
              }
            ]
          },
          {
            "subsection": "Transfer of Control via Interrupts",
            "cardCount": 3,
            "cards": [
              {
                "id": "1-Interrupts-Transfer-of-Control-via-Interrupts-Normal-Flow",
                "title": "Normal Flow",
                "front": "Normal Flow",
                "back": "Instruction 1 → Instruction 2 → Instruction 3 → Instruction 4 → ...",
                "type": "definition",
                "section": "Interrupts",
                "subsection": "Transfer of Control via Interrupts"
              },
              {
                "id": "1-Interrupts-Transfer-of-Control-via-Interrupts-With-Interrupt",
                "title": "With Interrupt",
                "front": "With Interrupt",
                "back": "Instruction 1 → Instruction 2 → [INTERRUPT] → Interrupt Handler → Resume Instruction 3 → ...",
                "type": "definition",
                "section": "Interrupts",
                "subsection": "Transfer of Control via Interrupts"
              },
              {
                "id": "1-Interrupts-Transfer-of-Control-via-Interrupts-Key-Process",
                "title": "Key Process",
                "front": "Key Process",
                "back": "1. Current instruction completes (or is suspended)\n2. CPU saves current context (registers, PC, status)\n3. CPU jumps to interrupt handler routine\n4. Handler processes the interrupt\n5. CPU restores saved context\n6. CPU resumes execution from where it was interrupted",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Transfer of Control via Interrupts"
              }
            ]
          },
          {
            "subsection": "Interrupt Cycle",
            "cardCount": 2,
            "cards": [
              {
                "id": "1-Interrupts-Interrupt-Cycle-Modified-Instruction-Cycle",
                "title": "Modified Instruction Cycle",
                "front": "Modified Instruction Cycle",
                "back": "FETCH → EXECUTE → [INTERRUPT CHECK] → FETCH (next instruction) │ If interrupt pending: SAVE CONTEXT JUMP TO HANDLER PROCESS INTERRUPT RESTORE CONTEXT RETURN TO PROGRAM",
                "type": "definition",
                "section": "Interrupts",
                "subsection": "Interrupt Cycle"
              },
              {
                "id": "1-Interrupts-Interrupt-Cycle-Interrupt-Check-Steps",
                "title": "Interrupt Check Steps",
                "front": "Interrupt Check Steps",
                "back": "1. **Check for interrupt signal** (after each instruction)\n2. **If no interrupt:** Continue to fetch next instruction\n3. **If interrupt pending:**\n4. **Suspend** execution of current program\n5. **Save context:**\n6. Program Counter (PC)\n7. Processor Status Word (PSW)\n8. General-purpose registers\n9. Other processor state\n10. **Set PC** to start address of interrupt handler routine\n11. **Process interrupt** (execute handler)\n12. **Restore context** (restore saved state)\n13. **Continue** interrupted program",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Interrupt Cycle"
              }
            ]
          },
          {
            "subsection": "Program Timing with Interrupts",
            "cardCount": 5,
            "cards": [
              {
                "id": "1-Interrupts-Program-Timing-with-Interrupts-Without-Interrupts--Programmed-I-O--",
                "title": "Without Interrupts (Programmed I/O):",
                "front": "Without Interrupts (Programmed I/O):",
                "back": "CPU: [Execute] [Wait] [Wait] [Wait] [Wait] [Wait] [I/O Complete] [Continue] └─────────────────────────────────────────────────────────┘ CPU WASTED TIME",
                "type": "concept",
                "section": "Interrupts",
                "subsection": "Program Timing with Interrupts"
              },
              {
                "id": "1-Interrupts-Program-Timing-with-Interrupts-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "CPU sits idle waiting for slow I/O device.",
                "type": "definition",
                "section": "Interrupts",
                "subsection": "Program Timing with Interrupts"
              },
              {
                "id": "1-Interrupts-Program-Timing-with-Interrupts-With-Interrupts--Interrupt-Driven-I-O--",
                "title": "With Interrupts (Interrupt-Driven I/O):",
                "front": "With Interrupts (Interrupt-Driven I/O):",
                "back": "CPU: [Execute] [Execute] [Execute] [Execute] [Interrupt] [Handler] [Continue] I/O: [Start] [Working] [Working] [Working] [Complete] ──┘",
                "type": "concept",
                "section": "Interrupts",
                "subsection": "Program Timing with Interrupts"
              },
              {
                "id": "1-Interrupts-Program-Timing-with-Interrupts-Benefit",
                "title": "Benefit",
                "front": "Benefit",
                "back": "CPU can do useful work while I/O device operates.",
                "type": "definition",
                "section": "Interrupts",
                "subsection": "Program Timing with Interrupts"
              },
              {
                "id": "1-Interrupts-Program-Timing-with-Interrupts-Efficiency-Gain",
                "title": "Efficiency Gain",
                "front": "Efficiency Gain",
                "back": "1. **Short I/O Wait:** Small improvement\n2. **Long I/O Wait:** Massive improvement (CPU can execute thousands of instructions)",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Program Timing with Interrupts"
              }
            ]
          },
          {
            "subsection": "Multiple Interrupts",
            "cardCount": 6,
            "cards": [
              {
                "id": "1-Interrupts-Multiple-Interrupts-Strategy-1--Disable-Interrupts",
                "title": "Strategy 1: Disable Interrupts",
                "front": "Strategy 1: Disable Interrupts",
                "back": "1. **Approach:** Processor ignores further interrupts while processing one\n2. **Behavior:**\n3. Interrupts remain pending\n4. Checked after current interrupt is processed\n5. Handled in sequence as they occurred\n6. **Use Case:** Simple systems, low interrupt rates",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Multiple Interrupts"
              },
              {
                "id": "1-Interrupts-Multiple-Interrupts-Timeline",
                "title": "Timeline",
                "front": "Timeline",
                "back": "Interrupt 1 arrives → Process Interrupt 1 Interrupt 2 arrives → [IGNORED, pending] Interrupt 3 arrives → [IGNORED, pending] Interrupt 1 complete → Check pending → Process Interrupt 2 Interrupt 2 complete → Check pending → Process Interrupt 3",
                "type": "definition",
                "section": "Interrupts",
                "subsection": "Multiple Interrupts"
              },
              {
                "id": "1-Interrupts-Multiple-Interrupts-Strategy-2--Priority-Based--Nested-Interrupts-",
                "title": "Strategy 2: Priority-Based (Nested Interrupts)",
                "front": "Strategy 2: Priority-Based (Nested Interrupts)",
                "back": "1. **Approach:** Define interrupt priorities\n2. **Behavior:**\n3. Low priority interrupts can be interrupted by higher priority interrupts\n4. When high priority interrupt completes, return to previous interrupt\n5. Supports nested interrupt handling\n6. **Use Case:** Real-time systems, critical events",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Multiple Interrupts"
              },
              {
                "id": "1-Interrupts-Multiple-Interrupts-Priority-Levels--Example-",
                "title": "Priority Levels (Example)",
                "front": "Priority Levels (Example)",
                "back": "1. **Highest:** Hardware failure (power failure, memory error)\n2. **High:** Timer interrupts (system scheduling)\n3. **Medium:** I/O interrupts (device ready)\n4. **Lowest:** Program interrupts (overflow, division by zero)",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Multiple Interrupts"
              },
              {
                "id": "1-Interrupts-Multiple-Interrupts-Timeline--Nested-",
                "title": "Timeline (Nested)",
                "front": "Timeline (Nested)",
                "back": "Low Priority Interrupt 1 starts → High Priority Interrupt 2 arrives → Process Interrupt 2 (higher priority) → Interrupt 2 complete → Resume Interrupt 1 → Interrupt 1 complete",
                "type": "definition",
                "section": "Interrupts",
                "subsection": "Multiple Interrupts"
              },
              {
                "id": "1-Interrupts-Multiple-Interrupts-Timeline--Sequential-",
                "title": "Timeline (Sequential)",
                "front": "Timeline (Sequential)",
                "back": "Interrupt 1 arrives → Process Interrupt 1 → Complete Interrupt 2 arrives → Process Interrupt 2 → Complete Interrupt 3 arrives → Process Interrupt 3 → Complete",
                "type": "definition",
                "section": "Interrupts",
                "subsection": "Multiple Interrupts"
              }
            ]
          },
          {
            "subsection": "Interrupt Performance Impact",
            "cardCount": 2,
            "cards": [
              {
                "id": "1-Interrupts-Interrupt-Performance-Impact-Overhead",
                "title": "Overhead",
                "front": "Overhead",
                "back": "1. Context saving/restoring takes time\n2. Interrupt handler execution time\n3. Pipeline stalls (in pipelined processors)",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Interrupt Performance Impact"
              },
              {
                "id": "1-Interrupts-Interrupt-Performance-Impact-Benefit",
                "title": "Benefit",
                "front": "Benefit",
                "back": "1. Much greater than overhead for long I/O operations\n2. Enables multitasking and real-time response",
                "type": "list",
                "section": "Interrupts",
                "subsection": "Interrupt Performance Impact"
              }
            ]
          }
        ]
      },
      {
        "section": "System Interconnection: The Bus",
        "subsections": [
          {
            "subsection": "What is a Bus?",
            "cardCount": 3,
            "cards": [
              {
                "id": "1-System-Interconnection--The-Bus-What-is-a-Bus--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "A communication pathway connecting two or more devices.",
                "type": "definition",
                "section": "System Interconnection: The Bus",
                "subsection": "What is a Bus?"
              },
              {
                "id": "1-System-Interconnection--The-Bus-What-is-a-Bus--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Broadcast:** Signals sent on bus are received by all connected devices\n2. **Shared Resource:** Only one device can transmit at a time\n3. **Grouped Channels:** Multiple wires carrying related signals\n4. Example: 32-bit data bus = 32 separate wires (channels)",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "What is a Bus?"
              },
              {
                "id": "1-System-Interconnection--The-Bus-What-is-a-Bus--Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **Control/Address/Data bus (PC):** Traditional PC architecture\n2. **Unibus (DEC-PDP):** DEC's unified bus system",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "What is a Bus?"
              }
            ]
          },
          {
            "subsection": "Bus Interconnection Scheme",
            "cardCount": 1,
            "cards": [
              {
                "id": "1-System-Interconnection--The-Bus-Bus-Interconnection-Scheme-Key-Point",
                "title": "Key Point",
                "front": "Key Point",
                "back": "All devices share the same bus. Only one can use it at a time.",
                "type": "definition",
                "section": "System Interconnection: The Bus",
                "subsection": "Bus Interconnection Scheme"
              }
            ]
          },
          {
            "subsection": "The Three Types of Buses",
            "cardCount": 16,
            "cards": [
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-1--Data-Bus",
                "title": "1. Data Bus",
                "front": "1. Data Bus",
                "back": "",
                "type": "concept",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Function",
                "title": "Function",
                "front": "Function",
                "back": "Carries data and instructions between components.",
                "type": "definition",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Key-Characteristics",
                "title": "Key Characteristics",
                "front": "Key Characteristics",
                "back": "1. **Bidirectional:** Data can flow in both directions\n2. **Width Matters:**\n3. 8-bit bus: Transfer 1 byte at a time\n4. 16-bit bus: Transfer 2 bytes at a time\n5. 32-bit bus: Transfer 4 bytes at a time\n6. 64-bit bus: Transfer 8 bytes at a time\n7. **Performance Impact:** Wider bus = faster data transfer",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Important-Note",
                "title": "Important Note",
                "front": "Important Note",
                "back": "At the bus level, there is **no difference between \"data\" and \"instructions\"**. Both are just binary patterns traveling on the data bus.",
                "type": "definition",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. 32-bit data bus can transfer a 32-bit instruction in one cycle\n2. Or transfer a 32-bit data value in one cycle",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-2--Address-Bus",
                "title": "2. Address Bus",
                "front": "2. Address Bus",
                "back": "",
                "type": "concept",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Function",
                "title": "Function",
                "front": "Function",
                "back": "Identifies the source or destination of data.",
                "type": "definition",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Key-Characteristics",
                "title": "Key Characteristics",
                "front": "Key Characteristics",
                "back": "1. **Unidirectional:** Typically CPU → Memory/I/O (CPU specifies address)\n2. **Width Determines Memory Capacity:**\n3. n-bit address bus = 2^n addressable locations\n4. Example: 16-bit address bus = 2^16 = 65,536 locations = 64 KB\n5. Example: 32-bit address bus = 2^32 = 4,294,967,296 locations = 4 GB",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Memory-Addressing-Example",
                "title": "Memory Addressing Example",
                "front": "Memory Addressing Example",
                "back": "1. CPU places 1000 on address bus\n2. Memory module sees address 1000\n3. Memory module places contents of location 1000 on data bus\n4. CPU reads data from data bus",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Historical-Example",
                "title": "Historical Example",
                "front": "Historical Example",
                "back": "1. Intel 8080: 16-bit address bus → 64 KB maximum memory\n2. Modern processors: 64-bit address bus → 16 exabytes theoretical maximum",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-3--Control-Bus",
                "title": "3. Control Bus",
                "front": "3. Control Bus",
                "back": "",
                "type": "concept",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Function",
                "title": "Function",
                "front": "Function",
                "back": "Carries control and timing information.",
                "type": "definition",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Key-Signals",
                "title": "Key Signals",
                "front": "Key Signals",
                "back": "1. **Memory Read:** Signal to read from memory\n2. **Memory Write:** Signal to write to memory\n3. **I/O Read:** Signal to read from I/O device\n4. **I/O Write:** Signal to write to I/O device\n5. **Interrupt Request (IRQ):** Device requesting interrupt\n6. **Interrupt Acknowledge:** CPU acknowledging interrupt\n7. **Bus Request:** Device requesting bus control\n8. **Bus Grant:** CPU granting bus control\n9. **Clock:** Synchronization signal\n10. **Reset:** System reset signal",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Control-Bus-Operations",
                "title": "Control Bus Operations",
                "front": "Control Bus Operations",
                "back": "",
                "type": "definition",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Sending-Data",
                "title": "Sending Data",
                "front": "Sending Data",
                "back": "1. Obtain use of the bus (bus arbitration)\n2. Place address on address bus\n3. Place data on data bus\n4. Assert appropriate control signal (e.g., Write)\n5. Wait for acknowledgment\n6. Release bus",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              },
              {
                "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Requesting-Data",
                "title": "Requesting Data",
                "front": "Requesting Data",
                "back": "1. Obtain use of the bus\n2. Place address on address bus\n3. Assert appropriate control signal (e.g., Read)\n4. Wait for data on data bus\n5. Read data from data bus\n6. Release bus",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "The Three Types of Buses"
              }
            ]
          },
          {
            "subsection": "Bus Width and Performance",
            "cardCount": 3,
            "cards": [
              {
                "id": "1-System-Interconnection--The-Bus-Bus-Width-and-Performance-Data-Bus-Width",
                "title": "Data Bus Width",
                "front": "Data Bus Width",
                "back": "1. Determines how much data can be transferred per cycle\n2. Wider = fewer cycles needed for large transfers\n3. Trade-off: More wires = higher cost",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "Bus Width and Performance"
              },
              {
                "id": "1-System-Interconnection--The-Bus-Bus-Width-and-Performance-Address-Bus-Width",
                "title": "Address Bus Width",
                "front": "Address Bus Width",
                "back": "1. Determines maximum addressable memory\n2. Wider = more memory can be addressed\n3. Trade-off: More wires = higher cost",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "Bus Width and Performance"
              },
              {
                "id": "1-System-Interconnection--The-Bus-Bus-Width-and-Performance-Example-Calculation",
                "title": "Example Calculation",
                "front": "Example Calculation",
                "back": "1. 32-bit data bus: Can transfer 4 bytes per cycle\n2. 32-bit address bus: Can address 4 GB of memory\n3. Number of transfers needed: 1 MB / 4 bytes = 262,144 transfers\n4. If each transfer takes 1 cycle: 262,144 cycles",
                "type": "list",
                "section": "System Interconnection: The Bus",
                "subsection": "Bus Width and Performance"
              }
            ]
          }
        ]
      },
      {
        "section": "Bus Architecture and Design",
        "subsections": [
          {
            "subsection": "Single Bus Problems",
            "cardCount": 2,
            "cards": [
              {
                "id": "1-Bus-Architecture-and-Design-Single-Bus-Problems-Issues-with-Single-Bus-Architecture",
                "title": "Issues with Single Bus Architecture",
                "front": "Issues with Single Bus Architecture",
                "back": "1. **Propagation Delays:**\n2. Long bus = longer signal travel time\n3. Limits maximum bus speed\n4. Becomes worse with more devices\n5. **Bus Contention:**\n6. Many devices competing for bus access\n7. Coordination overhead increases\n8. Performance degrades as more devices added\n9. **Bandwidth Limitations:**\n10. Single bus has fixed bandwidth\n11. Aggregate data transfer approaches bus capacity\n12. Becomes bottleneck for high-performance systems",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Single Bus Problems"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Single-Bus-Problems-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Use **multiple buses** organized hierarchically.",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Single Bus Problems"
              }
            ]
          },
          {
            "subsection": "Traditional Bus Architecture",
            "cardCount": 2,
            "cards": [
              {
                "id": "1-Bus-Architecture-and-Design-Traditional-Bus-Architecture-Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "├──► System Bus (High Speed) ├──► Memory Bus ──► Main Memory └──► Expansion Bus ──► I/O Devices",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Traditional Bus Architecture"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Traditional-Bus-Architecture-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **System Bus:** Fast, connects CPU and cache\n2. **Memory Bus:** Connects to main memory\n3. **Expansion Bus:** Slower, connects to I/O devices\n4. **Hierarchical:** Different speeds for different purposes",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Traditional Bus Architecture"
              }
            ]
          },
          {
            "subsection": "High Performance Bus Architecture",
            "cardCount": 2,
            "cards": [
              {
                "id": "1-Bus-Architecture-and-Design-High-Performance-Bus-Architecture-Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "├──► Local Bus (Very Fast) ──► Cache └──► System Bus (Fast) ──► Main Memory └──► Expansion Bus (Slower) ──► I/O Devices",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "High Performance Bus Architecture"
              },
              {
                "id": "1-Bus-Architecture-and-Design-High-Performance-Bus-Architecture-Benefits",
                "title": "Benefits",
                "front": "Benefits",
                "back": "1. **Local Bus:** Ultra-fast for CPU-cache communication\n2. **System Bus:** Fast for CPU-memory communication\n3. **Expansion Bus:** Adequate speed for I/O devices\n4. **Reduced Contention:** Different buses for different purposes",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "High Performance Bus Architecture"
              }
            ]
          },
          {
            "subsection": "Bus Types",
            "cardCount": 5,
            "cards": [
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Types-1--Dedicated-Bus",
                "title": "1. Dedicated Bus",
                "front": "1. Dedicated Bus",
                "back": "1. **Separate lines** for data and address\n2. **Advantages:**\n3. Simpler control logic\n4. Can transfer address and data simultaneously (in some cases)\n5. Better performance\n6. **Disadvantages:**\n7. More wires = higher cost\n8. More complex physical layout",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Types"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Types-Example",
                "title": "Example",
                "front": "Example",
                "back": "Data Bus: 32 wires (D0-D31) Address Bus: 32 wires (A0-A31) Control Bus: Various control signals Total: 64+ wires",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Types"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Types-2--Multiplexed-Bus",
                "title": "2. Multiplexed Bus",
                "front": "2. Multiplexed Bus",
                "back": "1. **Shared lines** for address and data\n2. **Control signal** indicates whether address or data is on bus\n3. **Advantages:**\n4. Fewer wires = lower cost\n5. Simpler physical layout\n6. **Disadvantages:**\n7. More complex control logic\n8. Requires two cycles (address, then data)\n9. Lower performance",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Types"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Types-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. ALE=1: Bus carries address\n2. ALE=0: Bus carries data",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Types"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Types-Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "Cycle 1: Place address on bus, assert ALE Cycle 2: Place data on bus, deassert ALE",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Types"
              }
            ]
          },
          {
            "subsection": "Bus Arbitration",
            "cardCount": 13,
            "cards": [
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "Multiple devices may want to use the bus simultaneously.",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "**Bus Arbitration** - mechanism to determine which device gets bus access.",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Requirements",
                "title": "Requirements",
                "front": "Requirements",
                "back": "1. Only **one device** can control bus at a time\n2. Fair access to all devices\n3. Priority for time-critical operations\n4. Efficient arbitration (minimal overhead)",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Centralized-Arbitration",
                "title": "Centralized Arbitration",
                "front": "Centralized Arbitration",
                "back": "",
                "type": "concept",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "1. **Single hardware device** (bus controller/arbiter) controls bus access\n2. May be part of CPU or separate chip\n3. All devices request bus from arbiter\n4. Arbiter grants bus to one device at a time",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Simple logic in each device\n2. Centralized control\n3. Easy to implement priority schemes",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. Single point of failure\n2. May become bottleneck\n3. Centralized logic complexity",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Example",
                "title": "Example",
                "front": "Example",
                "back": "Device 1 ──┐ Device 2 ──┼──► Bus Arbiter ──► Bus Control Device 3 ──┘",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Distributed-Arbitration",
                "title": "Distributed Arbitration",
                "front": "Distributed Arbitration",
                "back": "",
                "type": "concept",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "1. **Each device** has arbitration logic\n2. Devices compete directly\n3. No central arbiter\n4. Self-selecting based on priority",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. No single point of failure\n2. Scalable\n3. Can be faster (parallel arbitration)",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. More complex logic in each device\n2. More expensive per device\n3. Harder to debug",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Example",
                "title": "Example",
                "front": "Example",
                "back": "Device 1 (Priority 3) ──┐ Device 2 (Priority 2) ──┼──► Bus (winner takes control) Device 3 (Priority 1) ──┘ (Device 3 wins - highest priority)",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Arbitration"
              }
            ]
          },
          {
            "subsection": "Bus Timing",
            "cardCount": 15,
            "cards": [
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "Devices must coordinate when to read/write data.",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "**Timing protocols** ensure proper synchronization.",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Synchronous-Timing",
                "title": "Synchronous Timing",
                "front": "Synchronous Timing",
                "back": "",
                "type": "concept",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Events determined by **clock signals**\n2. Control bus includes **clock line**\n3. All devices read same clock\n4. Single clock cycle (1-0 transition) = one bus cycle\n5. Usually synchronize on **leading edge** (rising edge) of clock\n6. Usually one cycle per event",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Simple to implement\n2. Predictable timing\n3. Easy to design for",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. Limited by slowest device\n2. Clock skew problems at high speeds\n3. Inflexible (all devices must use same clock)",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Timing-Diagram",
                "title": "Timing Diagram",
                "front": "Timing Diagram",
                "back": "Clock: ──┐ ┐ ┐ ┐ └─────┘ └─────┘ Address: ──[A]─────────────── Data: └──[D]─────────── Read: └────────────────",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "1. **T1:** Address placed on address bus\n2. **T2:** Read signal asserted\n3. **T3:** Data available on data bus (memory responds)\n4. **T4:** Data read, signals deasserted",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Asynchronous-Timing",
                "title": "Asynchronous Timing",
                "front": "Asynchronous Timing",
                "back": "",
                "type": "concept",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **No common clock**\n2. Devices use **handshaking signals**\n3. **Request-Acknowledge** protocol\n4. Timing determined by device speeds, not fixed clock",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Signals",
                "title": "Signals",
                "front": "Signals",
                "back": "1. **Request (REQ):** Initiator requests operation\n2. **Acknowledge (ACK):** Target acknowledges completion\n3. **Ready:** Data ready signal",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Works with devices of different speeds\n2. No clock skew issues\n3. More flexible",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. More complex control logic\n2. Harder to design\n3. Variable timing (harder to predict)",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Read-Operation-Timing",
                "title": "Read Operation Timing",
                "front": "Read Operation Timing",
                "back": "Initiator places address on bus Initiator asserts REQ Target sees REQ, places data on bus Target asserts ACK Initiator reads data, deasserts REQ Target deasserts ACK",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Bus-Timing-Write-Operation-Timing",
                "title": "Write Operation Timing",
                "front": "Write Operation Timing",
                "back": "Initiator places address and data on bus Initiator asserts REQ Target reads data, asserts ACK Initiator deasserts REQ Target deasserts ACK",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Bus Timing"
              }
            ]
          },
          {
            "subsection": "Direct Memory Access (DMA) Fundamentals",
            "cardCount": 7,
            "cards": [
              {
                "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Allow I/O modules to exchange data directly with memory, bypassing the CPU.",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Direct Memory Access (DMA) Fundamentals"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Traditional-Approach--Programmed-I-O-",
                "title": "Traditional Approach (Programmed I/O)",
                "front": "Traditional Approach (Programmed I/O)",
                "back": "CPU reads from I/O → CPU writes to Memory CPU reads from Memory → CPU writes to I/O",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Direct Memory Access (DMA) Fundamentals"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "CPU is involved in every data transfer, wasting CPU cycles.",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Direct Memory Access (DMA) Fundamentals"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-DMA-Approach",
                "title": "DMA Approach",
                "front": "DMA Approach",
                "back": "I/O Module ──► Memory (direct transfer, CPU not involved)",
                "type": "definition",
                "section": "Bus Architecture and Design",
                "subsection": "Direct Memory Access (DMA) Fundamentals"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Process",
                "title": "Process",
                "front": "Process",
                "back": "1. CPU grants DMA authority to I/O module\n2. I/O module issues read/write commands directly to memory\n3. CPU is free to do other work\n4. I/O module notifies CPU when transfer complete (interrupt)",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Direct Memory Access (DMA) Fundamentals"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Benefits",
                "title": "Benefits",
                "front": "Benefits",
                "back": "1. CPU not tied up during data transfer\n2. Much faster for large transfers\n3. Better overall system performance",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Direct Memory Access (DMA) Fundamentals"
              },
              {
                "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. Disk I/O (reading/writing files)\n2. Network I/O (receiving/sending packets)\n3. Graphics (transferring frame buffers)\n4. Audio (streaming audio data)",
                "type": "list",
                "section": "Bus Architecture and Design",
                "subsection": "Direct Memory Access (DMA) Fundamentals"
              }
            ]
          }
        ]
      },
      {
        "section": "Modern Interconnect Technologies",
        "subsections": [
          {
            "subsection": "Evolution from Bus to Point-to-Point",
            "cardCount": 2,
            "cards": [
              {
                "id": "1-Modern-Interconnect-Technologies-Evolution-from-Bus-to-Point-to-Point-Problems-with-Traditional-Buses",
                "title": "Problems with Traditional Buses",
                "front": "Problems with Traditional Buses",
                "back": "1. **Electrical Constraints:**\n2. Increasing frequency causes signal integrity issues\n3. Wide synchronous buses become difficult at high speeds\n4. Clock distribution becomes problematic\n5. **Synchronization and Arbitration:**\n6. Hard to perform in timely fashion at high data rates\n7. Arbitration overhead increases\n8. Becomes bottleneck\n9. **Multicore Challenges:**\n10. Multiple processors on single chip\n11. Shared bus on chip magnifies problems\n12. Need to keep up with processor speeds",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Evolution from Bus to Point-to-Point"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Evolution-from-Bus-to-Point-to-Point-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Lower Latency:** Direct connections, no bus arbitration\n2. **Higher Data Rate:** Can achieve much higher speeds\n3. **Better Scalability:** Add more connections without degrading performance\n4. **No Arbitration Overhead:** Direct connections eliminate contention",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Evolution from Bus to Point-to-Point"
              }
            ]
          },
          {
            "subsection": "Quick Path Interconnect (QPI)",
            "cardCount": 6,
            "cards": [
              {
                "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--Introduction",
                "title": "Introduction",
                "front": "Introduction",
                "back": "Intel introduced QPI in 2008 for high-performance systems.",
                "type": "definition",
                "section": "Modern Interconnect Technologies",
                "subsection": "Quick Path Interconnect (QPI)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--Key-Features",
                "title": "Key Features",
                "front": "Key Features",
                "back": "1. **Multiple Direct Connections:** Pairwise connections between components\n2. **No Arbitration:** Eliminates need for bus arbitration\n3. **Layered Protocol:** Similar to network protocols\n4. **Packetized Transfer:** Data sent as packets with headers and error codes",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Quick Path Interconnect (QPI)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--QPI-Architecture-Layers",
                "title": "QPI Architecture Layers",
                "front": "QPI Architecture Layers",
                "back": "1. **Function:** Actual wires and circuitry for signal transmission\n2. **Unit:** **Phit (Physical Unit)** = 20 bits\n3. **Implementation:**\n4. 20 data lanes in each direction (transmit and receive)\n5. Plus clock lane in each direction\n6. **Differential Signaling:** Two wires per lane (balanced transmission)\n7. Current travels down one conductor, returns on other\n8. Binary value depends on voltage difference\n9. More noise-resistant than single-ended signaling\n10. **Function:** Reliable transmission and flow control\n11. **Unit:** **Flit (Flow Control Unit)** = 80 bits\n12. 72-bit message payload\n13. 8-bit error control code (CRC - Cyclic Redundancy Check)\n14. **Responsibilities:**\n15. **Flow Control:** Prevents sender from overwhelming receiver\n16. **Error Control:** Detects and recovers from bit errors\n17. **Function:** Determines packet path through system\n18. **Implementation:** Defined by firmware\n19. **Purpose:** Describes possible paths packets can follow\n20. **Function:** High-level rules for packet exchange\n21. **Unit:** **Packet** (comprised of integral number of Flits)\n22. **Key Feature:** Cache coherency protocol\n23. Ensures main memory values in multiple caches remain consistent\n24. Critical for multiprocessor systems",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Quick Path Interconnect (QPI)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--QPI-Physical-Interface",
                "title": "QPI Physical Interface",
                "front": "QPI Physical Interface",
                "back": "",
                "type": "concept",
                "section": "Modern Interconnect Technologies",
                "subsection": "Quick Path Interconnect (QPI)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "1. **84 individual links** per QPI port\n2. **20 data lanes** in each direction (40 total)\n3. **1 clock lane** in each direction (2 total)\n4. **Multilane Distribution:** 80-bit flits distributed across 20 lanes in round-robin fashion",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Quick Path Interconnect (QPI)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--Performance",
                "title": "Performance",
                "front": "Performance",
                "back": "1. Can transmit 20 bits in parallel in each direction\n2. Very high data rates achieved through parallel channels",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Quick Path Interconnect (QPI)"
              }
            ]
          },
          {
            "subsection": "Peripheral Component Interconnect Express (PCIe)",
            "cardCount": 6,
            "cards": [
              {
                "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--Evolution",
                "title": "Evolution",
                "front": "Evolution",
                "back": "1. **PCI (Peripheral Component Interconnect):** Traditional bus-based scheme\n2. **PCIe (PCI Express):** Point-to-point interconnect replacing PCI",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Peripheral Component Interconnect Express (PCIe)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--Key-Requirements",
                "title": "Key Requirements",
                "front": "Key Requirements",
                "back": "1. High capacity for high data rate I/O devices\n2. Support for Gigabit Ethernet and faster\n3. Support time-dependent data streams (real-time audio/video)",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Peripheral Component Interconnect Express (PCIe)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--PCIe-Architecture-Layers",
                "title": "PCIe Architecture Layers",
                "front": "PCIe Architecture Layers",
                "back": "1. **Function:** Physical wires and transmission circuitry\n2. **Characteristics:**\n3. **Bidirectional Lanes:** Unlike QPI, lanes work both directions\n4. **Configurable Lanes:** 1, 4, 8, 16, or 32 lanes per port\n5. **Round-Robin Distribution:** Bits sent to lanes in round-robin\n6. **128-bit Processing:** Each lane processes 16 bytes (128 bits) at a time\n7. **130-bit Encoding:** Each 128-bit block encoded into 130-bit codeword\n8. **No Common Clock:** Receiver uses data transitions for synchronization\n9. **Transition Guarantee:** Extra 2 bits ensure transitions in long sequences of 1s\n10. **Function:** Reliable transmission and flow control\n11. **Unit:** **DLLP (Data Link Layer Packet)**\n12. **Responsibilities:**\n13. **Flow Control:** Regulates transmission rate\n14. **Power Management:** Manages power budgeting\n15. **ACK/NAK:** Acknowledges valid packets, requests retransmission of invalid packets\n16. **Function:** Generates and consumes data packets, manages flow\n17. **Unit:** **TLP (Transaction Layer Packet)**\n18. **Responsibilities:**\n19. Receives read/write requests from software\n20. Creates request packets for transmission\n21. **Split Transactions:** Most transactions use request-response pattern\n22. **Posted Transactions:** Some writes and messages don't expect response\n23. Supports 32-bit and 64-bit memory addressing",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Peripheral Component Interconnect Express (PCIe)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--PCIe-Configuration",
                "title": "PCIe Configuration",
                "front": "PCIe Configuration",
                "back": "",
                "type": "concept",
                "section": "Modern Interconnect Technologies",
                "subsection": "Peripheral Component Interconnect Express (PCIe)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--Typical-Setup",
                "title": "Typical Setup",
                "front": "Typical Setup",
                "back": "CPU ──► QPI ──► Memory Controller Hub ├──► PCIe ──► Graphics Card (x16) ├──► PCIe ──► Network Card (x1) └──► PCIe ──► Storage Controller (x4)",
                "type": "definition",
                "section": "Modern Interconnect Technologies",
                "subsection": "Peripheral Component Interconnect Express (PCIe)"
              },
              {
                "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--Lane-Configurations",
                "title": "Lane Configurations",
                "front": "Lane Configurations",
                "back": "1. **x1:** 1 lane (low bandwidth devices)\n2. **x4:** 4 lanes (moderate bandwidth)\n3. **x8:** 8 lanes (high bandwidth)\n4. **x16:** 16 lanes (graphics cards, high-performance devices)",
                "type": "list",
                "section": "Modern Interconnect Technologies",
                "subsection": "Peripheral Component Interconnect Express (PCIe)"
              }
            ]
          }
        ]
      },
      {
        "section": "Key Concepts Summary",
        "subsections": [
          {
            "subsection": "Fundamental Principles",
            "cardCount": 1,
            "cards": [
              {
                "id": "1-Key-Concepts-Summary-Fundamental-Principles-Fundamental-Principles",
                "title": "Fundamental Principles",
                "front": "Fundamental Principles",
                "back": "1. **Programmable Hardware:**\n2. Same hardware executes different programs\n3. Programs are sequences of instructions\n4. Instructions generate control signals\n5. **Component Communication:**\n6. All components communicate via system bus\n7. Bus is shared resource\n8. Only one device can use bus at a time\n9. **Instruction Execution:**\n10. Fetch-Execute cycle repeats\n11. Each instruction may require multiple memory accesses\n12. Interrupts can suspend normal execution\n13. **Performance Optimization:**\n14. Interrupts improve efficiency (CPU doesn't wait for I/O)\n15. Multiple buses reduce contention\n16. Point-to-point interconnects eliminate bus bottlenecks",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Fundamental Principles"
              }
            ]
          },
          {
            "subsection": "Memory Hierarchy Concept",
            "cardCount": 2,
            "cards": [
              {
                "id": "1-Key-Concepts-Summary-Memory-Hierarchy-Concept-Levels--Fastest-to-Slowest-",
                "title": "Levels (Fastest to Slowest)",
                "front": "Levels (Fastest to Slowest)",
                "back": "1. **CPU Registers:** Fastest, smallest, most expensive\n2. **Cache Memory:** Very fast, small, expensive\n3. **Main Memory (RAM):** Fast, medium size, moderate cost\n4. **Secondary Storage (Disk):** Slow, large, cheap",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Memory Hierarchy Concept"
              },
              {
                "id": "1-Key-Concepts-Summary-Memory-Hierarchy-Concept-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Use fast, expensive memory for frequently accessed data; use slow, cheap memory for bulk storage.",
                "type": "definition",
                "section": "Key Concepts Summary",
                "subsection": "Memory Hierarchy Concept"
              }
            ]
          },
          {
            "subsection": "Bus Design Trade-offs",
            "cardCount": 3,
            "cards": [
              {
                "id": "1-Key-Concepts-Summary-Bus-Design-Trade-offs-Dedicated-vs--Multiplexed",
                "title": "Dedicated vs. Multiplexed",
                "front": "Dedicated vs. Multiplexed",
                "back": "1. **Dedicated:** Better performance, more expensive\n2. **Multiplexed:** Lower cost, lower performance",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Bus Design Trade-offs"
              },
              {
                "id": "1-Key-Concepts-Summary-Bus-Design-Trade-offs-Synchronous-vs--Asynchronous",
                "title": "Synchronous vs. Asynchronous",
                "front": "Synchronous vs. Asynchronous",
                "back": "1. **Synchronous:** Simpler, predictable, limited by slowest device\n2. **Asynchronous:** More flexible, works with different speeds, more complex",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Bus Design Trade-offs"
              },
              {
                "id": "1-Key-Concepts-Summary-Bus-Design-Trade-offs-Single-vs--Multiple-Buses",
                "title": "Single vs. Multiple Buses",
                "front": "Single vs. Multiple Buses",
                "back": "1. **Single:** Simple, but becomes bottleneck\n2. **Multiple:** Better performance, more complex",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Bus Design Trade-offs"
              }
            ]
          },
          {
            "subsection": "Interrupt System Benefits",
            "cardCount": 1,
            "cards": [
              {
                "id": "1-Key-Concepts-Summary-Interrupt-System-Benefits-Interrupt-System-Benefits",
                "title": "Interrupt System Benefits",
                "front": "Interrupt System Benefits",
                "back": "1. **Efficiency:** CPU doesn't waste time waiting for I/O\n2. **Responsiveness:** System can respond to events immediately\n3. **Multitasking:** Enables time-sharing and pre-emptive scheduling\n4. **Error Handling:** Graceful error recovery",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Interrupt System Benefits"
              }
            ]
          }
        ]
      },
      {
        "section": "Practice Problems and Examples",
        "subsections": [
          {
            "subsection": "Problem 1: Address Bus Calculation",
            "cardCount": 3,
            "cards": [
              {
                "id": "1-Practice-Problems-and-Examples-Problem-1--Address-Bus-Calculation-Question",
                "title": "Question",
                "front": "Question",
                "back": "A microprocessor has a 20-bit address bus. What is the maximum directly addressable memory capacity?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Address Bus Calculation"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-1--Address-Bus-Calculation-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Address bus width: 20 bits\n2. Maximum addressable locations: 2^20 = 1,048,576 locations\n3. If each location stores 1 byte: 1,048,576 bytes = 1 MB\n4. If each location stores 1 word (4 bytes): 4 MB",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Address Bus Calculation"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-1--Address-Bus-Calculation-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1 MB (assuming byte-addressable memory)",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Address Bus Calculation"
              }
            ]
          },
          {
            "subsection": "Problem 2: Data Bus Performance",
            "cardCount": 3,
            "cards": [
              {
                "id": "1-Practice-Problems-and-Examples-Problem-2--Data-Bus-Performance-Question",
                "title": "Question",
                "front": "Question",
                "back": "A system has a 32-bit data bus running at 100 MHz. What is the theoretical maximum data transfer rate?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Data Bus Performance"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-2--Data-Bus-Performance-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Bus width: 32 bits = 4 bytes\n2. Bus frequency: 100 MHz = 100 million cycles per second\n3. Maximum transfer rate: 4 bytes × 100,000,000 cycles/sec = 400,000,000 bytes/sec\n4. = 400 MB/s",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Data Bus Performance"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-2--Data-Bus-Performance-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "400 MB/s",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Data Bus Performance"
              }
            ]
          },
          {
            "subsection": "Problem 3: Instruction Cycle Analysis",
            "cardCount": 3,
            "cards": [
              {
                "id": "1-Practice-Problems-and-Examples-Problem-3--Instruction-Cycle-Analysis-Question",
                "title": "Question",
                "front": "Question",
                "back": "For the instruction `ADD B, A` (add value at B to value at A, store result in A), how many memory accesses occur during the execute cycle?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: Instruction Cycle Analysis"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-3--Instruction-Cycle-Analysis-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Read memory location A → 1 access\n2. Read memory location B → 1 access\n3. Add values (in CPU, no memory access)\n4. Write result to memory location A → 1 access",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: Instruction Cycle Analysis"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-3--Instruction-Cycle-Analysis-Total",
                "title": "Total",
                "front": "Total",
                "back": "3 memory accesses (2 reads, 1 write)",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: Instruction Cycle Analysis"
              }
            ]
          },
          {
            "subsection": "Problem 4: Interrupt Efficiency",
            "cardCount": 4,
            "cards": [
              {
                "id": "1-Practice-Problems-and-Examples-Problem-4--Interrupt-Efficiency-Question",
                "title": "Question",
                "front": "Question",
                "back": "An I/O operation takes 10 ms. The CPU can execute 1 billion instructions per second. How many instructions can the CPU execute during the I/O operation if interrupts are used?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Interrupt Efficiency"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-4--Interrupt-Efficiency-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. I/O operation time: 10 ms = 0.01 seconds\n2. CPU speed: 1 billion instructions/second\n3. Instructions during I/O: 1,000,000,000 × 0.01 = 10,000,000 instructions",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Interrupt Efficiency"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-4--Interrupt-Efficiency-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "10 million instructions",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Interrupt Efficiency"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-4--Interrupt-Efficiency-Without-interrupts",
                "title": "Without interrupts",
                "front": "Without interrupts",
                "back": "CPU would wait idle, executing 0 instructions.",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Interrupt Efficiency"
              }
            ]
          },
          {
            "subsection": "Problem 5: Bus Arbitration",
            "cardCount": 3,
            "cards": [
              {
                "id": "1-Practice-Problems-and-Examples-Problem-5--Bus-Arbitration-Question",
                "title": "Question",
                "front": "Question",
                "back": "In a system with 4 devices requesting bus access, how does centralized arbitration work?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Bus Arbitration"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-5--Bus-Arbitration-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. All 4 devices send bus request to arbiter\n2. Arbiter determines priority (e.g., Device 1 = highest, Device 4 = lowest)\n3. Arbiter grants bus to Device 1\n4. Device 1 uses bus, completes operation, releases bus\n5. Arbiter grants bus to next device in priority order\n6. Process repeats",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Bus Arbitration"
              },
              {
                "id": "1-Practice-Problems-and-Examples-Problem-5--Bus-Arbitration-Key-Point",
                "title": "Key Point",
                "front": "Key Point",
                "back": "1. **Understand the Big Picture:**\n2. Start with the overall system architecture\n3. Understand how components connect and communicate\n4. Then dive into details of each component\n5. **Visualize the Data Flow:**\n6. Draw diagrams of instruction execution\n7. Trace data through the system\n8. Understand bus operations step-by-step\n9. **Practice Calculations:**\n10. Address bus width → memory capacity\n11. Data bus width → transfer rates\n12. Interrupt timing and efficiency\n13. **Compare and Contrast:**\n14. Dedicated vs. multiplexed buses\n15. Synchronous vs. asynchronous timing\n16. Centralized vs. distributed arbitration\n17. Traditional bus vs. point-to-point interconnect\n18. **Understand Trade-offs:**\n19. Performance vs. cost\n20. Complexity vs. simplicity\n21. Flexibility vs. speed\n22. **Relate to Real Systems:**\n23. Think about how these concepts apply to actual computers\n24. Consider modern systems (QPI, PCIe) vs. traditional systems\n25. Understand why systems evolved\n26. **Computers are programmable:** Same hardware, different programs\n27. **Components communicate via buses:** Shared communication pathways\n28. **Instructions execute in cycles:** Fetch, then execute\n29. **Interrupts improve efficiency:** CPU doesn't wait for slow devices\n30. **Bus design affects performance:** Width, timing, and architecture matter\n31. **Modern systems use point-to-point:** Better performance than shared buses\n32. CPU architecture (Group 2) builds on instruction execution\n33. Instruction sets (Group 3) define what instructions look like\n34. Memory systems (Group 4) connect via buses\n35. I/O systems (Group 6) use interrupts and DMA",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Bus Arbitration"
              }
            ]
          }
        ]
      }
    ],
    "allCards": [
      {
        "id": "1-Detailed-Study-Guide--Detailed-Study-Guide",
        "title": "Detailed Study Guide",
        "front": "Detailed Study Guide",
        "back": "1. [Introduction and Core Concepts](#introduction-and-core-concepts)\n2. [Computer Components Overview](#computer-components-overview)\n3. [Instruction Cycle](#instruction-cycle)\n4. [Interrupts](#interrupts)\n5. [System Interconnection: The Bus](#system-interconnection-the-bus)\n6. [Bus Architecture and Design](#bus-architecture-and-design)\n7. [Modern Interconnect Technologies](#modern-interconnect-technologies)\n8. [Key Concepts Summary](#key-concepts-summary)\n9. [Practice Problems and Examples](#practice-problems-and-examples)",
        "type": "list",
        "section": "Detailed Study Guide",
        "subsection": ""
      },
      {
        "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Fundamental-Principle",
        "title": "Fundamental Principle",
        "front": "Fundamental Principle",
        "back": "Modern computers use **programmable hardware** rather than hardwired systems.",
        "type": "definition",
        "section": "Introduction and Core Concepts",
        "subsection": "The Program Concept"
      },
      {
        "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Hardwired-vs--Programmable-Systems",
        "title": "Hardwired vs. Programmable Systems",
        "front": "Hardwired vs. Programmable Systems",
        "back": "",
        "type": "concept",
        "section": "Introduction and Core Concepts",
        "subsection": "The Program Concept"
      },
      {
        "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Hardwired-Systems",
        "title": "Hardwired Systems",
        "front": "Hardwired Systems",
        "back": "1. Inflexible - designed for one specific task\n2. Require physical rewiring to change functionality\n3. Example: Early calculators, dedicated control systems",
        "type": "list",
        "section": "Introduction and Core Concepts",
        "subsection": "The Program Concept"
      },
      {
        "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Programmable-Systems--General-Purpose-Hardware-",
        "title": "Programmable Systems (General-Purpose Hardware)",
        "front": "Programmable Systems (General-Purpose Hardware)",
        "back": "1. Flexible - can perform different tasks\n2. Same hardware executes different programs\n3. Change functionality by supplying new control signals (instructions)\n4. Example: Modern computers, smartphones, tablets",
        "type": "list",
        "section": "Introduction and Core Concepts",
        "subsection": "The Program Concept"
      },
      {
        "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-What-is-a-Program-",
        "title": "What is a Program?",
        "front": "What is a Program?",
        "back": "1. A **sequence of steps** (instructions)\n2. Each step performs an **arithmetic or logical operation**\n3. Each operation requires a **different set of control signals**\n4. The sequence of control signals determines the program's behavior",
        "type": "list",
        "section": "Introduction and Core Concepts",
        "subsection": "The Program Concept"
      },
      {
        "id": "1-Introduction-and-Core-Concepts-The-Program-Concept-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "The same hardware can execute completely different programs by changing the sequence of instructions.",
        "type": "definition",
        "section": "Introduction and Core Concepts",
        "subsection": "The Program Concept"
      },
      {
        "id": "1-Introduction-and-Core-Concepts-The-Control-Unit-Function",
        "title": "Function",
        "front": "Function",
        "back": "The Control Unit translates instruction codes into control signals.",
        "type": "definition",
        "section": "Introduction and Core Concepts",
        "subsection": "The Control Unit"
      },
      {
        "id": "1-Introduction-and-Core-Concepts-The-Control-Unit-Process",
        "title": "Process",
        "front": "Process",
        "back": "1. Each operation has a **unique code** (opcode)\n2. Examples: ADD, MOVE, SUBTRACT, JUMP\n3. The hardware accepts this code\n4. The hardware issues the appropriate **control signals** to execute the operation",
        "type": "list",
        "section": "Introduction and Core Concepts",
        "subsection": "The Control Unit"
      },
      {
        "id": "1-Introduction-and-Core-Concepts-The-Control-Unit-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. Instruction code: `ADD`\n2. Control signals generated:\n3. Enable ALU addition mode\n4. Route operands to ALU inputs\n5. Route result to destination register\n6. Update status flags",
        "type": "list",
        "section": "Introduction and Core Concepts",
        "subsection": "The Control Unit"
      },
      {
        "id": "1-Computer-Components-Overview-The-Four-Essential-Components-1--Central-Processing-Unit--CPU-",
        "title": "1. Central Processing Unit (CPU)",
        "front": "1. Central Processing Unit (CPU)",
        "back": "1. **Control Unit (CU):** Manages instruction execution, generates control signals\n2. **Arithmetic and Logic Unit (ALU):** Performs arithmetic and logical operations\n3. **Registers:** Fast, temporary storage within the CPU",
        "type": "list",
        "section": "Computer Components Overview",
        "subsection": "The Four Essential Components"
      },
      {
        "id": "1-Computer-Components-Overview-The-Four-Essential-Components-2--Main-Memory",
        "title": "2. Main Memory",
        "front": "2. Main Memory",
        "back": "1. Stores both **instructions** and **data**\n2. Temporary storage (volatile - loses data when power is off)\n3. Organized as a sequence of addressable locations\n4. Each location can store a word (typically 32 or 64 bits)",
        "type": "list",
        "section": "Computer Components Overview",
        "subsection": "The Four Essential Components"
      },
      {
        "id": "1-Computer-Components-Overview-The-Four-Essential-Components-3--Input-Output--I-O--Modules",
        "title": "3. Input/Output (I/O) Modules",
        "front": "3. Input/Output (I/O) Modules",
        "back": "1. Interface between the computer and external devices\n2. Handle data transfer to/from peripherals\n3. Examples: Keyboard, mouse, display, printer, disk drives, network interfaces",
        "type": "list",
        "section": "Computer Components Overview",
        "subsection": "The Four Essential Components"
      },
      {
        "id": "1-Computer-Components-Overview-The-Four-Essential-Components-4--System-Interconnection",
        "title": "4. System Interconnection",
        "front": "4. System Interconnection",
        "back": "1. **Bus:** Communication pathway connecting all components\n2. Enables data, address, and control signal transfer\n3. Critical for system performance",
        "type": "list",
        "section": "Computer Components Overview",
        "subsection": "The Four Essential Components"
      },
      {
        "id": "1-Computer-Components-Overview-Component-Relationships-Key-Point",
        "title": "Key Point",
        "front": "Key Point",
        "back": "All components communicate through the system bus. The bus is the shared communication pathway.",
        "type": "definition",
        "section": "Computer Components Overview",
        "subsection": "Component Relationships"
      },
      {
        "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Phase-1--Fetch-Cycle",
        "title": "Phase 1: Fetch Cycle",
        "front": "Phase 1: Fetch Cycle",
        "back": "",
        "type": "concept",
        "section": "Instruction Cycle",
        "subsection": "Basic Instruction Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Retrieve the next instruction from memory",
        "type": "definition",
        "section": "Instruction Cycle",
        "subsection": "Basic Instruction Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Steps",
        "title": "Steps",
        "front": "Steps",
        "back": "1. **Read Program Counter (PC):** PC contains the address of the next instruction\n2. **Fetch Instruction:** Read instruction from memory location pointed to by PC\n3. **Increment PC:** PC = PC + 1 (or appropriate increment based on instruction size)\n4. **Load Instruction Register (IR):** Store fetched instruction in IR for decoding",
        "type": "list",
        "section": "Instruction Cycle",
        "subsection": "Basic Instruction Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Example",
        "title": "Example",
        "front": "Example",
        "back": "PC = 1000 (address of next instruction) Fetch instruction from memory[1000] PC = 1001 (or 1004 if 32-bit instructions) IR = instruction from memory[1000]",
        "type": "definition",
        "section": "Instruction Cycle",
        "subsection": "Basic Instruction Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Phase-2--Execute-Cycle",
        "title": "Phase 2: Execute Cycle",
        "front": "Phase 2: Execute Cycle",
        "back": "",
        "type": "concept",
        "section": "Instruction Cycle",
        "subsection": "Basic Instruction Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Interpret and execute the instruction",
        "type": "definition",
        "section": "Instruction Cycle",
        "subsection": "Basic Instruction Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Basic-Instruction-Cycle-Types-of-Operations",
        "title": "Types of Operations",
        "front": "Types of Operations",
        "back": "1. **Processor-Memory:**\n2. Data transfer between CPU and main memory\n3. Read data from memory\n4. Write data to memory\n5. **Data Processing:**\n6. Arithmetic operations (ADD, SUBTRACT, MULTIPLY, DIVIDE)\n7. Logical operations (AND, OR, NOT, XOR)\n8. Shift operations (left, right, rotate)\n9. **Control:**\n10. Alteration of instruction sequence\n11. Jump instructions (unconditional)\n12. Branch instructions (conditional)\n13. Subroutine calls and returns\n14. **Processor-I/O:**\n15. Data transfer between CPU and I/O module\n16. Input operations\n17. Output operations",
        "type": "list",
        "section": "Instruction Cycle",
        "subsection": "Basic Instruction Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Instruction-Cycle-State-Diagram-Key-States",
        "title": "Key States",
        "front": "Key States",
        "back": "1. **Fetch:** Get instruction from memory\n2. **Execute:** Perform the operation\n3. **Interrupt Check:** (Added when interrupts are enabled)",
        "type": "list",
        "section": "Instruction Cycle",
        "subsection": "Instruction Cycle State Diagram"
      },
      {
        "id": "1-Instruction-Cycle-Multiple-Memory-Access-in-Execute-Cycle-Important",
        "title": "Important",
        "front": "Important",
        "back": "The execute cycle may require **multiple memory accesses**. **Example: PDP-11 Instruction `ADD B, A`** This instruction adds the value at memory location B to the value at memory location A.",
        "type": "definition",
        "section": "Instruction Cycle",
        "subsection": "Multiple Memory Access in Execute Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Multiple-Memory-Access-in-Execute-Cycle-Execute-Cycle-Steps",
        "title": "Execute Cycle Steps",
        "front": "Execute Cycle Steps",
        "back": "1. **Read memory location A** → Load into register R1\n2. **Read memory location B** → Load into register R2\n3. **Add R1 + R2** → Result in R1\n4. **Write R1** → Store result back to memory location A",
        "type": "list",
        "section": "Instruction Cycle",
        "subsection": "Multiple Memory Access in Execute Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Multiple-Memory-Access-in-Execute-Cycle-Total-Memory-Accesses",
        "title": "Total Memory Accesses",
        "front": "Total Memory Accesses",
        "back": "3 (2 reads, 1 write)",
        "type": "definition",
        "section": "Instruction Cycle",
        "subsection": "Multiple Memory Access in Execute Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Multiple-Memory-Access-in-Execute-Cycle-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "Complex instructions require multiple memory operations, making the execute cycle more complicated.",
        "type": "definition",
        "section": "Instruction Cycle",
        "subsection": "Multiple Memory Access in Execute Cycle"
      },
      {
        "id": "1-Instruction-Cycle-Instruction-Cycle-Timing-Without-Interrupts",
        "title": "Without Interrupts",
        "front": "Without Interrupts",
        "back": "Instruction 1: [Fetch] [Execute] [Fetch] [Execute] [Fetch] [Execute] ... Instruction 2: [Fetch] [Execute] [Fetch] [Execute] ... Instruction 3: [Fetch] [Execute] ...",
        "type": "definition",
        "section": "Instruction Cycle",
        "subsection": "Instruction Cycle Timing"
      },
      {
        "id": "1-Instruction-Cycle-Instruction-Cycle-Timing-Performance-Consideration",
        "title": "Performance Consideration",
        "front": "Performance Consideration",
        "back": "1. Fetch time depends on memory speed\n2. Execute time depends on instruction complexity\n3. Total cycle time = Fetch time + Execute time",
        "type": "list",
        "section": "Instruction Cycle",
        "subsection": "Instruction Cycle Timing"
      },
      {
        "id": "1-Interrupts-What-are-Interrupts--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "A mechanism by which other modules (e.g., I/O devices) can interrupt the normal sequence of instruction execution.",
        "type": "definition",
        "section": "Interrupts",
        "subsection": "What are Interrupts?"
      },
      {
        "id": "1-Interrupts-What-are-Interrupts--Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "1. **Improve Processing Efficiency:**\n2. External devices are much slower than the processor\n3. Don't want CPU to wait idle for I/O operations\n4. Example: Printer takes milliseconds to print; CPU can do millions of operations in that time\n5. **Error Handling:**\n6. Stop execution when errors occur\n7. Errors may or may not be recoverable\n8. Allows graceful error handling\n9. **Real-Time Response:**\n10. Respond to time-critical events immediately\n11. Example: User input, network packets, sensor data",
        "type": "list",
        "section": "Interrupts",
        "subsection": "What are Interrupts?"
      },
      {
        "id": "1-Interrupts-Classes-of-Interrupts-1--Program-Interrupts",
        "title": "1. Program Interrupts",
        "front": "1. Program Interrupts",
        "back": "1. Generated by program execution\n2. **Examples:**\n3. **Overflow:** Arithmetic operation result exceeds register capacity\n4. **Division by Zero:** Attempt to divide by zero\n5. **Illegal Instruction:** Invalid opcode encountered\n6. **Privilege Violation:** User program attempts privileged operation",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Classes of Interrupts"
      },
      {
        "id": "1-Interrupts-Classes-of-Interrupts-2--Timer-Interrupts",
        "title": "2. Timer Interrupts",
        "front": "2. Timer Interrupts",
        "back": "1. Generated by internal processor timer\n2. **Uses:**\n3. **Pre-emptive Multi-tasking:** OS switches between processes\n4. **Time Slicing:** Fair CPU time allocation\n5. **Real-Time Systems:** Periodic task scheduling\n6. **Example:** Every 10ms, timer interrupt triggers OS scheduler",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Classes of Interrupts"
      },
      {
        "id": "1-Interrupts-Classes-of-Interrupts-3--I-O-Interrupts",
        "title": "3. I/O Interrupts",
        "front": "3. I/O Interrupts",
        "back": "1. Generated by I/O controllers\n2. **Examples:**\n3. **Device Ready:** I/O operation completed\n4. **Device Error:** I/O operation failed\n5. **Data Available:** Input device has data ready\n6. **Example:** Printer finishes printing, interrupts CPU to request next page",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Classes of Interrupts"
      },
      {
        "id": "1-Interrupts-Classes-of-Interrupts-4--Hardware-Failure-Interrupts",
        "title": "4. Hardware Failure Interrupts",
        "front": "4. Hardware Failure Interrupts",
        "back": "1. Generated by hardware malfunctions\n2. **Examples:**\n3. **Power Failure:** Power supply issues detected\n4. **Memory Parity Error:** Data corruption detected in memory\n5. **Hardware Malfunction:** Component failure detected",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Classes of Interrupts"
      },
      {
        "id": "1-Interrupts-Transfer-of-Control-via-Interrupts-Normal-Flow",
        "title": "Normal Flow",
        "front": "Normal Flow",
        "back": "Instruction 1 → Instruction 2 → Instruction 3 → Instruction 4 → ...",
        "type": "definition",
        "section": "Interrupts",
        "subsection": "Transfer of Control via Interrupts"
      },
      {
        "id": "1-Interrupts-Transfer-of-Control-via-Interrupts-With-Interrupt",
        "title": "With Interrupt",
        "front": "With Interrupt",
        "back": "Instruction 1 → Instruction 2 → [INTERRUPT] → Interrupt Handler → Resume Instruction 3 → ...",
        "type": "definition",
        "section": "Interrupts",
        "subsection": "Transfer of Control via Interrupts"
      },
      {
        "id": "1-Interrupts-Transfer-of-Control-via-Interrupts-Key-Process",
        "title": "Key Process",
        "front": "Key Process",
        "back": "1. Current instruction completes (or is suspended)\n2. CPU saves current context (registers, PC, status)\n3. CPU jumps to interrupt handler routine\n4. Handler processes the interrupt\n5. CPU restores saved context\n6. CPU resumes execution from where it was interrupted",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Transfer of Control via Interrupts"
      },
      {
        "id": "1-Interrupts-Interrupt-Cycle-Modified-Instruction-Cycle",
        "title": "Modified Instruction Cycle",
        "front": "Modified Instruction Cycle",
        "back": "FETCH → EXECUTE → [INTERRUPT CHECK] → FETCH (next instruction) │ If interrupt pending: SAVE CONTEXT JUMP TO HANDLER PROCESS INTERRUPT RESTORE CONTEXT RETURN TO PROGRAM",
        "type": "definition",
        "section": "Interrupts",
        "subsection": "Interrupt Cycle"
      },
      {
        "id": "1-Interrupts-Interrupt-Cycle-Interrupt-Check-Steps",
        "title": "Interrupt Check Steps",
        "front": "Interrupt Check Steps",
        "back": "1. **Check for interrupt signal** (after each instruction)\n2. **If no interrupt:** Continue to fetch next instruction\n3. **If interrupt pending:**\n4. **Suspend** execution of current program\n5. **Save context:**\n6. Program Counter (PC)\n7. Processor Status Word (PSW)\n8. General-purpose registers\n9. Other processor state\n10. **Set PC** to start address of interrupt handler routine\n11. **Process interrupt** (execute handler)\n12. **Restore context** (restore saved state)\n13. **Continue** interrupted program",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Interrupt Cycle"
      },
      {
        "id": "1-Interrupts-Program-Timing-with-Interrupts-Without-Interrupts--Programmed-I-O--",
        "title": "Without Interrupts (Programmed I/O):",
        "front": "Without Interrupts (Programmed I/O):",
        "back": "CPU: [Execute] [Wait] [Wait] [Wait] [Wait] [Wait] [I/O Complete] [Continue] └─────────────────────────────────────────────────────────┘ CPU WASTED TIME",
        "type": "concept",
        "section": "Interrupts",
        "subsection": "Program Timing with Interrupts"
      },
      {
        "id": "1-Interrupts-Program-Timing-with-Interrupts-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "CPU sits idle waiting for slow I/O device.",
        "type": "definition",
        "section": "Interrupts",
        "subsection": "Program Timing with Interrupts"
      },
      {
        "id": "1-Interrupts-Program-Timing-with-Interrupts-With-Interrupts--Interrupt-Driven-I-O--",
        "title": "With Interrupts (Interrupt-Driven I/O):",
        "front": "With Interrupts (Interrupt-Driven I/O):",
        "back": "CPU: [Execute] [Execute] [Execute] [Execute] [Interrupt] [Handler] [Continue] I/O: [Start] [Working] [Working] [Working] [Complete] ──┘",
        "type": "concept",
        "section": "Interrupts",
        "subsection": "Program Timing with Interrupts"
      },
      {
        "id": "1-Interrupts-Program-Timing-with-Interrupts-Benefit",
        "title": "Benefit",
        "front": "Benefit",
        "back": "CPU can do useful work while I/O device operates.",
        "type": "definition",
        "section": "Interrupts",
        "subsection": "Program Timing with Interrupts"
      },
      {
        "id": "1-Interrupts-Program-Timing-with-Interrupts-Efficiency-Gain",
        "title": "Efficiency Gain",
        "front": "Efficiency Gain",
        "back": "1. **Short I/O Wait:** Small improvement\n2. **Long I/O Wait:** Massive improvement (CPU can execute thousands of instructions)",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Program Timing with Interrupts"
      },
      {
        "id": "1-Interrupts-Multiple-Interrupts-Strategy-1--Disable-Interrupts",
        "title": "Strategy 1: Disable Interrupts",
        "front": "Strategy 1: Disable Interrupts",
        "back": "1. **Approach:** Processor ignores further interrupts while processing one\n2. **Behavior:**\n3. Interrupts remain pending\n4. Checked after current interrupt is processed\n5. Handled in sequence as they occurred\n6. **Use Case:** Simple systems, low interrupt rates",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Multiple Interrupts"
      },
      {
        "id": "1-Interrupts-Multiple-Interrupts-Timeline",
        "title": "Timeline",
        "front": "Timeline",
        "back": "Interrupt 1 arrives → Process Interrupt 1 Interrupt 2 arrives → [IGNORED, pending] Interrupt 3 arrives → [IGNORED, pending] Interrupt 1 complete → Check pending → Process Interrupt 2 Interrupt 2 complete → Check pending → Process Interrupt 3",
        "type": "definition",
        "section": "Interrupts",
        "subsection": "Multiple Interrupts"
      },
      {
        "id": "1-Interrupts-Multiple-Interrupts-Strategy-2--Priority-Based--Nested-Interrupts-",
        "title": "Strategy 2: Priority-Based (Nested Interrupts)",
        "front": "Strategy 2: Priority-Based (Nested Interrupts)",
        "back": "1. **Approach:** Define interrupt priorities\n2. **Behavior:**\n3. Low priority interrupts can be interrupted by higher priority interrupts\n4. When high priority interrupt completes, return to previous interrupt\n5. Supports nested interrupt handling\n6. **Use Case:** Real-time systems, critical events",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Multiple Interrupts"
      },
      {
        "id": "1-Interrupts-Multiple-Interrupts-Priority-Levels--Example-",
        "title": "Priority Levels (Example)",
        "front": "Priority Levels (Example)",
        "back": "1. **Highest:** Hardware failure (power failure, memory error)\n2. **High:** Timer interrupts (system scheduling)\n3. **Medium:** I/O interrupts (device ready)\n4. **Lowest:** Program interrupts (overflow, division by zero)",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Multiple Interrupts"
      },
      {
        "id": "1-Interrupts-Multiple-Interrupts-Timeline--Nested-",
        "title": "Timeline (Nested)",
        "front": "Timeline (Nested)",
        "back": "Low Priority Interrupt 1 starts → High Priority Interrupt 2 arrives → Process Interrupt 2 (higher priority) → Interrupt 2 complete → Resume Interrupt 1 → Interrupt 1 complete",
        "type": "definition",
        "section": "Interrupts",
        "subsection": "Multiple Interrupts"
      },
      {
        "id": "1-Interrupts-Multiple-Interrupts-Timeline--Sequential-",
        "title": "Timeline (Sequential)",
        "front": "Timeline (Sequential)",
        "back": "Interrupt 1 arrives → Process Interrupt 1 → Complete Interrupt 2 arrives → Process Interrupt 2 → Complete Interrupt 3 arrives → Process Interrupt 3 → Complete",
        "type": "definition",
        "section": "Interrupts",
        "subsection": "Multiple Interrupts"
      },
      {
        "id": "1-Interrupts-Interrupt-Performance-Impact-Overhead",
        "title": "Overhead",
        "front": "Overhead",
        "back": "1. Context saving/restoring takes time\n2. Interrupt handler execution time\n3. Pipeline stalls (in pipelined processors)",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Interrupt Performance Impact"
      },
      {
        "id": "1-Interrupts-Interrupt-Performance-Impact-Benefit",
        "title": "Benefit",
        "front": "Benefit",
        "back": "1. Much greater than overhead for long I/O operations\n2. Enables multitasking and real-time response",
        "type": "list",
        "section": "Interrupts",
        "subsection": "Interrupt Performance Impact"
      },
      {
        "id": "1-System-Interconnection--The-Bus-What-is-a-Bus--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "A communication pathway connecting two or more devices.",
        "type": "definition",
        "section": "System Interconnection: The Bus",
        "subsection": "What is a Bus?"
      },
      {
        "id": "1-System-Interconnection--The-Bus-What-is-a-Bus--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Broadcast:** Signals sent on bus are received by all connected devices\n2. **Shared Resource:** Only one device can transmit at a time\n3. **Grouped Channels:** Multiple wires carrying related signals\n4. Example: 32-bit data bus = 32 separate wires (channels)",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "What is a Bus?"
      },
      {
        "id": "1-System-Interconnection--The-Bus-What-is-a-Bus--Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **Control/Address/Data bus (PC):** Traditional PC architecture\n2. **Unibus (DEC-PDP):** DEC's unified bus system",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "What is a Bus?"
      },
      {
        "id": "1-System-Interconnection--The-Bus-Bus-Interconnection-Scheme-Key-Point",
        "title": "Key Point",
        "front": "Key Point",
        "back": "All devices share the same bus. Only one can use it at a time.",
        "type": "definition",
        "section": "System Interconnection: The Bus",
        "subsection": "Bus Interconnection Scheme"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-1--Data-Bus",
        "title": "1. Data Bus",
        "front": "1. Data Bus",
        "back": "",
        "type": "concept",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Function",
        "title": "Function",
        "front": "Function",
        "back": "Carries data and instructions between components.",
        "type": "definition",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Key-Characteristics",
        "title": "Key Characteristics",
        "front": "Key Characteristics",
        "back": "1. **Bidirectional:** Data can flow in both directions\n2. **Width Matters:**\n3. 8-bit bus: Transfer 1 byte at a time\n4. 16-bit bus: Transfer 2 bytes at a time\n5. 32-bit bus: Transfer 4 bytes at a time\n6. 64-bit bus: Transfer 8 bytes at a time\n7. **Performance Impact:** Wider bus = faster data transfer",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Important-Note",
        "title": "Important Note",
        "front": "Important Note",
        "back": "At the bus level, there is **no difference between \"data\" and \"instructions\"**. Both are just binary patterns traveling on the data bus.",
        "type": "definition",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. 32-bit data bus can transfer a 32-bit instruction in one cycle\n2. Or transfer a 32-bit data value in one cycle",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-2--Address-Bus",
        "title": "2. Address Bus",
        "front": "2. Address Bus",
        "back": "",
        "type": "concept",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Function",
        "title": "Function",
        "front": "Function",
        "back": "Identifies the source or destination of data.",
        "type": "definition",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Key-Characteristics",
        "title": "Key Characteristics",
        "front": "Key Characteristics",
        "back": "1. **Unidirectional:** Typically CPU → Memory/I/O (CPU specifies address)\n2. **Width Determines Memory Capacity:**\n3. n-bit address bus = 2^n addressable locations\n4. Example: 16-bit address bus = 2^16 = 65,536 locations = 64 KB\n5. Example: 32-bit address bus = 2^32 = 4,294,967,296 locations = 4 GB",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Memory-Addressing-Example",
        "title": "Memory Addressing Example",
        "front": "Memory Addressing Example",
        "back": "1. CPU places 1000 on address bus\n2. Memory module sees address 1000\n3. Memory module places contents of location 1000 on data bus\n4. CPU reads data from data bus",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Historical-Example",
        "title": "Historical Example",
        "front": "Historical Example",
        "back": "1. Intel 8080: 16-bit address bus → 64 KB maximum memory\n2. Modern processors: 64-bit address bus → 16 exabytes theoretical maximum",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-3--Control-Bus",
        "title": "3. Control Bus",
        "front": "3. Control Bus",
        "back": "",
        "type": "concept",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Function",
        "title": "Function",
        "front": "Function",
        "back": "Carries control and timing information.",
        "type": "definition",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Key-Signals",
        "title": "Key Signals",
        "front": "Key Signals",
        "back": "1. **Memory Read:** Signal to read from memory\n2. **Memory Write:** Signal to write to memory\n3. **I/O Read:** Signal to read from I/O device\n4. **I/O Write:** Signal to write to I/O device\n5. **Interrupt Request (IRQ):** Device requesting interrupt\n6. **Interrupt Acknowledge:** CPU acknowledging interrupt\n7. **Bus Request:** Device requesting bus control\n8. **Bus Grant:** CPU granting bus control\n9. **Clock:** Synchronization signal\n10. **Reset:** System reset signal",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Control-Bus-Operations",
        "title": "Control Bus Operations",
        "front": "Control Bus Operations",
        "back": "",
        "type": "definition",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Sending-Data",
        "title": "Sending Data",
        "front": "Sending Data",
        "back": "1. Obtain use of the bus (bus arbitration)\n2. Place address on address bus\n3. Place data on data bus\n4. Assert appropriate control signal (e.g., Write)\n5. Wait for acknowledgment\n6. Release bus",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-The-Three-Types-of-Buses-Requesting-Data",
        "title": "Requesting Data",
        "front": "Requesting Data",
        "back": "1. Obtain use of the bus\n2. Place address on address bus\n3. Assert appropriate control signal (e.g., Read)\n4. Wait for data on data bus\n5. Read data from data bus\n6. Release bus",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "The Three Types of Buses"
      },
      {
        "id": "1-System-Interconnection--The-Bus-Bus-Width-and-Performance-Data-Bus-Width",
        "title": "Data Bus Width",
        "front": "Data Bus Width",
        "back": "1. Determines how much data can be transferred per cycle\n2. Wider = fewer cycles needed for large transfers\n3. Trade-off: More wires = higher cost",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "Bus Width and Performance"
      },
      {
        "id": "1-System-Interconnection--The-Bus-Bus-Width-and-Performance-Address-Bus-Width",
        "title": "Address Bus Width",
        "front": "Address Bus Width",
        "back": "1. Determines maximum addressable memory\n2. Wider = more memory can be addressed\n3. Trade-off: More wires = higher cost",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "Bus Width and Performance"
      },
      {
        "id": "1-System-Interconnection--The-Bus-Bus-Width-and-Performance-Example-Calculation",
        "title": "Example Calculation",
        "front": "Example Calculation",
        "back": "1. 32-bit data bus: Can transfer 4 bytes per cycle\n2. 32-bit address bus: Can address 4 GB of memory\n3. Number of transfers needed: 1 MB / 4 bytes = 262,144 transfers\n4. If each transfer takes 1 cycle: 262,144 cycles",
        "type": "list",
        "section": "System Interconnection: The Bus",
        "subsection": "Bus Width and Performance"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Single-Bus-Problems-Issues-with-Single-Bus-Architecture",
        "title": "Issues with Single Bus Architecture",
        "front": "Issues with Single Bus Architecture",
        "back": "1. **Propagation Delays:**\n2. Long bus = longer signal travel time\n3. Limits maximum bus speed\n4. Becomes worse with more devices\n5. **Bus Contention:**\n6. Many devices competing for bus access\n7. Coordination overhead increases\n8. Performance degrades as more devices added\n9. **Bandwidth Limitations:**\n10. Single bus has fixed bandwidth\n11. Aggregate data transfer approaches bus capacity\n12. Becomes bottleneck for high-performance systems",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Single Bus Problems"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Single-Bus-Problems-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Use **multiple buses** organized hierarchically.",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Single Bus Problems"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Traditional-Bus-Architecture-Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "├──► System Bus (High Speed) ├──► Memory Bus ──► Main Memory └──► Expansion Bus ──► I/O Devices",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Traditional Bus Architecture"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Traditional-Bus-Architecture-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **System Bus:** Fast, connects CPU and cache\n2. **Memory Bus:** Connects to main memory\n3. **Expansion Bus:** Slower, connects to I/O devices\n4. **Hierarchical:** Different speeds for different purposes",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Traditional Bus Architecture"
      },
      {
        "id": "1-Bus-Architecture-and-Design-High-Performance-Bus-Architecture-Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "├──► Local Bus (Very Fast) ──► Cache └──► System Bus (Fast) ──► Main Memory └──► Expansion Bus (Slower) ──► I/O Devices",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "High Performance Bus Architecture"
      },
      {
        "id": "1-Bus-Architecture-and-Design-High-Performance-Bus-Architecture-Benefits",
        "title": "Benefits",
        "front": "Benefits",
        "back": "1. **Local Bus:** Ultra-fast for CPU-cache communication\n2. **System Bus:** Fast for CPU-memory communication\n3. **Expansion Bus:** Adequate speed for I/O devices\n4. **Reduced Contention:** Different buses for different purposes",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "High Performance Bus Architecture"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Types-1--Dedicated-Bus",
        "title": "1. Dedicated Bus",
        "front": "1. Dedicated Bus",
        "back": "1. **Separate lines** for data and address\n2. **Advantages:**\n3. Simpler control logic\n4. Can transfer address and data simultaneously (in some cases)\n5. Better performance\n6. **Disadvantages:**\n7. More wires = higher cost\n8. More complex physical layout",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Types"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Types-Example",
        "title": "Example",
        "front": "Example",
        "back": "Data Bus: 32 wires (D0-D31) Address Bus: 32 wires (A0-A31) Control Bus: Various control signals Total: 64+ wires",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Types"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Types-2--Multiplexed-Bus",
        "title": "2. Multiplexed Bus",
        "front": "2. Multiplexed Bus",
        "back": "1. **Shared lines** for address and data\n2. **Control signal** indicates whether address or data is on bus\n3. **Advantages:**\n4. Fewer wires = lower cost\n5. Simpler physical layout\n6. **Disadvantages:**\n7. More complex control logic\n8. Requires two cycles (address, then data)\n9. Lower performance",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Types"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Types-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. ALE=1: Bus carries address\n2. ALE=0: Bus carries data",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Types"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Types-Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "Cycle 1: Place address on bus, assert ALE Cycle 2: Place data on bus, deassert ALE",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Types"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "Multiple devices may want to use the bus simultaneously.",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "**Bus Arbitration** - mechanism to determine which device gets bus access.",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Requirements",
        "title": "Requirements",
        "front": "Requirements",
        "back": "1. Only **one device** can control bus at a time\n2. Fair access to all devices\n3. Priority for time-critical operations\n4. Efficient arbitration (minimal overhead)",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Centralized-Arbitration",
        "title": "Centralized Arbitration",
        "front": "Centralized Arbitration",
        "back": "",
        "type": "concept",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "1. **Single hardware device** (bus controller/arbiter) controls bus access\n2. May be part of CPU or separate chip\n3. All devices request bus from arbiter\n4. Arbiter grants bus to one device at a time",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Simple logic in each device\n2. Centralized control\n3. Easy to implement priority schemes",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. Single point of failure\n2. May become bottleneck\n3. Centralized logic complexity",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Example",
        "title": "Example",
        "front": "Example",
        "back": "Device 1 ──┐ Device 2 ──┼──► Bus Arbiter ──► Bus Control Device 3 ──┘",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Distributed-Arbitration",
        "title": "Distributed Arbitration",
        "front": "Distributed Arbitration",
        "back": "",
        "type": "concept",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "1. **Each device** has arbitration logic\n2. Devices compete directly\n3. No central arbiter\n4. Self-selecting based on priority",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. No single point of failure\n2. Scalable\n3. Can be faster (parallel arbitration)",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. More complex logic in each device\n2. More expensive per device\n3. Harder to debug",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Arbitration-Example",
        "title": "Example",
        "front": "Example",
        "back": "Device 1 (Priority 3) ──┐ Device 2 (Priority 2) ──┼──► Bus (winner takes control) Device 3 (Priority 1) ──┘ (Device 3 wins - highest priority)",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Arbitration"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "Devices must coordinate when to read/write data.",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "**Timing protocols** ensure proper synchronization.",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Synchronous-Timing",
        "title": "Synchronous Timing",
        "front": "Synchronous Timing",
        "back": "",
        "type": "concept",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Events determined by **clock signals**\n2. Control bus includes **clock line**\n3. All devices read same clock\n4. Single clock cycle (1-0 transition) = one bus cycle\n5. Usually synchronize on **leading edge** (rising edge) of clock\n6. Usually one cycle per event",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Simple to implement\n2. Predictable timing\n3. Easy to design for",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. Limited by slowest device\n2. Clock skew problems at high speeds\n3. Inflexible (all devices must use same clock)",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Timing-Diagram",
        "title": "Timing Diagram",
        "front": "Timing Diagram",
        "back": "Clock: ──┐ ┐ ┐ ┐ └─────┘ └─────┘ Address: ──[A]─────────────── Data: └──[D]─────────── Read: └────────────────",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "1. **T1:** Address placed on address bus\n2. **T2:** Read signal asserted\n3. **T3:** Data available on data bus (memory responds)\n4. **T4:** Data read, signals deasserted",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Asynchronous-Timing",
        "title": "Asynchronous Timing",
        "front": "Asynchronous Timing",
        "back": "",
        "type": "concept",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **No common clock**\n2. Devices use **handshaking signals**\n3. **Request-Acknowledge** protocol\n4. Timing determined by device speeds, not fixed clock",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Signals",
        "title": "Signals",
        "front": "Signals",
        "back": "1. **Request (REQ):** Initiator requests operation\n2. **Acknowledge (ACK):** Target acknowledges completion\n3. **Ready:** Data ready signal",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Works with devices of different speeds\n2. No clock skew issues\n3. More flexible",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. More complex control logic\n2. Harder to design\n3. Variable timing (harder to predict)",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Read-Operation-Timing",
        "title": "Read Operation Timing",
        "front": "Read Operation Timing",
        "back": "Initiator places address on bus Initiator asserts REQ Target sees REQ, places data on bus Target asserts ACK Initiator reads data, deasserts REQ Target deasserts ACK",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Bus-Timing-Write-Operation-Timing",
        "title": "Write Operation Timing",
        "front": "Write Operation Timing",
        "back": "Initiator places address and data on bus Initiator asserts REQ Target reads data, asserts ACK Initiator deasserts REQ Target deasserts ACK",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Bus Timing"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Allow I/O modules to exchange data directly with memory, bypassing the CPU.",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Direct Memory Access (DMA) Fundamentals"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Traditional-Approach--Programmed-I-O-",
        "title": "Traditional Approach (Programmed I/O)",
        "front": "Traditional Approach (Programmed I/O)",
        "back": "CPU reads from I/O → CPU writes to Memory CPU reads from Memory → CPU writes to I/O",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Direct Memory Access (DMA) Fundamentals"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "CPU is involved in every data transfer, wasting CPU cycles.",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Direct Memory Access (DMA) Fundamentals"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-DMA-Approach",
        "title": "DMA Approach",
        "front": "DMA Approach",
        "back": "I/O Module ──► Memory (direct transfer, CPU not involved)",
        "type": "definition",
        "section": "Bus Architecture and Design",
        "subsection": "Direct Memory Access (DMA) Fundamentals"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Process",
        "title": "Process",
        "front": "Process",
        "back": "1. CPU grants DMA authority to I/O module\n2. I/O module issues read/write commands directly to memory\n3. CPU is free to do other work\n4. I/O module notifies CPU when transfer complete (interrupt)",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Direct Memory Access (DMA) Fundamentals"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Benefits",
        "title": "Benefits",
        "front": "Benefits",
        "back": "1. CPU not tied up during data transfer\n2. Much faster for large transfers\n3. Better overall system performance",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Direct Memory Access (DMA) Fundamentals"
      },
      {
        "id": "1-Bus-Architecture-and-Design-Direct-Memory-Access--DMA--Fundamentals-Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. Disk I/O (reading/writing files)\n2. Network I/O (receiving/sending packets)\n3. Graphics (transferring frame buffers)\n4. Audio (streaming audio data)",
        "type": "list",
        "section": "Bus Architecture and Design",
        "subsection": "Direct Memory Access (DMA) Fundamentals"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Evolution-from-Bus-to-Point-to-Point-Problems-with-Traditional-Buses",
        "title": "Problems with Traditional Buses",
        "front": "Problems with Traditional Buses",
        "back": "1. **Electrical Constraints:**\n2. Increasing frequency causes signal integrity issues\n3. Wide synchronous buses become difficult at high speeds\n4. Clock distribution becomes problematic\n5. **Synchronization and Arbitration:**\n6. Hard to perform in timely fashion at high data rates\n7. Arbitration overhead increases\n8. Becomes bottleneck\n9. **Multicore Challenges:**\n10. Multiple processors on single chip\n11. Shared bus on chip magnifies problems\n12. Need to keep up with processor speeds",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Evolution from Bus to Point-to-Point"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Evolution-from-Bus-to-Point-to-Point-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Lower Latency:** Direct connections, no bus arbitration\n2. **Higher Data Rate:** Can achieve much higher speeds\n3. **Better Scalability:** Add more connections without degrading performance\n4. **No Arbitration Overhead:** Direct connections eliminate contention",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Evolution from Bus to Point-to-Point"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--Introduction",
        "title": "Introduction",
        "front": "Introduction",
        "back": "Intel introduced QPI in 2008 for high-performance systems.",
        "type": "definition",
        "section": "Modern Interconnect Technologies",
        "subsection": "Quick Path Interconnect (QPI)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--Key-Features",
        "title": "Key Features",
        "front": "Key Features",
        "back": "1. **Multiple Direct Connections:** Pairwise connections between components\n2. **No Arbitration:** Eliminates need for bus arbitration\n3. **Layered Protocol:** Similar to network protocols\n4. **Packetized Transfer:** Data sent as packets with headers and error codes",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Quick Path Interconnect (QPI)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--QPI-Architecture-Layers",
        "title": "QPI Architecture Layers",
        "front": "QPI Architecture Layers",
        "back": "1. **Function:** Actual wires and circuitry for signal transmission\n2. **Unit:** **Phit (Physical Unit)** = 20 bits\n3. **Implementation:**\n4. 20 data lanes in each direction (transmit and receive)\n5. Plus clock lane in each direction\n6. **Differential Signaling:** Two wires per lane (balanced transmission)\n7. Current travels down one conductor, returns on other\n8. Binary value depends on voltage difference\n9. More noise-resistant than single-ended signaling\n10. **Function:** Reliable transmission and flow control\n11. **Unit:** **Flit (Flow Control Unit)** = 80 bits\n12. 72-bit message payload\n13. 8-bit error control code (CRC - Cyclic Redundancy Check)\n14. **Responsibilities:**\n15. **Flow Control:** Prevents sender from overwhelming receiver\n16. **Error Control:** Detects and recovers from bit errors\n17. **Function:** Determines packet path through system\n18. **Implementation:** Defined by firmware\n19. **Purpose:** Describes possible paths packets can follow\n20. **Function:** High-level rules for packet exchange\n21. **Unit:** **Packet** (comprised of integral number of Flits)\n22. **Key Feature:** Cache coherency protocol\n23. Ensures main memory values in multiple caches remain consistent\n24. Critical for multiprocessor systems",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Quick Path Interconnect (QPI)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--QPI-Physical-Interface",
        "title": "QPI Physical Interface",
        "front": "QPI Physical Interface",
        "back": "",
        "type": "concept",
        "section": "Modern Interconnect Technologies",
        "subsection": "Quick Path Interconnect (QPI)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "1. **84 individual links** per QPI port\n2. **20 data lanes** in each direction (40 total)\n3. **1 clock lane** in each direction (2 total)\n4. **Multilane Distribution:** 80-bit flits distributed across 20 lanes in round-robin fashion",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Quick Path Interconnect (QPI)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Quick-Path-Interconnect--QPI--Performance",
        "title": "Performance",
        "front": "Performance",
        "back": "1. Can transmit 20 bits in parallel in each direction\n2. Very high data rates achieved through parallel channels",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Quick Path Interconnect (QPI)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--Evolution",
        "title": "Evolution",
        "front": "Evolution",
        "back": "1. **PCI (Peripheral Component Interconnect):** Traditional bus-based scheme\n2. **PCIe (PCI Express):** Point-to-point interconnect replacing PCI",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Peripheral Component Interconnect Express (PCIe)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--Key-Requirements",
        "title": "Key Requirements",
        "front": "Key Requirements",
        "back": "1. High capacity for high data rate I/O devices\n2. Support for Gigabit Ethernet and faster\n3. Support time-dependent data streams (real-time audio/video)",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Peripheral Component Interconnect Express (PCIe)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--PCIe-Architecture-Layers",
        "title": "PCIe Architecture Layers",
        "front": "PCIe Architecture Layers",
        "back": "1. **Function:** Physical wires and transmission circuitry\n2. **Characteristics:**\n3. **Bidirectional Lanes:** Unlike QPI, lanes work both directions\n4. **Configurable Lanes:** 1, 4, 8, 16, or 32 lanes per port\n5. **Round-Robin Distribution:** Bits sent to lanes in round-robin\n6. **128-bit Processing:** Each lane processes 16 bytes (128 bits) at a time\n7. **130-bit Encoding:** Each 128-bit block encoded into 130-bit codeword\n8. **No Common Clock:** Receiver uses data transitions for synchronization\n9. **Transition Guarantee:** Extra 2 bits ensure transitions in long sequences of 1s\n10. **Function:** Reliable transmission and flow control\n11. **Unit:** **DLLP (Data Link Layer Packet)**\n12. **Responsibilities:**\n13. **Flow Control:** Regulates transmission rate\n14. **Power Management:** Manages power budgeting\n15. **ACK/NAK:** Acknowledges valid packets, requests retransmission of invalid packets\n16. **Function:** Generates and consumes data packets, manages flow\n17. **Unit:** **TLP (Transaction Layer Packet)**\n18. **Responsibilities:**\n19. Receives read/write requests from software\n20. Creates request packets for transmission\n21. **Split Transactions:** Most transactions use request-response pattern\n22. **Posted Transactions:** Some writes and messages don't expect response\n23. Supports 32-bit and 64-bit memory addressing",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Peripheral Component Interconnect Express (PCIe)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--PCIe-Configuration",
        "title": "PCIe Configuration",
        "front": "PCIe Configuration",
        "back": "",
        "type": "concept",
        "section": "Modern Interconnect Technologies",
        "subsection": "Peripheral Component Interconnect Express (PCIe)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--Typical-Setup",
        "title": "Typical Setup",
        "front": "Typical Setup",
        "back": "CPU ──► QPI ──► Memory Controller Hub ├──► PCIe ──► Graphics Card (x16) ├──► PCIe ──► Network Card (x1) └──► PCIe ──► Storage Controller (x4)",
        "type": "definition",
        "section": "Modern Interconnect Technologies",
        "subsection": "Peripheral Component Interconnect Express (PCIe)"
      },
      {
        "id": "1-Modern-Interconnect-Technologies-Peripheral-Component-Interconnect-Express--PCIe--Lane-Configurations",
        "title": "Lane Configurations",
        "front": "Lane Configurations",
        "back": "1. **x1:** 1 lane (low bandwidth devices)\n2. **x4:** 4 lanes (moderate bandwidth)\n3. **x8:** 8 lanes (high bandwidth)\n4. **x16:** 16 lanes (graphics cards, high-performance devices)",
        "type": "list",
        "section": "Modern Interconnect Technologies",
        "subsection": "Peripheral Component Interconnect Express (PCIe)"
      },
      {
        "id": "1-Key-Concepts-Summary-Fundamental-Principles-Fundamental-Principles",
        "title": "Fundamental Principles",
        "front": "Fundamental Principles",
        "back": "1. **Programmable Hardware:**\n2. Same hardware executes different programs\n3. Programs are sequences of instructions\n4. Instructions generate control signals\n5. **Component Communication:**\n6. All components communicate via system bus\n7. Bus is shared resource\n8. Only one device can use bus at a time\n9. **Instruction Execution:**\n10. Fetch-Execute cycle repeats\n11. Each instruction may require multiple memory accesses\n12. Interrupts can suspend normal execution\n13. **Performance Optimization:**\n14. Interrupts improve efficiency (CPU doesn't wait for I/O)\n15. Multiple buses reduce contention\n16. Point-to-point interconnects eliminate bus bottlenecks",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Fundamental Principles"
      },
      {
        "id": "1-Key-Concepts-Summary-Memory-Hierarchy-Concept-Levels--Fastest-to-Slowest-",
        "title": "Levels (Fastest to Slowest)",
        "front": "Levels (Fastest to Slowest)",
        "back": "1. **CPU Registers:** Fastest, smallest, most expensive\n2. **Cache Memory:** Very fast, small, expensive\n3. **Main Memory (RAM):** Fast, medium size, moderate cost\n4. **Secondary Storage (Disk):** Slow, large, cheap",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Memory Hierarchy Concept"
      },
      {
        "id": "1-Key-Concepts-Summary-Memory-Hierarchy-Concept-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Use fast, expensive memory for frequently accessed data; use slow, cheap memory for bulk storage.",
        "type": "definition",
        "section": "Key Concepts Summary",
        "subsection": "Memory Hierarchy Concept"
      },
      {
        "id": "1-Key-Concepts-Summary-Bus-Design-Trade-offs-Dedicated-vs--Multiplexed",
        "title": "Dedicated vs. Multiplexed",
        "front": "Dedicated vs. Multiplexed",
        "back": "1. **Dedicated:** Better performance, more expensive\n2. **Multiplexed:** Lower cost, lower performance",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Bus Design Trade-offs"
      },
      {
        "id": "1-Key-Concepts-Summary-Bus-Design-Trade-offs-Synchronous-vs--Asynchronous",
        "title": "Synchronous vs. Asynchronous",
        "front": "Synchronous vs. Asynchronous",
        "back": "1. **Synchronous:** Simpler, predictable, limited by slowest device\n2. **Asynchronous:** More flexible, works with different speeds, more complex",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Bus Design Trade-offs"
      },
      {
        "id": "1-Key-Concepts-Summary-Bus-Design-Trade-offs-Single-vs--Multiple-Buses",
        "title": "Single vs. Multiple Buses",
        "front": "Single vs. Multiple Buses",
        "back": "1. **Single:** Simple, but becomes bottleneck\n2. **Multiple:** Better performance, more complex",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Bus Design Trade-offs"
      },
      {
        "id": "1-Key-Concepts-Summary-Interrupt-System-Benefits-Interrupt-System-Benefits",
        "title": "Interrupt System Benefits",
        "front": "Interrupt System Benefits",
        "back": "1. **Efficiency:** CPU doesn't waste time waiting for I/O\n2. **Responsiveness:** System can respond to events immediately\n3. **Multitasking:** Enables time-sharing and pre-emptive scheduling\n4. **Error Handling:** Graceful error recovery",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Interrupt System Benefits"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-1--Address-Bus-Calculation-Question",
        "title": "Question",
        "front": "Question",
        "back": "A microprocessor has a 20-bit address bus. What is the maximum directly addressable memory capacity?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Address Bus Calculation"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-1--Address-Bus-Calculation-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Address bus width: 20 bits\n2. Maximum addressable locations: 2^20 = 1,048,576 locations\n3. If each location stores 1 byte: 1,048,576 bytes = 1 MB\n4. If each location stores 1 word (4 bytes): 4 MB",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Address Bus Calculation"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-1--Address-Bus-Calculation-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1 MB (assuming byte-addressable memory)",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Address Bus Calculation"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-2--Data-Bus-Performance-Question",
        "title": "Question",
        "front": "Question",
        "back": "A system has a 32-bit data bus running at 100 MHz. What is the theoretical maximum data transfer rate?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Data Bus Performance"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-2--Data-Bus-Performance-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Bus width: 32 bits = 4 bytes\n2. Bus frequency: 100 MHz = 100 million cycles per second\n3. Maximum transfer rate: 4 bytes × 100,000,000 cycles/sec = 400,000,000 bytes/sec\n4. = 400 MB/s",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Data Bus Performance"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-2--Data-Bus-Performance-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "400 MB/s",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Data Bus Performance"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-3--Instruction-Cycle-Analysis-Question",
        "title": "Question",
        "front": "Question",
        "back": "For the instruction `ADD B, A` (add value at B to value at A, store result in A), how many memory accesses occur during the execute cycle?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: Instruction Cycle Analysis"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-3--Instruction-Cycle-Analysis-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Read memory location A → 1 access\n2. Read memory location B → 1 access\n3. Add values (in CPU, no memory access)\n4. Write result to memory location A → 1 access",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: Instruction Cycle Analysis"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-3--Instruction-Cycle-Analysis-Total",
        "title": "Total",
        "front": "Total",
        "back": "3 memory accesses (2 reads, 1 write)",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: Instruction Cycle Analysis"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-4--Interrupt-Efficiency-Question",
        "title": "Question",
        "front": "Question",
        "back": "An I/O operation takes 10 ms. The CPU can execute 1 billion instructions per second. How many instructions can the CPU execute during the I/O operation if interrupts are used?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Interrupt Efficiency"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-4--Interrupt-Efficiency-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. I/O operation time: 10 ms = 0.01 seconds\n2. CPU speed: 1 billion instructions/second\n3. Instructions during I/O: 1,000,000,000 × 0.01 = 10,000,000 instructions",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Interrupt Efficiency"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-4--Interrupt-Efficiency-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "10 million instructions",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Interrupt Efficiency"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-4--Interrupt-Efficiency-Without-interrupts",
        "title": "Without interrupts",
        "front": "Without interrupts",
        "back": "CPU would wait idle, executing 0 instructions.",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Interrupt Efficiency"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-5--Bus-Arbitration-Question",
        "title": "Question",
        "front": "Question",
        "back": "In a system with 4 devices requesting bus access, how does centralized arbitration work?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Bus Arbitration"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-5--Bus-Arbitration-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. All 4 devices send bus request to arbiter\n2. Arbiter determines priority (e.g., Device 1 = highest, Device 4 = lowest)\n3. Arbiter grants bus to Device 1\n4. Device 1 uses bus, completes operation, releases bus\n5. Arbiter grants bus to next device in priority order\n6. Process repeats",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Bus Arbitration"
      },
      {
        "id": "1-Practice-Problems-and-Examples-Problem-5--Bus-Arbitration-Key-Point",
        "title": "Key Point",
        "front": "Key Point",
        "back": "1. **Understand the Big Picture:**\n2. Start with the overall system architecture\n3. Understand how components connect and communicate\n4. Then dive into details of each component\n5. **Visualize the Data Flow:**\n6. Draw diagrams of instruction execution\n7. Trace data through the system\n8. Understand bus operations step-by-step\n9. **Practice Calculations:**\n10. Address bus width → memory capacity\n11. Data bus width → transfer rates\n12. Interrupt timing and efficiency\n13. **Compare and Contrast:**\n14. Dedicated vs. multiplexed buses\n15. Synchronous vs. asynchronous timing\n16. Centralized vs. distributed arbitration\n17. Traditional bus vs. point-to-point interconnect\n18. **Understand Trade-offs:**\n19. Performance vs. cost\n20. Complexity vs. simplicity\n21. Flexibility vs. speed\n22. **Relate to Real Systems:**\n23. Think about how these concepts apply to actual computers\n24. Consider modern systems (QPI, PCIe) vs. traditional systems\n25. Understand why systems evolved\n26. **Computers are programmable:** Same hardware, different programs\n27. **Components communicate via buses:** Shared communication pathways\n28. **Instructions execute in cycles:** Fetch, then execute\n29. **Interrupts improve efficiency:** CPU doesn't wait for slow devices\n30. **Bus design affects performance:** Width, timing, and architecture matter\n31. **Modern systems use point-to-point:** Better performance than shared buses\n32. CPU architecture (Group 2) builds on instruction execution\n33. Instruction sets (Group 3) define what instructions look like\n34. Memory systems (Group 4) connect via buses\n35. I/O systems (Group 6) use interrupts and DMA",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Bus Arbitration"
      }
    ]
  },
  "2": {
    "group": 2,
    "totalCards": 207,
    "sections": [
      {
        "section": "Detailed Study Guide",
        "subsections": [
          {
            "subsection": "General",
            "cardCount": 1,
            "cards": [
              {
                "id": "2-Detailed-Study-Guide--Detailed-Study-Guide",
                "title": "Detailed Study Guide",
                "front": "Detailed Study Guide",
                "back": "1. [Introduction: Processor Organization](#introduction-processor-organization)\n2. [CPU Internal Structure](#cpu-internal-structure)\n3. [Register Organization](#register-organization)\n4. [Instruction Cycle Details](#instruction-cycle-details)\n5. [Pipelining Fundamentals](#pipelining-fundamentals)\n6. [MIPS Pipeline Case Study](#mips-pipeline-case-study)\n7. [Pipeline Hazards](#pipeline-hazards)\n8. [Data Hazards and Forwarding](#data-hazards-and-forwarding)\n9. [Control Hazards](#control-hazards)\n10. [Key Concepts Summary](#key-concepts-summary)\n11. [Practice Problems and Examples](#practice-problems-and-examples)",
                "type": "list",
                "section": "Detailed Study Guide",
                "subsection": ""
              }
            ]
          }
        ]
      },
      {
        "section": "Introduction: Processor Organization",
        "subsections": [
          {
            "subsection": "Processor Requirements",
            "cardCount": 5,
            "cards": [
              {
                "id": "2-Introduction--Processor-Organization-Processor-Requirements-1--Fetch-Instruction",
                "title": "1. Fetch Instruction",
                "front": "1. Fetch Instruction",
                "back": "1. **Purpose:** Read the next instruction to execute\n2. **Source:** Memory (register, cache, or main memory)\n3. **Process:**\n4. Read instruction from memory location\n5. Load instruction into processor\n6. Prepare for execution",
                "type": "list",
                "section": "Introduction: Processor Organization",
                "subsection": "Processor Requirements"
              },
              {
                "id": "2-Introduction--Processor-Organization-Processor-Requirements-2--Interpret-Instruction",
                "title": "2. Interpret Instruction",
                "front": "2. Interpret Instruction",
                "back": "1. **Purpose:** Determine what action the instruction requires\n2. **Process:**\n3. Decode the instruction opcode\n4. Identify operation type (ADD, SUB, LOAD, STORE, etc.)\n5. Determine operand locations\n6. Generate control signals",
                "type": "list",
                "section": "Introduction: Processor Organization",
                "subsection": "Processor Requirements"
              },
              {
                "id": "2-Introduction--Processor-Organization-Processor-Requirements-3--Fetch-Data",
                "title": "3. Fetch Data",
                "front": "3. Fetch Data",
                "back": "1. **Purpose:** Retrieve operands needed for instruction execution\n2. **Sources:**\n3. Memory (main memory or cache)\n4. I/O modules (for I/O operations)\n5. Registers (fastest source)\n6. **Note:** Not all instructions require data fetch (some operate on registers only)",
                "type": "list",
                "section": "Introduction: Processor Organization",
                "subsection": "Processor Requirements"
              },
              {
                "id": "2-Introduction--Processor-Organization-Processor-Requirements-4--Process-Data",
                "title": "4. Process Data",
                "front": "4. Process Data",
                "back": "1. **Purpose:** Perform the actual computation\n2. **Operations:**\n3. **Arithmetic:** ADD, SUBTRACT, MULTIPLY, DIVIDE\n4. **Logical:** AND, OR, NOT, XOR, SHIFT, ROTATE\n5. **Comparison:** Compare values, set condition codes\n6. **Location:** Typically performed in ALU (Arithmetic Logic Unit)",
                "type": "list",
                "section": "Introduction: Processor Organization",
                "subsection": "Processor Requirements"
              },
              {
                "id": "2-Introduction--Processor-Organization-Processor-Requirements-5--Write-Data",
                "title": "5. Write Data",
                "front": "5. Write Data",
                "back": "1. **Purpose:** Store results of computation\n2. **Destinations:**\n3. Memory (main memory or cache)\n4. I/O modules (for output operations)\n5. Registers (fastest destination)",
                "type": "list",
                "section": "Introduction: Processor Organization",
                "subsection": "Processor Requirements"
              }
            ]
          },
          {
            "subsection": "Internal Memory Requirement",
            "cardCount": 3,
            "cards": [
              {
                "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Key-Point",
                "title": "Key Point",
                "front": "Key Point",
                "back": "1. Instructions being executed\n2. Operands being processed\n3. Intermediate results\n4. Control information",
                "type": "list",
                "section": "Introduction: Processor Organization",
                "subsection": "Internal Memory Requirement"
              },
              {
                "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "**Registers** - fast, small memory locations within the CPU.",
                "type": "definition",
                "section": "Introduction: Processor Organization",
                "subsection": "Internal Memory Requirement"
              },
              {
                "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Memory-Hierarchy--Fastest-to-Slowest-",
                "title": "Memory Hierarchy (Fastest to Slowest)",
                "front": "Memory Hierarchy (Fastest to Slowest)",
                "back": "1. **CPU Registers** (fastest, smallest, most expensive)\n2. **Cache Memory** (very fast, small, expensive)\n3. **Main Memory** (fast, larger, moderate cost)\n4. **Secondary Storage** (slow, very large, cheap)",
                "type": "list",
                "section": "Introduction: Processor Organization",
                "subsection": "Internal Memory Requirement"
              }
            ]
          }
        ]
      },
      {
        "section": "CPU Internal Structure",
        "subsections": [
          {
            "subsection": "CPU-System Bus Connection",
            "cardCount": 2,
            "cards": [
              {
                "id": "2-CPU-Internal-Structure-CPU-System-Bus-Connection-CPU-System-Bus-Connection",
                "title": "CPU-System Bus Connection",
                "front": "CPU-System Bus Connection",
                "back": "1. **Data Bus:** For transferring data and instructions\n2. **Address Bus:** For specifying memory/I/O addresses\n3. **Control Bus:** For control and timing signals",
                "type": "list",
                "section": "CPU Internal Structure",
                "subsection": "CPU-System Bus Connection"
              },
              {
                "id": "2-CPU-Internal-Structure-CPU-System-Bus-Connection-Connection-Points",
                "title": "Connection Points",
                "front": "Connection Points",
                "back": "1. CPU reads instructions from memory via bus\n2. CPU reads/writes data via bus\n3. CPU sends control signals via bus\n4. CPU receives interrupt signals via bus",
                "type": "list",
                "section": "CPU Internal Structure",
                "subsection": "CPU-System Bus Connection"
              }
            ]
          },
          {
            "subsection": "Internal CPU Organization",
            "cardCount": 3,
            "cards": [
              {
                "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Key-Components",
                "title": "Key Components",
                "front": "Key Components",
                "back": "┌─────────────────────────────────────┐ │ CPU INTERNAL │ │ │ │ ┌──────────┐ ┌──────────┐ │ │ │ Control │ │ ALU │ │ │ │ Unit │◄────►│ │ │ │ └────┬─────┘ └────┬─────┘ │ │ │ │ │ │ ┌────┴─────────────────┴─────┐ │ │ │ Register File │ │ │ │ (User-Visible Registers) │ │ │ └─────────────────────────────┘ │ │ │ │ ┌─────────────────────────────┐ │ │ │ Control & Status Registers │ │ │ │ (PC, IR, MAR, MBR, PSW) │ │ │ └─────────────────────────────┘ │ │ │ └─────────────────────────────────────┘",
                "type": "definition",
                "section": "CPU Internal Structure",
                "subsection": "Internal CPU Organization"
              },
              {
                "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Data-Flow",
                "title": "Data Flow",
                "front": "Data Flow",
                "back": "1. **Control Unit:** Generates control signals based on instruction\n2. **ALU:** Performs arithmetic/logical operations\n3. **Registers:** Store operands and results\n4. **Internal Buses:** Connect components within CPU",
                "type": "list",
                "section": "CPU Internal Structure",
                "subsection": "Internal CPU Organization"
              },
              {
                "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "The CPU is a complex system with multiple components working together. Understanding how these components interact is crucial.",
                "type": "definition",
                "section": "CPU Internal Structure",
                "subsection": "Internal CPU Organization"
              }
            ]
          }
        ]
      },
      {
        "section": "Register Organization",
        "subsections": [
          {
            "subsection": "Register Hierarchy",
            "cardCount": 1,
            "cards": [
              {
                "id": "2-Register-Organization-Register-Hierarchy-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "1. Minimize main memory references\n2. Store frequently accessed data\n3. Hold operands and results\n4. Control processor operation",
                "type": "list",
                "section": "Register Organization",
                "subsection": "Register Hierarchy"
              }
            ]
          },
          {
            "subsection": "Two Categories of Registers",
            "cardCount": 11,
            "cards": [
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-1--User-Visible-Registers",
                "title": "1. User-Visible Registers",
                "front": "1. User-Visible Registers",
                "back": "",
                "type": "concept",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Registers that can be referenced by machine language or assembly language programs.",
                "type": "definition",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Enable programmers to optimize code by minimizing memory accesses.",
                "type": "definition",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-Categories",
                "title": "Categories",
                "front": "Categories",
                "back": "1. **Function:** Can be assigned to various functions by the programmer\n2. **Uses:**\n3. Hold operands for arithmetic/logical operations\n4. Hold addresses for memory operations\n5. Hold intermediate results\n6. Hold function parameters and return values\n7. **Examples:**\n8. x86: EAX, EBX, ECX, EDX (and more)\n9. MIPS: $0-$31 (32 general-purpose registers)\n10. ARM: R0-R15 (16 general-purpose registers)",
                "type": "list",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Flexibility: Can be used for any purpose\n2. Efficiency: Fast access, no memory references needed\n3. **Function:** Used only to hold data\n4. **Restriction:** Cannot be used in address calculations\n5. **Use Case:** Specialized registers for data operations\n6. **Example:** Some architectures separate data registers from address registers\n7. **Function:** Used for address calculations and memory addressing\n8. **Types:**\n9. **Segment Pointers:** Hold segment base addresses (x86 architecture)\n10. **Index Registers:** Used in indexed addressing modes\n11. **Stack Pointer (SP):** Points to top of stack\n12. **Base Pointer (BP):** Points to base of stack frame\n13. **Examples:**\n14. x86: ESI (source index), EDI (destination index), ESP (stack pointer), EBP (base pointer)\n15. MIPS: $sp (stack pointer), $fp (frame pointer)\n16. **Function:** Bits set by processor hardware as result of operations\n17. **Common Flags:**\n18. **Zero (Z):** Result is zero\n19. **Sign (S/N):** Result is negative\n20. **Carry (C):** Arithmetic carry occurred\n21. **Overflow (V):** Arithmetic overflow occurred\n22. **Parity (P):** Even/odd parity\n23. **Use:** Control conditional branches and program flow\n24. **Example:**",
                "type": "list",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-2--Control-and-Status-Registers",
                "title": "2. Control and Status Registers",
                "front": "2. Control and Status Registers",
                "back": "",
                "type": "concept",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Registers used by the control unit and operating system to control processor operation.",
                "type": "definition",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Manage instruction execution and system state.",
                "type": "definition",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-Essential-Registers",
                "title": "Essential Registers",
                "front": "Essential Registers",
                "back": "1. **Function:** Contains the address of the next instruction to fetch\n2. **Behavior:**\n3. Incremented after each instruction fetch\n4. Updated on branches, jumps, and subroutine calls\n5. Saved on interrupts, restored on return\n6. **Size:** Typically matches address bus width\n7. **Example:**\n8. **Function:** Contains the instruction most recently fetched\n9. **Behavior:**\n10. Loaded during fetch cycle\n11. Used by control unit for decoding\n12. Holds instruction until execution completes\n13. **Size:** Matches instruction width (typically 32 or 64 bits)\n14. **Function:** Contains the address of a location in memory\n15. **Use:**\n16. Holds address for memory read operations\n17. Holds address for memory write operations\n18. Connected to address bus\n19. **Size:** Matches address bus width\n20. **Function:** Contains data to be written to memory or data most recently read\n21. **Also Known As:** Memory Data Register (MDR)\n22. **Use:**\n23. Holds data being written to memory\n24. Holds data read from memory\n25. Connected to data bus\n26. **Size:** Matches data bus width",
                "type": "list",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-Data-Flow-Example--Memory-Read-",
                "title": "Data Flow Example (Memory Read)",
                "front": "Data Flow Example (Memory Read)",
                "back": "1. CPU places address in MAR\n2. CPU asserts Read signal\n3. Memory places data in MBR\n4. CPU reads data from MBR",
                "type": "list",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              },
              {
                "id": "2-Register-Organization-Two-Categories-of-Registers-Data-Flow-Example--Memory-Write-",
                "title": "Data Flow Example (Memory Write)",
                "front": "Data Flow Example (Memory Write)",
                "back": "1. CPU places address in MAR\n2. CPU places data in MBR\n3. CPU asserts Write signal\n4. Memory reads data from MBR and writes to address in MAR",
                "type": "list",
                "section": "Register Organization",
                "subsection": "Two Categories of Registers"
              }
            ]
          },
          {
            "subsection": "Program Status Word (PSW)",
            "cardCount": 4,
            "cards": [
              {
                "id": "2-Register-Organization-Program-Status-Word--PSW--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "A register (or set of registers) containing condition codes plus other status information.",
                "type": "definition",
                "section": "Register Organization",
                "subsection": "Program Status Word (PSW)"
              },
              {
                "id": "2-Register-Organization-Program-Status-Word--PSW--Common-Fields-Flags",
                "title": "Common Fields/Flags",
                "front": "Common Fields/Flags",
                "back": "1. **Sign (S/N):**\n2. Set when result is negative\n3. Used for signed comparisons\n4. **Zero (Z):**\n5. Set when result is zero\n6. Used for equality comparisons\n7. **Carry (C):**\n8. Set when arithmetic operation produces carry\n9. Used for unsigned arithmetic and multi-precision operations\n10. **Equal:**\n11. Set when two values are equal\n12. Used for comparisons\n13. **Overflow (V):**\n14. Set when signed arithmetic overflow occurs\n15. Used for error detection in signed arithmetic\n16. **Interrupt Enable/Disable:**\n17. Controls whether interrupts are processed\n18. Critical for interrupt handling\n19. **Supervisor (S):**\n20. Indicates processor mode (user vs. supervisor/kernel)\n21. Controls access to privileged instructions",
                "type": "list",
                "section": "Register Organization",
                "subsection": "Program Status Word (PSW)"
              },
              {
                "id": "2-Register-Organization-Program-Status-Word--PSW--PSW-Example",
                "title": "PSW Example",
                "front": "PSW Example",
                "back": "PSW = [S|Z|C|E|V|I|M|...] │ │ │ │ │ │ │ │ │ │ │ │ │ └─ Mode (Supervisor/User) │ │ │ │ │ └─── Interrupt Enable │ │ │ │ └───── Overflow │ │ │ └─────── Equal │ │ └───────── Carry │ └─────────── Zero └───────────── Sign",
                "type": "definition",
                "section": "Register Organization",
                "subsection": "Program Status Word (PSW)"
              },
              {
                "id": "2-Register-Organization-Program-Status-Word--PSW--Usage",
                "title": "Usage",
                "front": "Usage",
                "back": "1. Condition codes set automatically by ALU\n2. Used by conditional branch instructions\n3. Saved/restored on context switches\n4. Critical for program flow control",
                "type": "list",
                "section": "Register Organization",
                "subsection": "Program Status Word (PSW)"
              }
            ]
          }
        ]
      },
      {
        "section": "Instruction Cycle Details",
        "subsections": [
          {
            "subsection": "Complete Instruction Cycle",
            "cardCount": 17,
            "cards": [
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-1--Fetch-Cycle",
                "title": "Phase 1: Fetch Cycle",
                "front": "Phase 1: Fetch Cycle",
                "back": "",
                "type": "concept",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Retrieve instruction from memory.",
                "type": "definition",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
                "title": "Steps",
                "front": "Steps",
                "back": "1. **PC → MAR:** Transfer program counter to memory address register\n2. **Assert Read:** Signal memory to read\n3. **Memory → MBR:** Memory places instruction in memory buffer register\n4. **MBR → IR:** Transfer instruction to instruction register\n5. **Increment PC:** PC = PC + instruction_size",
                "type": "list",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Data-Flow",
                "title": "Data Flow",
                "front": "Data Flow",
                "back": "PC ──► MAR ──► Address Bus ──► Memory MBR ◄── Data Bus ◄── Memory",
                "type": "definition",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Timing",
                "title": "Timing",
                "front": "Timing",
                "back": "1. Typically takes 1-3 clock cycles\n2. Depends on memory speed and cache hit/miss",
                "type": "list",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-2--Indirect-Cycle",
                "title": "Phase 2: Indirect Cycle",
                "front": "Phase 2: Indirect Cycle",
                "back": "",
                "type": "concept",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Handle indirect addressing (when instruction specifies indirect address).",
                "type": "definition",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
                "title": "Steps",
                "front": "Steps",
                "back": "1. **IR → MAR:** Address field of instruction to MAR\n2. **Assert Read:** Read indirect address from memory\n3. **Memory → MBR:** Get actual address\n4. **MBR → MAR:** Use actual address for operand fetch",
                "type": "list",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-When-Used",
                "title": "When Used",
                "front": "When Used",
                "back": "1. Indirect addressing mode\n2. Pointer dereferencing\n3. Array indexing through pointers",
                "type": "list",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. Read address from R1 → MAR\n2. Read value at that address → MBR\n3. Use MBR as operand for ADD",
                "type": "list",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-3--Execute-Cycle",
                "title": "Phase 3: Execute Cycle",
                "front": "Phase 3: Execute Cycle",
                "back": "",
                "type": "concept",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Perform the actual operation.",
                "type": "definition",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Types-of-Execute-Cycles",
                "title": "Types of Execute Cycles",
                "front": "Types of Execute Cycles",
                "back": "1. Read R2 and R3 from register file\n2. ALU performs R2 + R3\n3. Write result to R1\n4. Address 1000 → MAR\n5. Assert Read\n6. Memory → MBR\n7. MBR → R1\n8. R1 → MBR\n9. Address 1000 → MAR\n10. Assert Write\n11. Memory reads from MBR\n12. R2, R3 → ALU inputs\n13. ALU performs addition\n14. ALU output → R1\n15. Update condition codes (PSW)\n16. Check Z flag in PSW\n17. If Z=1: PC = target\n18. If Z=0: PC = PC + 1 (continue)",
                "type": "list",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-4--Interrupt-Cycle",
                "title": "Phase 4: Interrupt Cycle",
                "front": "Phase 4: Interrupt Cycle",
                "back": "",
                "type": "concept",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Handle interrupts (covered in detail in Group 1).",
                "type": "definition",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
                "title": "Steps",
                "front": "Steps",
                "back": "1. **Save Context:** PC, PSW, registers → stack or special registers\n2. **Disable Interrupts:** Set interrupt disable flag\n3. **Load Handler Address:** Interrupt vector → PC\n4. **Jump to Handler:** Begin executing interrupt service routine",
                "type": "list",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              },
              {
                "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Data-Flow",
                "title": "Data Flow",
                "front": "Data Flow",
                "back": "Current PC ──► Save to stack Current PSW ──► Save to stack Registers ──► Save to stack Interrupt Vector ──► PC",
                "type": "definition",
                "section": "Instruction Cycle Details",
                "subsection": "Complete Instruction Cycle"
              }
            ]
          },
          {
            "subsection": "Instruction Cycle State Diagram",
            "cardCount": 2,
            "cards": [
              {
                "id": "2-Instruction-Cycle-Details-Instruction-Cycle-State-Diagram-States",
                "title": "States",
                "front": "States",
                "back": "FETCH ──► [Indirect?] ──► EXECUTE ──► [Interrupt?] ──► FETCH │ Yes │ Yes │ │ ▼ ▼ INDIRECT INTERRUPT │ │ └──────── EXECUTE ───────────────┘",
                "type": "definition",
                "section": "Instruction Cycle Details",
                "subsection": "Instruction Cycle State Diagram"
              },
              {
                "id": "2-Instruction-Cycle-Details-Instruction-Cycle-State-Diagram-Key-Points",
                "title": "Key Points",
                "front": "Key Points",
                "back": "1. Fetch always occurs first\n2. Indirect cycle is optional (only for indirect addressing)\n3. Execute always occurs (but varies greatly)\n4. Interrupt check occurs after execute\n5. Cycle repeats indefinitely",
                "type": "list",
                "section": "Instruction Cycle Details",
                "subsection": "Instruction Cycle State Diagram"
              }
            ]
          }
        ]
      },
      {
        "section": "Pipelining Fundamentals",
        "subsections": [
          {
            "subsection": "The Problem: Sequential Execution",
            "cardCount": 4,
            "cards": [
              {
                "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Traditional-Approach--Non-Pipelined-",
                "title": "Traditional Approach (Non-Pipelined)",
                "front": "Traditional Approach (Non-Pipelined)",
                "back": "Instruction 1: [Fetch] [Decode] [Execute] [Write] ──► Complete Instruction 2: [Fetch] [Decode] [Execute] [Write] ──► Complete Instruction 3: [Fetch] [Decode] [Execute] [Write] ──► Complete",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "The Problem: Sequential Execution"
              },
              {
                "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Time-per-instruction",
                "title": "Time per instruction",
                "front": "Time per instruction",
                "back": "Sum of all stages",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "The Problem: Sequential Execution"
              },
              {
                "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Throughput",
                "title": "Throughput",
                "front": "Throughput",
                "back": "1 instruction per (sum of stages)",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "The Problem: Sequential Execution"
              },
              {
                "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. Fetch: 200ps\n2. Decode: 100ps\n3. Execute: 200ps\n4. Write: 100ps\n5. **Total: 600ps per instruction**",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "The Problem: Sequential Execution"
              }
            ]
          },
          {
            "subsection": "The Solution: Pipelining",
            "cardCount": 4,
            "cards": [
              {
                "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Overlap execution of multiple instructions.",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "The Solution: Pipelining"
              },
              {
                "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Pipelined-Approach",
                "title": "Pipelined Approach",
                "front": "Pipelined Approach",
                "back": "Time: 1 2 3 4 5 6 7 8 Inst 1: [F] [D] [E] [W] Inst 2: [F] [D] [E] [W] Inst 3: [F] [D] [E] [W] Inst 4: [F] [D] [E] [W]",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "The Solution: Pipelining"
              },
              {
                "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "While Instruction 1 is in Execute stage, Instruction 2 can be in Decode stage, and Instruction 3 can be in Fetch stage.",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "The Solution: Pipelining"
              },
              {
                "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Benefits",
                "title": "Benefits",
                "front": "Benefits",
                "back": "1. **Throughput:** Multiple instructions in pipeline simultaneously\n2. **Efficiency:** Better resource utilization\n3. **Performance:** Significant speedup (ideally equal to number of stages)",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "The Solution: Pipelining"
              }
            ]
          },
          {
            "subsection": "Pipelining Analogy: Laundry",
            "cardCount": 4,
            "cards": [
              {
                "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Non-Pipelined-Laundry",
                "title": "Non-Pipelined Laundry",
                "front": "Non-Pipelined Laundry",
                "back": "Load 1: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Load 2: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Load 3: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Total: 240 minutes for 3 loads",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "Pipelining Analogy: Laundry"
              },
              {
                "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Pipelined-Laundry",
                "title": "Pipelined Laundry",
                "front": "Pipelined Laundry",
                "back": "Time: 0-30 30-60 60-80 80-110 110-140 140-160 Load 1: [Wash] [Dry] [Fold] Load 2: [Wash] [Dry] [Fold] Load 3: [Wash] [Dry] [Fold] Total: 160 minutes for 3 loads Speedup: 240/160 = 1.5x",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "Pipelining Analogy: Laundry"
              },
              {
                "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-With-4-Loads",
                "title": "With 4 Loads",
                "front": "With 4 Loads",
                "back": "1. Non-pipelined: 320 minutes\n2. Pipelined: 200 minutes (30 + 30 + 20 + 3×30)\n3. **Speedup: 320/200 = 1.6x**",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "Pipelining Analogy: Laundry"
              },
              {
                "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Ideal-Speedup",
                "title": "Ideal Speedup",
                "front": "Ideal Speedup",
                "back": "If all stages take equal time and there's enough work, speedup = number of stages.",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "Pipelining Analogy: Laundry"
              }
            ]
          },
          {
            "subsection": "Instruction Pipeline Stages",
            "cardCount": 6,
            "cards": [
              {
                "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-1--Fetch-Instruction--FI-",
                "title": "Stage 1: Fetch Instruction (FI)",
                "front": "Stage 1: Fetch Instruction (FI)",
                "back": "1. **Function:** Read the next expected instruction into a buffer\n2. **Operations:**\n3. PC → MAR\n4. Assert Read\n5. Memory → MBR → Instruction Buffer\n6. Increment PC\n7. **Time:** Depends on memory/cache access time",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "Instruction Pipeline Stages"
              },
              {
                "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-2--Decode-Instruction--DI-",
                "title": "Stage 2: Decode Instruction (DI)",
                "front": "Stage 2: Decode Instruction (DI)",
                "back": "1. **Function:** Determine the opcode and operand specifiers\n2. **Operations:**\n3. Extract opcode from instruction\n4. Identify instruction type\n5. Determine operand locations\n6. Generate control signals\n7. **Time:** Typically fast (register access)",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "Instruction Pipeline Stages"
              },
              {
                "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-3--Calculate-Operands--CO-",
                "title": "Stage 3: Calculate Operands (CO)",
                "front": "Stage 3: Calculate Operands (CO)",
                "back": "1. **Function:** Calculate the effective address of each source operand\n2. **Operations:**\n3. Handle addressing modes:\n4. Immediate: Use constant from instruction\n5. Direct: Use address from instruction\n6. Indirect: Read address, then use it\n7. Displacement: Base register + offset\n8. Register indirect: Use register value as address\n9. **Time:** Depends on addressing mode complexity",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "Instruction Pipeline Stages"
              },
              {
                "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-4--Fetch-Operands--FO-",
                "title": "Stage 4: Fetch Operands (FO)",
                "front": "Stage 4: Fetch Operands (FO)",
                "back": "1. **Function:** Fetch each operand from memory (if needed)\n2. **Operations:**\n3. Read operands from memory\n4. Read operands from registers\n5. Note: Register operands don't require memory access\n6. **Time:** Depends on operand location (register = fast, memory = slow)",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "Instruction Pipeline Stages"
              },
              {
                "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-5--Execute-Instruction--EI-",
                "title": "Stage 5: Execute Instruction (EI)",
                "front": "Stage 5: Execute Instruction (EI)",
                "back": "1. **Function:** Perform the indicated operation\n2. **Operations:**\n3. Arithmetic operations in ALU\n4. Logical operations in ALU\n5. Address calculations\n6. Comparisons\n7. **Time:** Depends on operation complexity",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "Instruction Pipeline Stages"
              },
              {
                "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-6--Write-Operand--WO-",
                "title": "Stage 6: Write Operand (WO)",
                "front": "Stage 6: Write Operand (WO)",
                "back": "1. **Function:** Store the result in memory or register\n2. **Operations:**\n3. Write result to destination register\n4. Write result to memory (if needed)\n5. Update condition codes\n6. **Time:** Depends on destination (register = fast, memory = slow)",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "Instruction Pipeline Stages"
              }
            ]
          },
          {
            "subsection": "Pipeline Performance Characteristics",
            "cardCount": 2,
            "cards": [
              {
                "id": "2-Pipelining-Fundamentals-Pipeline-Performance-Characteristics-Key-Metrics",
                "title": "Key Metrics",
                "front": "Key Metrics",
                "back": "1. **Throughput:** Instructions completed per unit time\n2. **Non-pipelined:** 1 instruction per (sum of all stages)\n3. **Pipelined:** 1 instruction per (longest stage time)\n4. **Latency:** Time from start to completion of single instruction\n5. **Non-pipelined:** Sum of all stages\n6. **Pipelined:** Still sum of all stages (not reduced!)\n7. **Speedup:** Ratio of non-pipelined time to pipelined time\n8. **Ideal:** Number of stages (if stages are balanced)\n9. **Actual:** Less than ideal due to hazards and stalls",
                "type": "list",
                "section": "Pipelining Fundamentals",
                "subsection": "Pipeline Performance Characteristics"
              },
              {
                "id": "2-Pipelining-Fundamentals-Pipeline-Performance-Characteristics-Critical-Insight",
                "title": "Critical Insight",
                "front": "Critical Insight",
                "back": "Pipelining improves **throughput** (how many instructions per second), but **not latency** (how long each instruction takes).",
                "type": "definition",
                "section": "Pipelining Fundamentals",
                "subsection": "Pipeline Performance Characteristics"
              }
            ]
          }
        ]
      },
      {
        "section": "MIPS Pipeline Case Study",
        "subsections": [
          {
            "subsection": "MIPS Pipeline Overview",
            "cardCount": 7,
            "cards": [
              {
                "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Architecture",
                "title": "Architecture",
                "front": "Architecture",
                "back": "5-stage pipeline, one step per stage.",
                "type": "definition",
                "section": "MIPS Pipeline Case Study",
                "subsection": "MIPS Pipeline Overview"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stages",
                "title": "Stages",
                "front": "Stages",
                "back": "",
                "type": "definition",
                "section": "MIPS Pipeline Case Study",
                "subsection": "MIPS Pipeline Overview"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-1--IF--Instruction-Fetch-",
                "title": "Stage 1: IF (Instruction Fetch)",
                "front": "Stage 1: IF (Instruction Fetch)",
                "back": "1. Fetch instruction from memory\n2. Update PC\n3. **Time:** 200ps (memory access)",
                "type": "list",
                "section": "MIPS Pipeline Case Study",
                "subsection": "MIPS Pipeline Overview"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-2--ID--Instruction-Decode---Register-Read-",
                "title": "Stage 2: ID (Instruction Decode & Register Read)",
                "front": "Stage 2: ID (Instruction Decode & Register Read)",
                "back": "1. Decode instruction\n2. Read register operands\n3. **Time:** 100ps (register access)",
                "type": "list",
                "section": "MIPS Pipeline Case Study",
                "subsection": "MIPS Pipeline Overview"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-3--EX--Execute-",
                "title": "Stage 3: EX (Execute)",
                "front": "Stage 3: EX (Execute)",
                "back": "1. Perform ALU operation\n2. Calculate address (for load/store)\n3. **Time:** 200ps (ALU operation)",
                "type": "list",
                "section": "MIPS Pipeline Case Study",
                "subsection": "MIPS Pipeline Overview"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-4--MEM--Memory-Access-",
                "title": "Stage 4: MEM (Memory Access)",
                "front": "Stage 4: MEM (Memory Access)",
                "back": "1. Access memory operand (for load/store only)\n2. **Time:** 200ps (memory access)\n3. **Note:** R-format and branch instructions skip this stage",
                "type": "list",
                "section": "MIPS Pipeline Case Study",
                "subsection": "MIPS Pipeline Overview"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-5--WB--Write-Back-",
                "title": "Stage 5: WB (Write Back)",
                "front": "Stage 5: WB (Write Back)",
                "back": "1. Write result back to register\n2. **Time:** 100ps (register write)",
                "type": "list",
                "section": "MIPS Pipeline Case Study",
                "subsection": "MIPS Pipeline Overview"
              }
            ]
          },
          {
            "subsection": "Instruction Types and Pipeline Usage",
            "cardCount": 4,
            "cards": [
              {
                "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Load-Word--lw-",
                "title": "Load Word (lw)",
                "front": "Load Word (lw)",
                "back": "lw $t0, 4($s1) # $t0 = memory[$s1 + 4] IF: Fetch instruction (200ps) ID: Decode, read $s1 (100ps) EX: Calculate address $s1 + 4 (200ps) MEM: Read memory[$s1 + 4] (200ps) WB: Write to $t0 (100ps) Total: 800ps",
                "type": "concept",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Instruction Types and Pipeline Usage"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Store-Word--sw-",
                "title": "Store Word (sw)",
                "front": "Store Word (sw)",
                "back": "sw $t0, 4($s1) # memory[$s1 + 4] = $t0 IF: Fetch instruction (200ps) ID: Decode, read $s1 and $t0 (100ps) EX: Calculate address $s1 + 4 (200ps) MEM: Write memory[$s1 + 4] (200ps) WB: (no write back for store) Total: 700ps (no WB stage needed)",
                "type": "concept",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Instruction Types and Pipeline Usage"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-R-Format--Register-Operations-",
                "title": "R-Format (Register Operations)",
                "front": "R-Format (Register Operations)",
                "back": "add $s0, $t0, $t1 # $s0 = $t0 + $t1 IF: Fetch instruction (200ps) ID: Decode, read $t0 and $t1 (100ps) EX: ALU operation $t0 + $t1 (200ps) MEM: (no memory access) WB: Write to $s0 (100ps) Total: 600ps",
                "type": "concept",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Instruction Types and Pipeline Usage"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Branch--beq-",
                "title": "Branch (beq)",
                "front": "Branch (beq)",
                "back": "beq $t0, $t1, label # if $t0 == $t1, branch to label IF: Fetch instruction (200ps) ID: Decode, read $t0 and $t1 (100ps) EX: Compare $t0 and $t1, calculate target address (200ps) MEM: (no memory access) WB: (no write back) Total: 500ps",
                "type": "concept",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Instruction Types and Pipeline Usage"
              }
            ]
          },
          {
            "subsection": "Pipeline Clock Cycle",
            "cardCount": 4,
            "cards": [
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Critical-Constraint",
                "title": "Critical Constraint",
                "front": "Critical Constraint",
                "back": "Pipeline clock cycle is limited by the **slowest stage**.",
                "type": "definition",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Clock Cycle"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. IF: 200ps\n2. ID: 100ps\n3. EX: 200ps\n4. MEM: 200ps\n5. WB: 100ps\n6. **Clock cycle = 200ps** (slowest stage)",
                "type": "list",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Clock Cycle"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Implication",
                "title": "Implication",
                "front": "Implication",
                "back": "All stages must complete within one clock cycle, even if they don't need the full time.",
                "type": "definition",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Clock Cycle"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Wasted-Time",
                "title": "Wasted Time",
                "front": "Wasted Time",
                "back": "1. ID stage completes in 100ps but must wait 200ps\n2. WB stage completes in 100ps but must wait 200ps\n3. **Trade-off:** Simpler design vs. efficiency",
                "type": "list",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Clock Cycle"
              }
            ]
          },
          {
            "subsection": "Pipeline Throughput",
            "cardCount": 3,
            "cards": [
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Non-Pipelined",
                "title": "Non-Pipelined",
                "front": "Non-Pipelined",
                "back": "1. Longest instruction: 800ps (lw)\n2. Throughput: 1 instruction per 800ps = 1.25 × 10^9 instructions/second",
                "type": "list",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Throughput"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Pipelined",
                "title": "Pipelined",
                "front": "Pipelined",
                "back": "1. Clock cycle: 200ps (slowest stage)\n2. Throughput: 1 instruction per 200ps = 5 × 10^9 instructions/second\n3. **Speedup: 4x** (close to ideal 5x for 5 stages)",
                "type": "list",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Throughput"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Key-Point",
                "title": "Key Point",
                "front": "Key Point",
                "back": "Even though some instructions take 800ps to complete, the pipeline can start a new instruction every 200ps.",
                "type": "definition",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Throughput"
              }
            ]
          },
          {
            "subsection": "Pipeline Timing Diagram",
            "cardCount": 3,
            "cards": [
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Non-Pipelined-Execution",
                "title": "Non-Pipelined Execution",
                "front": "Non-Pipelined Execution",
                "back": "Time: 0-800 800-1500 1500-2100 2100-2600 Inst 1: [lw] Inst 2: [sw] Inst 3: [add] Inst 4: [beq]",
                "type": "definition",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Timing Diagram"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Pipelined-Execution",
                "title": "Pipelined Execution",
                "front": "Pipelined Execution",
                "back": "Time: 0-200 200-400 400-600 600-800 800-1000 1000-1200 Inst 1: [IF] [ID] [EX] [MEM] [WB] Inst 2: [IF] [ID] [EX] [MEM] [WB] Inst 3: [IF] [ID] [EX] [MEM] [WB] Inst 4: [IF] [ID] [EX] [MEM] [WB]",
                "type": "definition",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Timing Diagram"
              },
              {
                "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Observation",
                "title": "Observation",
                "front": "Observation",
                "back": "At time 800ps, Instruction 1 completes, but Instructions 2, 3, and 4 are already in progress.",
                "type": "definition",
                "section": "MIPS Pipeline Case Study",
                "subsection": "Pipeline Timing Diagram"
              }
            ]
          }
        ]
      },
      {
        "section": "Pipeline Hazards",
        "subsections": [
          {
            "subsection": "What are Hazards?",
            "cardCount": 3,
            "cards": [
              {
                "id": "2-Pipeline-Hazards-What-are-Hazards--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Situations that prevent starting the next instruction in the next cycle.",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "What are Hazards?"
              },
              {
                "id": "2-Pipeline-Hazards-What-are-Hazards--Impact",
                "title": "Impact",
                "front": "Impact",
                "back": "Cause pipeline stalls (bubbles), reducing performance.",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "What are Hazards?"
              },
              {
                "id": "2-Pipeline-Hazards-What-are-Hazards--Types",
                "title": "Types",
                "front": "Types",
                "back": "1. **Structure Hazards:** Resource conflicts\n2. **Data Hazards:** Data dependencies\n3. **Control Hazards:** Branch dependencies",
                "type": "list",
                "section": "Pipeline Hazards",
                "subsection": "What are Hazards?"
              }
            ]
          },
          {
            "subsection": "Structure Hazards",
            "cardCount": 6,
            "cards": [
              {
                "id": "2-Pipeline-Hazards-Structure-Hazards-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "A required resource is busy when needed.",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Structure Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Structure-Hazards-Common-Cause",
                "title": "Common Cause",
                "front": "Common Cause",
                "back": "Multiple instructions need the same hardware resource simultaneously.",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Structure Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Structure-Hazards-Example--Single-Memory-for-Instructions-and-Data",
                "title": "Example: Single Memory for Instructions and Data",
                "front": "Example: Single Memory for Instructions and Data",
                "back": "",
                "type": "concept",
                "section": "Pipeline Hazards",
                "subsection": "Structure Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Structure-Hazards-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "Cycle 1: Instruction 1 in MEM stage (accessing data memory) Cycle 1: Instruction 2 in IF stage (needs to fetch instruction) └─► CONFLICT! Both need memory access",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Structure Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Structure-Hazards-Solution-Options",
                "title": "Solution Options",
                "front": "Solution Options",
                "back": "1. **Stall Pipeline:**\n2. Insert \"bubble\" (NOP - No Operation)\n3. Performance penalty\n4. **Separate Instruction and Data Memory:**\n5. Harvard Architecture\n6. No conflict possible\n7. More expensive\n8. **Cache with Separate I-Cache and D-Cache:**\n9. Instruction cache for IF stage\n10. Data cache for MEM stage\n11. Modern solution",
                "type": "list",
                "section": "Pipeline Hazards",
                "subsection": "Structure Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Structure-Hazards-Other-Structure-Hazards",
                "title": "Other Structure Hazards",
                "front": "Other Structure Hazards",
                "back": "1. Multiple instructions needing ALU simultaneously\n2. Register file port conflicts (need multiple read/write ports)",
                "type": "list",
                "section": "Pipeline Hazards",
                "subsection": "Structure Hazards"
              }
            ]
          },
          {
            "subsection": "Data Hazards",
            "cardCount": 6,
            "cards": [
              {
                "id": "2-Pipeline-Hazards-Data-Hazards-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Attempt to use data before it's ready.",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Data Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Data-Hazards-Cause",
                "title": "Cause",
                "front": "Cause",
                "back": "Instruction depends on result of previous instruction that hasn't completed yet.",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Data Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Data-Hazards-Example-",
                "title": "Example:",
                "front": "Example:",
                "back": "add $s0, $t0, $t1 # I1: $s0 = $t0 + $t1 sub $t2, $s0, $t3 # I2: $t2 = $s0 - $t3 (depends on I1)",
                "type": "concept",
                "section": "Pipeline Hazards",
                "subsection": "Data Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Data-Hazards-Pipeline-Timeline",
                "title": "Pipeline Timeline",
                "front": "Pipeline Timeline",
                "back": "Time: 1 2 3 4 5 6 I1: [IF] [ID] [EX] [MEM] [WB] I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here, but I1 writes in cycle 5!",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Data Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Data-Hazards-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "I2 needs $s0 in cycle 3 (ID stage), but I1 doesn't write $s0 until cycle 5 (WB stage).",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Data Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Data-Hazards-Solutions",
                "title": "Solutions",
                "front": "Solutions",
                "back": "1. **Stall Pipeline:** Insert bubbles until data is ready\n2. **Forwarding (Bypassing):** Use result directly from EX/MEM stage\n3. **Instruction Reordering:** Compiler reorders instructions to avoid hazard",
                "type": "list",
                "section": "Pipeline Hazards",
                "subsection": "Data Hazards"
              }
            ]
          },
          {
            "subsection": "Control Hazards",
            "cardCount": 6,
            "cards": [
              {
                "id": "2-Pipeline-Hazards-Control-Hazards-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Deciding on control action depends on previous instruction.",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Control Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Control-Hazards-Cause",
                "title": "Cause",
                "front": "Cause",
                "back": "Branch instructions determine which instruction to fetch next, but decision isn't known until later in pipeline.",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Control Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Control-Hazards-Example-",
                "title": "Example:",
                "front": "Example:",
                "back": "beq $t0, $t1, label # Branch if $t0 == $t1 add $s0, $s1, $s2 # Next instruction (may or may not execute)",
                "type": "concept",
                "section": "Pipeline Hazards",
                "subsection": "Control Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Control-Hazards-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "Time: 1 2 3 4 5 beq: [IF] [ID] [EX] [MEM] [WB] add: [IF] [ID] [EX] [MEM] [WB] └─► Branch decision made here But we already fetched 'add'!",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Control Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Control-Hazards-Issue",
                "title": "Issue",
                "front": "Issue",
                "back": "We don't know if branch will be taken until EX stage, but we already fetched the next instruction.",
                "type": "definition",
                "section": "Pipeline Hazards",
                "subsection": "Control Hazards"
              },
              {
                "id": "2-Pipeline-Hazards-Control-Hazards-Solutions",
                "title": "Solutions",
                "front": "Solutions",
                "back": "1. **Stall on Branch:** Wait until branch decision is known\n2. **Branch Prediction:** Predict whether branch will be taken\n3. **Delayed Branch:** Always execute instruction after branch\n4. **Multiple Streams:** Fetch from both possible paths\n5. **Prefetch Branch Target:** Prefetch target instruction",
                "type": "list",
                "section": "Pipeline Hazards",
                "subsection": "Control Hazards"
              }
            ]
          }
        ]
      },
      {
        "section": "Data Hazards and Forwarding",
        "subsections": [
          {
            "subsection": "Types of Data Hazards",
            "cardCount": 24,
            "cards": [
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-1--RAW--Read-After-Write----True-Dependency",
                "title": "1. RAW (Read After Write) - True Dependency",
                "front": "1. RAW (Read After Write) - True Dependency",
                "back": "",
                "type": "concept",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Instruction 2 tries to read an operand before Instruction 1 writes to it.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
                "title": "Example",
                "front": "Example",
                "back": "I1: add $s0, $t0, $t1 # I1 writes to $s0 I2: sub $t2, $s0, $t3 # I2 reads from $s0",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
                "title": "Timeline",
                "front": "Timeline",
                "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 written here I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here (too early!)",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
                "title": "Frequency",
                "front": "Frequency",
                "back": "Extremely common - most data dependencies are RAW.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Forwarding (bypassing) - use result from EX/MEM stage directly.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-2--WAR--Write-After-Read----Anti-Dependency",
                "title": "2. WAR (Write After Read) - Anti-Dependency",
                "front": "2. WAR (Write After Read) - Anti-Dependency",
                "back": "",
                "type": "concept",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Instruction 2 tries to write to a destination before Instruction 1 reads from it.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
                "title": "Example",
                "front": "Example",
                "back": "I1: add $t4, $t1, $t5 # I1 reads from $t5 I2: add $t5, $t1, $t2 # I2 writes to $t5",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
                "title": "Timeline",
                "front": "Timeline",
                "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t5 here I2: [IF] [ID] [EX] [MEM] [WB] └─► Writes $t5 here",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
                "title": "Frequency",
                "front": "Frequency",
                "back": "Uncommon/impossible in simple in-order pipelines.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Why",
                "title": "Why",
                "front": "Why",
                "back": "In simple pipelines, instructions execute in order, so I1 always reads before I2 writes.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Occurs-In",
                "title": "Occurs In",
                "front": "Occurs In",
                "back": "Out-of-order execution, superscalar processors.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-3--WAW--Write-After-Write----Output-Dependency",
                "title": "3. WAW (Write After Write) - Output Dependency",
                "front": "3. WAW (Write After Write) - Output Dependency",
                "back": "",
                "type": "concept",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Instruction 2 tries to write to an operand before Instruction 1 writes to it.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
                "title": "Example",
                "front": "Example",
                "back": "I1: add $s0, $t0, $t1 # I1 writes to $s0 I2: add $s0, $t2, $t3 # I2 writes to $s0",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
                "title": "Timeline",
                "front": "Timeline",
                "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Writes $s0 here I2: [IF] [ID] [EX] [MEM] [WB] └─► Writes $s0 here (must wait)",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
                "title": "Frequency",
                "front": "Frequency",
                "back": "Possible in simple pipelines, but not in the very simple pipeline we're assuming.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Delay I2's write until I1 completes.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-4--RAR--Read-After-Read----Not-a-Hazard",
                "title": "4. RAR (Read After Read) - Not a Hazard",
                "front": "4. RAR (Read After Read) - Not a Hazard",
                "back": "",
                "type": "concept",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Both instructions read from the same register.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
                "title": "Example",
                "front": "Example",
                "back": "I1: add $t1, $t2, $t3 # I1 reads from $t2 I2: add $t5, $t4, $t2 # I2 reads from $t2",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Why-Not-a-Hazard",
                "title": "Why Not a Hazard",
                "front": "Why Not a Hazard",
                "back": "Reading doesn't change the register value. Order doesn't matter.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
                "title": "Timeline",
                "front": "Timeline",
                "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t2 I2: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t2 (no problem!)",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Types of Data Hazards"
              }
            ]
          },
          {
            "subsection": "Forwarding (Bypassing)",
            "cardCount": 8,
            "cards": [
              {
                "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Use result directly from pipeline stage where it's computed, without waiting for it to be written to register.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Forwarding (Bypassing)"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Problem-Without-Forwarding",
                "title": "Problem Without Forwarding",
                "front": "Problem Without Forwarding",
                "back": "Time: 1 2 3 4 5 6 7 8 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available here I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0, must wait (stall) [stall] [stall] [EX] [MEM] [WB]",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Forwarding (Bypassing)"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Solution-With-Forwarding",
                "title": "Solution With Forwarding",
                "front": "Solution With Forwarding",
                "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 computed here I2: [IF] [ID] [EX] [MEM] [WB] └─► Forward $s0 directly from I1's EX stage",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Forwarding (Bypassing)"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Implementation",
                "title": "Implementation",
                "front": "Implementation",
                "back": "1. **Extra Connections:** Datapath connections from EX/MEM stage to EX stage inputs\n2. **Forwarding Unit:** Detects data hazards and selects forwarded data\n3. **Multiplexers:** Route forwarded data to ALU inputs",
                "type": "list",
                "section": "Data Hazards and Forwarding",
                "subsection": "Forwarding (Bypassing)"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Forwarding-Paths",
                "title": "Forwarding Paths",
                "front": "Forwarding Paths",
                "back": "1. **EX/MEM → EX:** Forward result from previous instruction's EX stage\n2. **MEM/WB → EX:** Forward result from two instructions ago\n3. **EX/MEM → MEM:** Forward result for store instructions",
                "type": "list",
                "section": "Data Hazards and Forwarding",
                "subsection": "Forwarding (Bypassing)"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Example",
                "title": "Example",
                "front": "Example",
                "back": "add $s0, $t0, $t1 # I1 sub $t2, $s0, $t3 # I2: needs $s0",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Forwarding (Bypassing)"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--With-Forwarding",
                "title": "With Forwarding",
                "front": "With Forwarding",
                "back": "1. I1 computes $s0 in EX stage (cycle 3)\n2. I2 needs $s0 in EX stage (cycle 4)\n3. Forwarding unit detects hazard\n4. Routes I1's EX output directly to I2's EX input\n5. **No stall needed!**",
                "type": "list",
                "section": "Data Hazards and Forwarding",
                "subsection": "Forwarding (Bypassing)"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Limitations",
                "title": "Limitations",
                "front": "Limitations",
                "back": "1. Forwarding can't help if data isn't computed yet\n2. Load instructions: Data only available after MEM stage\n3. May still need 1-cycle stall for load-use hazards",
                "type": "list",
                "section": "Data Hazards and Forwarding",
                "subsection": "Forwarding (Bypassing)"
              }
            ]
          },
          {
            "subsection": "Load-Use Hazard",
            "cardCount": 6,
            "cards": [
              {
                "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Special-Case",
                "title": "Special Case",
                "front": "Special Case",
                "back": "Load instruction followed by instruction using loaded value.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Load-Use Hazard"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Example",
                "title": "Example",
                "front": "Example",
                "back": "lw $s0, 0($t0) # I1: Load from memory add $t2, $s0, $t1 # I2: Use loaded value",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Load-Use Hazard"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Timeline",
                "title": "Timeline",
                "front": "Timeline",
                "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available here (after memory read) I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here (too early!)",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Load-Use Hazard"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "$s0 only available after MEM stage, but I2 needs it in EX stage.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Load-Use Hazard"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "**1-cycle stall** + forwarding Time: 1 2 3 4 5 6 7 8 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available I2: [IF] [ID] [stall] [EX] [MEM] [WB] └─► Forward $s0 from I1's MEM stage",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Load-Use Hazard"
              },
              {
                "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Key-Point",
                "title": "Key Point",
                "front": "Key Point",
                "back": "Even with forwarding, load-use hazards require at least 1 stall cycle.",
                "type": "definition",
                "section": "Data Hazards and Forwarding",
                "subsection": "Load-Use Hazard"
              }
            ]
          }
        ]
      },
      {
        "section": "Control Hazards",
        "subsections": [
          {
            "subsection": "The Branch Problem",
            "cardCount": 4,
            "cards": [
              {
                "id": "2-Control-Hazards-The-Branch-Problem-Issue",
                "title": "Issue",
                "front": "Issue",
                "back": "Branch instruction determines which instruction to fetch next, but decision isn't known until later in pipeline.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "The Branch Problem"
              },
              {
                "id": "2-Control-Hazards-The-Branch-Problem-Example",
                "title": "Example",
                "front": "Example",
                "back": "beq $t0, $t1, label # Branch if $t0 == $t1 add $s0, $s1, $s2 # Next instruction (may be wrong!) sub $t2, $t3, $t4 # Instruction at label (may be correct)",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "The Branch Problem"
              },
              {
                "id": "2-Control-Hazards-The-Branch-Problem-Pipeline-Timeline",
                "title": "Pipeline Timeline",
                "front": "Pipeline Timeline",
                "back": "Time: 1 2 3 4 5 beq: [IF] [ID] [EX] [MEM] [WB] └─► Branch decision made here add: [IF] [ID] [EX] [MEM] [WB] └─► Already fetched, but may be wrong!",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "The Branch Problem"
              },
              {
                "id": "2-Control-Hazards-The-Branch-Problem-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "1. Branch decision (taken/not taken) known in EX stage\n2. But we already fetched next instruction in IF stage\n3. If branch is taken, we fetched wrong instruction\n4. Must flush pipeline and fetch correct instruction",
                "type": "list",
                "section": "Control Hazards",
                "subsection": "The Branch Problem"
              }
            ]
          },
          {
            "subsection": "Branch Penalty",
            "cardCount": 2,
            "cards": [
              {
                "id": "2-Control-Hazards-Branch-Penalty-Cost",
                "title": "Cost",
                "front": "Cost",
                "back": "2-3 cycles wasted when branch is taken.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Branch Penalty"
              },
              {
                "id": "2-Control-Hazards-Branch-Penalty-Why",
                "title": "Why",
                "front": "Why",
                "back": "1. Branch decision in EX stage (cycle 3)\n2. Wrong instruction already in pipeline (cycles 2-3)\n3. Must flush and fetch correct instruction\n4. **Total penalty: 2 cycles minimum**",
                "type": "list",
                "section": "Control Hazards",
                "subsection": "Branch Penalty"
              }
            ]
          },
          {
            "subsection": "Solutions to Control Hazards",
            "cardCount": 28,
            "cards": [
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-1--Stall-on-Branch",
                "title": "1. Stall on Branch",
                "front": "1. Stall on Branch",
                "back": "",
                "type": "concept",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
                "title": "Approach",
                "front": "Approach",
                "back": "Don't fetch next instruction until branch decision is known.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
                "title": "Implementation",
                "front": "Implementation",
                "back": "beq: [IF] [ID] [EX] [MEM] [WB] next: [IF] [stall] [stall] [IF] [ID] [EX] [MEM] [WB] └─► Wait for branch decision",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
                "title": "Performance",
                "front": "Performance",
                "back": "2-cycle penalty for every branch (taken or not).",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Advantage",
                "title": "Advantage",
                "front": "Advantage",
                "back": "Simple, always correct.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
                "title": "Disadvantage",
                "front": "Disadvantage",
                "back": "High performance penalty.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-2--Branch-Prediction",
                "title": "2. Branch Prediction",
                "front": "2. Branch Prediction",
                "back": "",
                "type": "concept",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
                "title": "Approach",
                "front": "Approach",
                "back": "Predict whether branch will be taken, fetch predicted instruction.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Predictions",
                "title": "Predictions",
                "front": "Predictions",
                "back": "1. **Always Not Taken:** Assume branch never taken\n2. If correct: No penalty\n3. If wrong: 2-cycle penalty\n4. **Always Taken:** Assume branch always taken\n5. Fetch target immediately\n6. If correct: No penalty\n7. If wrong: 2-cycle penalty\n8. **Dynamic Prediction:** Use history to predict\n9. Branch prediction buffer/cache\n10. Tracks previous branch behavior\n11. More accurate predictions",
                "type": "list",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
                "title": "Performance",
                "front": "Performance",
                "back": "1. Correct prediction: No penalty\n2. Wrong prediction: 2-cycle penalty\n3. **Accuracy matters!**",
                "type": "list",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-3--Delayed-Branch",
                "title": "3. Delayed Branch",
                "front": "3. Delayed Branch",
                "back": "",
                "type": "concept",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
                "title": "Approach",
                "front": "Approach",
                "back": "Always execute instruction immediately after branch.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Example",
                "title": "Example",
                "front": "Example",
                "back": "beq $t0, $t1, label add $s0, $s1, $s2 # Always executes (delay slot) # If branch taken, jump to label # If branch not taken, continue normally",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Compiler-s-Job",
                "title": "Compiler's Job",
                "front": "Compiler's Job",
                "back": "Fill delay slot with useful instruction (or NOP if none available).",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
                "title": "Performance",
                "front": "Performance",
                "back": "No penalty if delay slot filled usefully.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
                "title": "Disadvantage",
                "front": "Disadvantage",
                "back": "Complicates compiler and instruction set.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-4--Multiple-Streams",
                "title": "4. Multiple Streams",
                "front": "4. Multiple Streams",
                "back": "",
                "type": "concept",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
                "title": "Approach",
                "front": "Approach",
                "back": "Fetch from both possible paths (taken and not taken).",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
                "title": "Implementation",
                "front": "Implementation",
                "back": "1. Fetch next sequential instruction\n2. Also fetch branch target instruction\n3. Execute both until branch decision known\n4. Discard wrong path",
                "type": "list",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
                "title": "Disadvantage",
                "front": "Disadvantage",
                "back": "Wastes resources, complex.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-5--Prefetch-Branch-Target",
                "title": "5. Prefetch Branch Target",
                "front": "5. Prefetch Branch Target",
                "back": "",
                "type": "concept",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
                "title": "Approach",
                "front": "Approach",
                "back": "Prefetch instruction at branch target while branch executes.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
                "title": "Implementation",
                "front": "Implementation",
                "back": "1. When branch detected, start fetching target\n2. If branch taken, target already fetched\n3. If branch not taken, discard prefetched instruction",
                "type": "list",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
                "title": "Performance",
                "front": "Performance",
                "back": "Reduces penalty if branch taken.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-6--Loop-Buffer",
                "title": "6. Loop Buffer",
                "front": "6. Loop Buffer",
                "back": "",
                "type": "concept",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
                "title": "Approach",
                "front": "Approach",
                "back": "Small buffer holding recently fetched instructions.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Use-Case",
                "title": "Use Case",
                "front": "Use Case",
                "back": "Small loops that fit in buffer.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              },
              {
                "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Benefit",
                "title": "Benefit",
                "front": "Benefit",
                "back": "If loop branches back, instructions already in buffer (no fetch needed).",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Solutions to Control Hazards"
              }
            ]
          },
          {
            "subsection": "Modern Branch Prediction",
            "cardCount": 2,
            "cards": [
              {
                "id": "2-Control-Hazards-Modern-Branch-Prediction-Techniques",
                "title": "Techniques",
                "front": "Techniques",
                "back": "1. **1-bit Predictor:** Remember last outcome\n2. **2-bit Predictor:** State machine (strong/weak taken/not taken)\n3. **Branch Target Buffer (BTB):** Cache branch targets\n4. **Return Address Stack:** Predict return addresses\n5. **Correlation-based:** Use history of other branches",
                "type": "list",
                "section": "Control Hazards",
                "subsection": "Modern Branch Prediction"
              },
              {
                "id": "2-Control-Hazards-Modern-Branch-Prediction-Performance",
                "title": "Performance",
                "front": "Performance",
                "back": "Modern processors achieve >95% branch prediction accuracy.",
                "type": "definition",
                "section": "Control Hazards",
                "subsection": "Modern Branch Prediction"
              }
            ]
          }
        ]
      },
      {
        "section": "Key Concepts Summary",
        "subsections": [
          {
            "subsection": "Processor Organization Principles",
            "cardCount": 1,
            "cards": [
              {
                "id": "2-Key-Concepts-Summary-Processor-Organization-Principles-Processor-Organization-Principles",
                "title": "Processor Organization Principles",
                "front": "Processor Organization Principles",
                "back": "1. **Five Fundamental Operations:**\n2. Fetch, Interpret, Fetch Data, Process Data, Write Data\n3. All instructions follow this pattern (with variations)\n4. **Register Hierarchy:**\n5. Fastest memory level\n6. Minimize main memory accesses\n7. Two categories: User-visible and Control/Status\n8. **Instruction Cycle:**\n9. Fetch → (Indirect) → Execute → (Interrupt)\n10. Each phase has specific data flow patterns",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Processor Organization Principles"
              }
            ]
          },
          {
            "subsection": "Pipelining Fundamentals",
            "cardCount": 1,
            "cards": [
              {
                "id": "2-Key-Concepts-Summary-Pipelining-Fundamentals-Pipelining-Fundamentals",
                "title": "Pipelining Fundamentals",
                "front": "Pipelining Fundamentals",
                "back": "1. **Goal:** Improve throughput, not latency\n2. **Method:** Overlap execution of multiple instructions\n3. **Ideal Speedup:** Equal to number of stages (if balanced)\n4. **Clock Cycle:** Limited by slowest stage",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Pipelining Fundamentals"
              }
            ]
          },
          {
            "subsection": "Pipeline Hazards",
            "cardCount": 1,
            "cards": [
              {
                "id": "2-Key-Concepts-Summary-Pipeline-Hazards-Pipeline-Hazards",
                "title": "Pipeline Hazards",
                "front": "Pipeline Hazards",
                "back": "1. **Structure Hazards:**\n2. Resource conflicts\n3. Solved by: Separate resources, stalling\n4. **Data Hazards:**\n5. Data dependencies\n6. Solved by: Forwarding, stalling, instruction reordering\n7. Types: RAW (common), WAR (rare), WAW (possible), RAR (not a hazard)\n8. **Control Hazards:**\n9. Branch dependencies\n10. Solved by: Prediction, stalling, delayed branch\n11. Penalty: 2-3 cycles typically",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Pipeline Hazards"
              }
            ]
          },
          {
            "subsection": "Performance Optimization",
            "cardCount": 1,
            "cards": [
              {
                "id": "2-Key-Concepts-Summary-Performance-Optimization-Performance-Optimization",
                "title": "Performance Optimization",
                "front": "Performance Optimization",
                "back": "1. **Forwarding:** Eliminates most data hazard stalls\n2. **Branch Prediction:** Reduces control hazard penalty\n3. **Balanced Pipeline:** Minimize wasted time in stages\n4. **Hazard Detection:** Identify and handle hazards efficiently",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Performance Optimization"
              }
            ]
          }
        ]
      },
      {
        "section": "Practice Problems and Examples",
        "subsections": [
          {
            "subsection": "Problem 1: Register Organization",
            "cardCount": 2,
            "cards": [
              {
                "id": "2-Practice-Problems-and-Examples-Problem-1--Register-Organization-Question",
                "title": "Question",
                "front": "Question",
                "back": "What is the difference between user-visible registers and control/status registers?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Register Organization"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-1--Register-Organization-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **User-Visible Registers:** Can be directly accessed by programs (assembly/machine code). Used for data operations, addresses, condition codes. Examples: General-purpose registers, stack pointer.\n2. **Control/Status Registers:** Used internally by processor and OS. Not directly accessible to user programs. Control instruction execution. Examples: PC, IR, MAR, MBR, PSW.",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Register Organization"
              }
            ]
          },
          {
            "subsection": "Problem 2: Pipeline Speedup",
            "cardCount": 3,
            "cards": [
              {
                "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Question",
                "title": "Question",
                "front": "Question",
                "back": "A 5-stage pipeline has stage times: 200ps, 150ps, 200ps, 180ps, 150ps. What is the clock cycle time and ideal speedup?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Pipeline Speedup"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Clock cycle = slowest stage = 200ps\n2. Non-pipelined time = 200 + 150 + 200 + 180 + 150 = 880ps\n3. Pipelined throughput = 1 instruction per 200ps\n4. Ideal speedup = 880/200 = 4.4x\n5. Maximum possible speedup = 5x (number of stages)",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Pipeline Speedup"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "Clock cycle = 200ps, Ideal speedup ≈ 4.4x",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Pipeline Speedup"
              }
            ]
          },
          {
            "subsection": "Problem 3: Data Hazard Detection",
            "cardCount": 2,
            "cards": [
              {
                "id": "2-Practice-Problems-and-Examples-Problem-3--Data-Hazard-Detection-Question",
                "title": "Question",
                "front": "Question",
                "back": "Identify the data hazard in this code: add $s0, $t0, $t1 sub $t2, $s0, $t3 mul $s1, $s0, $t4",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: Data Hazard Detection"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-3--Data-Hazard-Detection-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **RAW Hazard 1:** `sub` reads $s0 before `add` writes it\n2. **RAW Hazard 2:** `mul` reads $s0 before `add` writes it\n3. **Solution:** Forwarding can handle both (if $s0 available in time)",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: Data Hazard Detection"
              }
            ]
          },
          {
            "subsection": "Problem 4: Control Hazard Penalty",
            "cardCount": 3,
            "cards": [
              {
                "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Question",
                "title": "Question",
                "front": "Question",
                "back": "In a 5-stage pipeline, a branch instruction makes its decision in the EX stage. What is the minimum branch penalty?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Control Hazard Penalty"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Branch decision in EX stage (cycle 3)\n2. Wrong instruction already fetched in IF stage (cycle 2)\n3. Must flush wrong instruction and fetch correct one\n4. **Minimum penalty: 2 cycles** (cycles 2-3 wasted)",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Control Hazard Penalty"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "2 cycles minimum",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Control Hazard Penalty"
              }
            ]
          },
          {
            "subsection": "Problem 5: Forwarding Analysis",
            "cardCount": 2,
            "cards": [
              {
                "id": "2-Practice-Problems-and-Examples-Problem-5--Forwarding-Analysis-Question",
                "title": "Question",
                "front": "Question",
                "back": "Can forwarding eliminate the stall in this sequence? lw $s0, 0($t0) add $t2, $s0, $t1",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Forwarding Analysis"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-5--Forwarding-Analysis-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **No, cannot completely eliminate stall**\n2. $s0 only available after MEM stage of `lw`\n3. `add` needs $s0 in EX stage\n4. **1-cycle stall required** (load-use hazard)\n5. Forwarding can be used after the stall to avoid additional delays",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Forwarding Analysis"
              }
            ]
          },
          {
            "subsection": "Problem 6: Pipeline Efficiency",
            "cardCount": 3,
            "cards": [
              {
                "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Question",
                "title": "Question",
                "front": "Question",
                "back": "A pipeline has 5 stages, each taking 100ps. If 20% of instructions cause 1-cycle stalls, what is the average CPI (Cycles Per Instruction)?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 6: Pipeline Efficiency"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Ideal CPI = 1 (one instruction per cycle in steady state)\n2. 20% of instructions cause 1 extra cycle\n3. Average CPI = 1 + 0.2 × 1 = 1.2",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 6: Pipeline Efficiency"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "Average CPI = 1.2",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 6: Pipeline Efficiency"
              }
            ]
          },
          {
            "subsection": "Problem 7: Branch Prediction Impact",
            "cardCount": 3,
            "cards": [
              {
                "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Question",
                "title": "Question",
                "front": "Question",
                "back": "A program has 20% branch instructions. With 80% prediction accuracy, what is the average branch penalty?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 7: Branch Prediction Impact"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. 20% of instructions are branches\n2. 80% predicted correctly → 0 penalty\n3. 20% predicted incorrectly → 2-cycle penalty\n4. Average penalty per branch = 0.8 × 0 + 0.2 × 2 = 0.4 cycles\n5. Average penalty per instruction = 0.2 × 0.4 = 0.08 cycles",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 7: Branch Prediction Impact"
              },
              {
                "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **Understand Data Flow:**\n2. Trace how data moves through pipeline stages\n3. Understand register usage and memory access patterns\n4. Visualize instruction execution step-by-step\n5. **Master Hazard Types:**\n6. Structure: Resource conflicts\n7. Data: Dependencies (RAW most important)\n8. Control: Branches\n9. **Practice Pipeline Diagrams:**\n10. Draw pipeline timing diagrams\n11. Identify hazards visually\n12. Show forwarding paths\n13. **Calculate Performance:**\n14. Throughput vs. latency\n15. Speedup calculations\n16. CPI and performance impact\n17. **Compare Solutions:**\n18. Forwarding vs. stalling\n19. Branch prediction strategies\n20. Pipeline design trade-offs\n21. **Relate to Real Processors:**\n22. MIPS pipeline as concrete example\n23. Modern processors use similar concepts\n24. Understand why certain designs are used\n25. **Processors are complex:** Multiple components working together\n26. **Registers are critical:** Fastest memory, essential for performance\n27. **Pipelining improves throughput:** Overlap execution for speed\n28. **Hazards limit performance:** Must be detected and handled\n29. **Forwarding is powerful:** Eliminates most data hazard stalls\n30. **Branches are expensive:** Control hazards require sophisticated solutions\n31. Instruction sets (Group 3) - what instructions look like\n32. Memory systems (Group 4) - how data is stored and retrieved\n33. I/O systems (Group 6) - how external communication works",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 7: Branch Prediction Impact"
              }
            ]
          }
        ]
      }
    ],
    "allCards": [
      {
        "id": "2-Detailed-Study-Guide--Detailed-Study-Guide",
        "title": "Detailed Study Guide",
        "front": "Detailed Study Guide",
        "back": "1. [Introduction: Processor Organization](#introduction-processor-organization)\n2. [CPU Internal Structure](#cpu-internal-structure)\n3. [Register Organization](#register-organization)\n4. [Instruction Cycle Details](#instruction-cycle-details)\n5. [Pipelining Fundamentals](#pipelining-fundamentals)\n6. [MIPS Pipeline Case Study](#mips-pipeline-case-study)\n7. [Pipeline Hazards](#pipeline-hazards)\n8. [Data Hazards and Forwarding](#data-hazards-and-forwarding)\n9. [Control Hazards](#control-hazards)\n10. [Key Concepts Summary](#key-concepts-summary)\n11. [Practice Problems and Examples](#practice-problems-and-examples)",
        "type": "list",
        "section": "Detailed Study Guide",
        "subsection": ""
      },
      {
        "id": "2-Introduction--Processor-Organization-Processor-Requirements-1--Fetch-Instruction",
        "title": "1. Fetch Instruction",
        "front": "1. Fetch Instruction",
        "back": "1. **Purpose:** Read the next instruction to execute\n2. **Source:** Memory (register, cache, or main memory)\n3. **Process:**\n4. Read instruction from memory location\n5. Load instruction into processor\n6. Prepare for execution",
        "type": "list",
        "section": "Introduction: Processor Organization",
        "subsection": "Processor Requirements"
      },
      {
        "id": "2-Introduction--Processor-Organization-Processor-Requirements-2--Interpret-Instruction",
        "title": "2. Interpret Instruction",
        "front": "2. Interpret Instruction",
        "back": "1. **Purpose:** Determine what action the instruction requires\n2. **Process:**\n3. Decode the instruction opcode\n4. Identify operation type (ADD, SUB, LOAD, STORE, etc.)\n5. Determine operand locations\n6. Generate control signals",
        "type": "list",
        "section": "Introduction: Processor Organization",
        "subsection": "Processor Requirements"
      },
      {
        "id": "2-Introduction--Processor-Organization-Processor-Requirements-3--Fetch-Data",
        "title": "3. Fetch Data",
        "front": "3. Fetch Data",
        "back": "1. **Purpose:** Retrieve operands needed for instruction execution\n2. **Sources:**\n3. Memory (main memory or cache)\n4. I/O modules (for I/O operations)\n5. Registers (fastest source)\n6. **Note:** Not all instructions require data fetch (some operate on registers only)",
        "type": "list",
        "section": "Introduction: Processor Organization",
        "subsection": "Processor Requirements"
      },
      {
        "id": "2-Introduction--Processor-Organization-Processor-Requirements-4--Process-Data",
        "title": "4. Process Data",
        "front": "4. Process Data",
        "back": "1. **Purpose:** Perform the actual computation\n2. **Operations:**\n3. **Arithmetic:** ADD, SUBTRACT, MULTIPLY, DIVIDE\n4. **Logical:** AND, OR, NOT, XOR, SHIFT, ROTATE\n5. **Comparison:** Compare values, set condition codes\n6. **Location:** Typically performed in ALU (Arithmetic Logic Unit)",
        "type": "list",
        "section": "Introduction: Processor Organization",
        "subsection": "Processor Requirements"
      },
      {
        "id": "2-Introduction--Processor-Organization-Processor-Requirements-5--Write-Data",
        "title": "5. Write Data",
        "front": "5. Write Data",
        "back": "1. **Purpose:** Store results of computation\n2. **Destinations:**\n3. Memory (main memory or cache)\n4. I/O modules (for output operations)\n5. Registers (fastest destination)",
        "type": "list",
        "section": "Introduction: Processor Organization",
        "subsection": "Processor Requirements"
      },
      {
        "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Key-Point",
        "title": "Key Point",
        "front": "Key Point",
        "back": "1. Instructions being executed\n2. Operands being processed\n3. Intermediate results\n4. Control information",
        "type": "list",
        "section": "Introduction: Processor Organization",
        "subsection": "Internal Memory Requirement"
      },
      {
        "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "**Registers** - fast, small memory locations within the CPU.",
        "type": "definition",
        "section": "Introduction: Processor Organization",
        "subsection": "Internal Memory Requirement"
      },
      {
        "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Memory-Hierarchy--Fastest-to-Slowest-",
        "title": "Memory Hierarchy (Fastest to Slowest)",
        "front": "Memory Hierarchy (Fastest to Slowest)",
        "back": "1. **CPU Registers** (fastest, smallest, most expensive)\n2. **Cache Memory** (very fast, small, expensive)\n3. **Main Memory** (fast, larger, moderate cost)\n4. **Secondary Storage** (slow, very large, cheap)",
        "type": "list",
        "section": "Introduction: Processor Organization",
        "subsection": "Internal Memory Requirement"
      },
      {
        "id": "2-CPU-Internal-Structure-CPU-System-Bus-Connection-CPU-System-Bus-Connection",
        "title": "CPU-System Bus Connection",
        "front": "CPU-System Bus Connection",
        "back": "1. **Data Bus:** For transferring data and instructions\n2. **Address Bus:** For specifying memory/I/O addresses\n3. **Control Bus:** For control and timing signals",
        "type": "list",
        "section": "CPU Internal Structure",
        "subsection": "CPU-System Bus Connection"
      },
      {
        "id": "2-CPU-Internal-Structure-CPU-System-Bus-Connection-Connection-Points",
        "title": "Connection Points",
        "front": "Connection Points",
        "back": "1. CPU reads instructions from memory via bus\n2. CPU reads/writes data via bus\n3. CPU sends control signals via bus\n4. CPU receives interrupt signals via bus",
        "type": "list",
        "section": "CPU Internal Structure",
        "subsection": "CPU-System Bus Connection"
      },
      {
        "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Key-Components",
        "title": "Key Components",
        "front": "Key Components",
        "back": "┌─────────────────────────────────────┐ │ CPU INTERNAL │ │ │ │ ┌──────────┐ ┌──────────┐ │ │ │ Control │ │ ALU │ │ │ │ Unit │◄────►│ │ │ │ └────┬─────┘ └────┬─────┘ │ │ │ │ │ │ ┌────┴─────────────────┴─────┐ │ │ │ Register File │ │ │ │ (User-Visible Registers) │ │ │ └─────────────────────────────┘ │ │ │ │ ┌─────────────────────────────┐ │ │ │ Control & Status Registers │ │ │ │ (PC, IR, MAR, MBR, PSW) │ │ │ └─────────────────────────────┘ │ │ │ └─────────────────────────────────────┘",
        "type": "definition",
        "section": "CPU Internal Structure",
        "subsection": "Internal CPU Organization"
      },
      {
        "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Data-Flow",
        "title": "Data Flow",
        "front": "Data Flow",
        "back": "1. **Control Unit:** Generates control signals based on instruction\n2. **ALU:** Performs arithmetic/logical operations\n3. **Registers:** Store operands and results\n4. **Internal Buses:** Connect components within CPU",
        "type": "list",
        "section": "CPU Internal Structure",
        "subsection": "Internal CPU Organization"
      },
      {
        "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "The CPU is a complex system with multiple components working together. Understanding how these components interact is crucial.",
        "type": "definition",
        "section": "CPU Internal Structure",
        "subsection": "Internal CPU Organization"
      },
      {
        "id": "2-Register-Organization-Register-Hierarchy-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "1. Minimize main memory references\n2. Store frequently accessed data\n3. Hold operands and results\n4. Control processor operation",
        "type": "list",
        "section": "Register Organization",
        "subsection": "Register Hierarchy"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-1--User-Visible-Registers",
        "title": "1. User-Visible Registers",
        "front": "1. User-Visible Registers",
        "back": "",
        "type": "concept",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Registers that can be referenced by machine language or assembly language programs.",
        "type": "definition",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Enable programmers to optimize code by minimizing memory accesses.",
        "type": "definition",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-Categories",
        "title": "Categories",
        "front": "Categories",
        "back": "1. **Function:** Can be assigned to various functions by the programmer\n2. **Uses:**\n3. Hold operands for arithmetic/logical operations\n4. Hold addresses for memory operations\n5. Hold intermediate results\n6. Hold function parameters and return values\n7. **Examples:**\n8. x86: EAX, EBX, ECX, EDX (and more)\n9. MIPS: $0-$31 (32 general-purpose registers)\n10. ARM: R0-R15 (16 general-purpose registers)",
        "type": "list",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Flexibility: Can be used for any purpose\n2. Efficiency: Fast access, no memory references needed\n3. **Function:** Used only to hold data\n4. **Restriction:** Cannot be used in address calculations\n5. **Use Case:** Specialized registers for data operations\n6. **Example:** Some architectures separate data registers from address registers\n7. **Function:** Used for address calculations and memory addressing\n8. **Types:**\n9. **Segment Pointers:** Hold segment base addresses (x86 architecture)\n10. **Index Registers:** Used in indexed addressing modes\n11. **Stack Pointer (SP):** Points to top of stack\n12. **Base Pointer (BP):** Points to base of stack frame\n13. **Examples:**\n14. x86: ESI (source index), EDI (destination index), ESP (stack pointer), EBP (base pointer)\n15. MIPS: $sp (stack pointer), $fp (frame pointer)\n16. **Function:** Bits set by processor hardware as result of operations\n17. **Common Flags:**\n18. **Zero (Z):** Result is zero\n19. **Sign (S/N):** Result is negative\n20. **Carry (C):** Arithmetic carry occurred\n21. **Overflow (V):** Arithmetic overflow occurred\n22. **Parity (P):** Even/odd parity\n23. **Use:** Control conditional branches and program flow\n24. **Example:**",
        "type": "list",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-2--Control-and-Status-Registers",
        "title": "2. Control and Status Registers",
        "front": "2. Control and Status Registers",
        "back": "",
        "type": "concept",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Registers used by the control unit and operating system to control processor operation.",
        "type": "definition",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Manage instruction execution and system state.",
        "type": "definition",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-Essential-Registers",
        "title": "Essential Registers",
        "front": "Essential Registers",
        "back": "1. **Function:** Contains the address of the next instruction to fetch\n2. **Behavior:**\n3. Incremented after each instruction fetch\n4. Updated on branches, jumps, and subroutine calls\n5. Saved on interrupts, restored on return\n6. **Size:** Typically matches address bus width\n7. **Example:**\n8. **Function:** Contains the instruction most recently fetched\n9. **Behavior:**\n10. Loaded during fetch cycle\n11. Used by control unit for decoding\n12. Holds instruction until execution completes\n13. **Size:** Matches instruction width (typically 32 or 64 bits)\n14. **Function:** Contains the address of a location in memory\n15. **Use:**\n16. Holds address for memory read operations\n17. Holds address for memory write operations\n18. Connected to address bus\n19. **Size:** Matches address bus width\n20. **Function:** Contains data to be written to memory or data most recently read\n21. **Also Known As:** Memory Data Register (MDR)\n22. **Use:**\n23. Holds data being written to memory\n24. Holds data read from memory\n25. Connected to data bus\n26. **Size:** Matches data bus width",
        "type": "list",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-Data-Flow-Example--Memory-Read-",
        "title": "Data Flow Example (Memory Read)",
        "front": "Data Flow Example (Memory Read)",
        "back": "1. CPU places address in MAR\n2. CPU asserts Read signal\n3. Memory places data in MBR\n4. CPU reads data from MBR",
        "type": "list",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Two-Categories-of-Registers-Data-Flow-Example--Memory-Write-",
        "title": "Data Flow Example (Memory Write)",
        "front": "Data Flow Example (Memory Write)",
        "back": "1. CPU places address in MAR\n2. CPU places data in MBR\n3. CPU asserts Write signal\n4. Memory reads data from MBR and writes to address in MAR",
        "type": "list",
        "section": "Register Organization",
        "subsection": "Two Categories of Registers"
      },
      {
        "id": "2-Register-Organization-Program-Status-Word--PSW--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "A register (or set of registers) containing condition codes plus other status information.",
        "type": "definition",
        "section": "Register Organization",
        "subsection": "Program Status Word (PSW)"
      },
      {
        "id": "2-Register-Organization-Program-Status-Word--PSW--Common-Fields-Flags",
        "title": "Common Fields/Flags",
        "front": "Common Fields/Flags",
        "back": "1. **Sign (S/N):**\n2. Set when result is negative\n3. Used for signed comparisons\n4. **Zero (Z):**\n5. Set when result is zero\n6. Used for equality comparisons\n7. **Carry (C):**\n8. Set when arithmetic operation produces carry\n9. Used for unsigned arithmetic and multi-precision operations\n10. **Equal:**\n11. Set when two values are equal\n12. Used for comparisons\n13. **Overflow (V):**\n14. Set when signed arithmetic overflow occurs\n15. Used for error detection in signed arithmetic\n16. **Interrupt Enable/Disable:**\n17. Controls whether interrupts are processed\n18. Critical for interrupt handling\n19. **Supervisor (S):**\n20. Indicates processor mode (user vs. supervisor/kernel)\n21. Controls access to privileged instructions",
        "type": "list",
        "section": "Register Organization",
        "subsection": "Program Status Word (PSW)"
      },
      {
        "id": "2-Register-Organization-Program-Status-Word--PSW--PSW-Example",
        "title": "PSW Example",
        "front": "PSW Example",
        "back": "PSW = [S|Z|C|E|V|I|M|...] │ │ │ │ │ │ │ │ │ │ │ │ │ └─ Mode (Supervisor/User) │ │ │ │ │ └─── Interrupt Enable │ │ │ │ └───── Overflow │ │ │ └─────── Equal │ │ └───────── Carry │ └─────────── Zero └───────────── Sign",
        "type": "definition",
        "section": "Register Organization",
        "subsection": "Program Status Word (PSW)"
      },
      {
        "id": "2-Register-Organization-Program-Status-Word--PSW--Usage",
        "title": "Usage",
        "front": "Usage",
        "back": "1. Condition codes set automatically by ALU\n2. Used by conditional branch instructions\n3. Saved/restored on context switches\n4. Critical for program flow control",
        "type": "list",
        "section": "Register Organization",
        "subsection": "Program Status Word (PSW)"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-1--Fetch-Cycle",
        "title": "Phase 1: Fetch Cycle",
        "front": "Phase 1: Fetch Cycle",
        "back": "",
        "type": "concept",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Retrieve instruction from memory.",
        "type": "definition",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
        "title": "Steps",
        "front": "Steps",
        "back": "1. **PC → MAR:** Transfer program counter to memory address register\n2. **Assert Read:** Signal memory to read\n3. **Memory → MBR:** Memory places instruction in memory buffer register\n4. **MBR → IR:** Transfer instruction to instruction register\n5. **Increment PC:** PC = PC + instruction_size",
        "type": "list",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Data-Flow",
        "title": "Data Flow",
        "front": "Data Flow",
        "back": "PC ──► MAR ──► Address Bus ──► Memory MBR ◄── Data Bus ◄── Memory",
        "type": "definition",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Timing",
        "title": "Timing",
        "front": "Timing",
        "back": "1. Typically takes 1-3 clock cycles\n2. Depends on memory speed and cache hit/miss",
        "type": "list",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-2--Indirect-Cycle",
        "title": "Phase 2: Indirect Cycle",
        "front": "Phase 2: Indirect Cycle",
        "back": "",
        "type": "concept",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Handle indirect addressing (when instruction specifies indirect address).",
        "type": "definition",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
        "title": "Steps",
        "front": "Steps",
        "back": "1. **IR → MAR:** Address field of instruction to MAR\n2. **Assert Read:** Read indirect address from memory\n3. **Memory → MBR:** Get actual address\n4. **MBR → MAR:** Use actual address for operand fetch",
        "type": "list",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-When-Used",
        "title": "When Used",
        "front": "When Used",
        "back": "1. Indirect addressing mode\n2. Pointer dereferencing\n3. Array indexing through pointers",
        "type": "list",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. Read address from R1 → MAR\n2. Read value at that address → MBR\n3. Use MBR as operand for ADD",
        "type": "list",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-3--Execute-Cycle",
        "title": "Phase 3: Execute Cycle",
        "front": "Phase 3: Execute Cycle",
        "back": "",
        "type": "concept",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Perform the actual operation.",
        "type": "definition",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Types-of-Execute-Cycles",
        "title": "Types of Execute Cycles",
        "front": "Types of Execute Cycles",
        "back": "1. Read R2 and R3 from register file\n2. ALU performs R2 + R3\n3. Write result to R1\n4. Address 1000 → MAR\n5. Assert Read\n6. Memory → MBR\n7. MBR → R1\n8. R1 → MBR\n9. Address 1000 → MAR\n10. Assert Write\n11. Memory reads from MBR\n12. R2, R3 → ALU inputs\n13. ALU performs addition\n14. ALU output → R1\n15. Update condition codes (PSW)\n16. Check Z flag in PSW\n17. If Z=1: PC = target\n18. If Z=0: PC = PC + 1 (continue)",
        "type": "list",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-4--Interrupt-Cycle",
        "title": "Phase 4: Interrupt Cycle",
        "front": "Phase 4: Interrupt Cycle",
        "back": "",
        "type": "concept",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Handle interrupts (covered in detail in Group 1).",
        "type": "definition",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
        "title": "Steps",
        "front": "Steps",
        "back": "1. **Save Context:** PC, PSW, registers → stack or special registers\n2. **Disable Interrupts:** Set interrupt disable flag\n3. **Load Handler Address:** Interrupt vector → PC\n4. **Jump to Handler:** Begin executing interrupt service routine",
        "type": "list",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Data-Flow",
        "title": "Data Flow",
        "front": "Data Flow",
        "back": "Current PC ──► Save to stack Current PSW ──► Save to stack Registers ──► Save to stack Interrupt Vector ──► PC",
        "type": "definition",
        "section": "Instruction Cycle Details",
        "subsection": "Complete Instruction Cycle"
      },
      {
        "id": "2-Instruction-Cycle-Details-Instruction-Cycle-State-Diagram-States",
        "title": "States",
        "front": "States",
        "back": "FETCH ──► [Indirect?] ──► EXECUTE ──► [Interrupt?] ──► FETCH │ Yes │ Yes │ │ ▼ ▼ INDIRECT INTERRUPT │ │ └──────── EXECUTE ───────────────┘",
        "type": "definition",
        "section": "Instruction Cycle Details",
        "subsection": "Instruction Cycle State Diagram"
      },
      {
        "id": "2-Instruction-Cycle-Details-Instruction-Cycle-State-Diagram-Key-Points",
        "title": "Key Points",
        "front": "Key Points",
        "back": "1. Fetch always occurs first\n2. Indirect cycle is optional (only for indirect addressing)\n3. Execute always occurs (but varies greatly)\n4. Interrupt check occurs after execute\n5. Cycle repeats indefinitely",
        "type": "list",
        "section": "Instruction Cycle Details",
        "subsection": "Instruction Cycle State Diagram"
      },
      {
        "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Traditional-Approach--Non-Pipelined-",
        "title": "Traditional Approach (Non-Pipelined)",
        "front": "Traditional Approach (Non-Pipelined)",
        "back": "Instruction 1: [Fetch] [Decode] [Execute] [Write] ──► Complete Instruction 2: [Fetch] [Decode] [Execute] [Write] ──► Complete Instruction 3: [Fetch] [Decode] [Execute] [Write] ──► Complete",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "The Problem: Sequential Execution"
      },
      {
        "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Time-per-instruction",
        "title": "Time per instruction",
        "front": "Time per instruction",
        "back": "Sum of all stages",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "The Problem: Sequential Execution"
      },
      {
        "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Throughput",
        "title": "Throughput",
        "front": "Throughput",
        "back": "1 instruction per (sum of stages)",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "The Problem: Sequential Execution"
      },
      {
        "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. Fetch: 200ps\n2. Decode: 100ps\n3. Execute: 200ps\n4. Write: 100ps\n5. **Total: 600ps per instruction**",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "The Problem: Sequential Execution"
      },
      {
        "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Overlap execution of multiple instructions.",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "The Solution: Pipelining"
      },
      {
        "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Pipelined-Approach",
        "title": "Pipelined Approach",
        "front": "Pipelined Approach",
        "back": "Time: 1 2 3 4 5 6 7 8 Inst 1: [F] [D] [E] [W] Inst 2: [F] [D] [E] [W] Inst 3: [F] [D] [E] [W] Inst 4: [F] [D] [E] [W]",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "The Solution: Pipelining"
      },
      {
        "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "While Instruction 1 is in Execute stage, Instruction 2 can be in Decode stage, and Instruction 3 can be in Fetch stage.",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "The Solution: Pipelining"
      },
      {
        "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Benefits",
        "title": "Benefits",
        "front": "Benefits",
        "back": "1. **Throughput:** Multiple instructions in pipeline simultaneously\n2. **Efficiency:** Better resource utilization\n3. **Performance:** Significant speedup (ideally equal to number of stages)",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "The Solution: Pipelining"
      },
      {
        "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Non-Pipelined-Laundry",
        "title": "Non-Pipelined Laundry",
        "front": "Non-Pipelined Laundry",
        "back": "Load 1: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Load 2: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Load 3: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Total: 240 minutes for 3 loads",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "Pipelining Analogy: Laundry"
      },
      {
        "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Pipelined-Laundry",
        "title": "Pipelined Laundry",
        "front": "Pipelined Laundry",
        "back": "Time: 0-30 30-60 60-80 80-110 110-140 140-160 Load 1: [Wash] [Dry] [Fold] Load 2: [Wash] [Dry] [Fold] Load 3: [Wash] [Dry] [Fold] Total: 160 minutes for 3 loads Speedup: 240/160 = 1.5x",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "Pipelining Analogy: Laundry"
      },
      {
        "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-With-4-Loads",
        "title": "With 4 Loads",
        "front": "With 4 Loads",
        "back": "1. Non-pipelined: 320 minutes\n2. Pipelined: 200 minutes (30 + 30 + 20 + 3×30)\n3. **Speedup: 320/200 = 1.6x**",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "Pipelining Analogy: Laundry"
      },
      {
        "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Ideal-Speedup",
        "title": "Ideal Speedup",
        "front": "Ideal Speedup",
        "back": "If all stages take equal time and there's enough work, speedup = number of stages.",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "Pipelining Analogy: Laundry"
      },
      {
        "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-1--Fetch-Instruction--FI-",
        "title": "Stage 1: Fetch Instruction (FI)",
        "front": "Stage 1: Fetch Instruction (FI)",
        "back": "1. **Function:** Read the next expected instruction into a buffer\n2. **Operations:**\n3. PC → MAR\n4. Assert Read\n5. Memory → MBR → Instruction Buffer\n6. Increment PC\n7. **Time:** Depends on memory/cache access time",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "Instruction Pipeline Stages"
      },
      {
        "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-2--Decode-Instruction--DI-",
        "title": "Stage 2: Decode Instruction (DI)",
        "front": "Stage 2: Decode Instruction (DI)",
        "back": "1. **Function:** Determine the opcode and operand specifiers\n2. **Operations:**\n3. Extract opcode from instruction\n4. Identify instruction type\n5. Determine operand locations\n6. Generate control signals\n7. **Time:** Typically fast (register access)",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "Instruction Pipeline Stages"
      },
      {
        "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-3--Calculate-Operands--CO-",
        "title": "Stage 3: Calculate Operands (CO)",
        "front": "Stage 3: Calculate Operands (CO)",
        "back": "1. **Function:** Calculate the effective address of each source operand\n2. **Operations:**\n3. Handle addressing modes:\n4. Immediate: Use constant from instruction\n5. Direct: Use address from instruction\n6. Indirect: Read address, then use it\n7. Displacement: Base register + offset\n8. Register indirect: Use register value as address\n9. **Time:** Depends on addressing mode complexity",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "Instruction Pipeline Stages"
      },
      {
        "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-4--Fetch-Operands--FO-",
        "title": "Stage 4: Fetch Operands (FO)",
        "front": "Stage 4: Fetch Operands (FO)",
        "back": "1. **Function:** Fetch each operand from memory (if needed)\n2. **Operations:**\n3. Read operands from memory\n4. Read operands from registers\n5. Note: Register operands don't require memory access\n6. **Time:** Depends on operand location (register = fast, memory = slow)",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "Instruction Pipeline Stages"
      },
      {
        "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-5--Execute-Instruction--EI-",
        "title": "Stage 5: Execute Instruction (EI)",
        "front": "Stage 5: Execute Instruction (EI)",
        "back": "1. **Function:** Perform the indicated operation\n2. **Operations:**\n3. Arithmetic operations in ALU\n4. Logical operations in ALU\n5. Address calculations\n6. Comparisons\n7. **Time:** Depends on operation complexity",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "Instruction Pipeline Stages"
      },
      {
        "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-6--Write-Operand--WO-",
        "title": "Stage 6: Write Operand (WO)",
        "front": "Stage 6: Write Operand (WO)",
        "back": "1. **Function:** Store the result in memory or register\n2. **Operations:**\n3. Write result to destination register\n4. Write result to memory (if needed)\n5. Update condition codes\n6. **Time:** Depends on destination (register = fast, memory = slow)",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "Instruction Pipeline Stages"
      },
      {
        "id": "2-Pipelining-Fundamentals-Pipeline-Performance-Characteristics-Key-Metrics",
        "title": "Key Metrics",
        "front": "Key Metrics",
        "back": "1. **Throughput:** Instructions completed per unit time\n2. **Non-pipelined:** 1 instruction per (sum of all stages)\n3. **Pipelined:** 1 instruction per (longest stage time)\n4. **Latency:** Time from start to completion of single instruction\n5. **Non-pipelined:** Sum of all stages\n6. **Pipelined:** Still sum of all stages (not reduced!)\n7. **Speedup:** Ratio of non-pipelined time to pipelined time\n8. **Ideal:** Number of stages (if stages are balanced)\n9. **Actual:** Less than ideal due to hazards and stalls",
        "type": "list",
        "section": "Pipelining Fundamentals",
        "subsection": "Pipeline Performance Characteristics"
      },
      {
        "id": "2-Pipelining-Fundamentals-Pipeline-Performance-Characteristics-Critical-Insight",
        "title": "Critical Insight",
        "front": "Critical Insight",
        "back": "Pipelining improves **throughput** (how many instructions per second), but **not latency** (how long each instruction takes).",
        "type": "definition",
        "section": "Pipelining Fundamentals",
        "subsection": "Pipeline Performance Characteristics"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Architecture",
        "title": "Architecture",
        "front": "Architecture",
        "back": "5-stage pipeline, one step per stage.",
        "type": "definition",
        "section": "MIPS Pipeline Case Study",
        "subsection": "MIPS Pipeline Overview"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stages",
        "title": "Stages",
        "front": "Stages",
        "back": "",
        "type": "definition",
        "section": "MIPS Pipeline Case Study",
        "subsection": "MIPS Pipeline Overview"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-1--IF--Instruction-Fetch-",
        "title": "Stage 1: IF (Instruction Fetch)",
        "front": "Stage 1: IF (Instruction Fetch)",
        "back": "1. Fetch instruction from memory\n2. Update PC\n3. **Time:** 200ps (memory access)",
        "type": "list",
        "section": "MIPS Pipeline Case Study",
        "subsection": "MIPS Pipeline Overview"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-2--ID--Instruction-Decode---Register-Read-",
        "title": "Stage 2: ID (Instruction Decode & Register Read)",
        "front": "Stage 2: ID (Instruction Decode & Register Read)",
        "back": "1. Decode instruction\n2. Read register operands\n3. **Time:** 100ps (register access)",
        "type": "list",
        "section": "MIPS Pipeline Case Study",
        "subsection": "MIPS Pipeline Overview"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-3--EX--Execute-",
        "title": "Stage 3: EX (Execute)",
        "front": "Stage 3: EX (Execute)",
        "back": "1. Perform ALU operation\n2. Calculate address (for load/store)\n3. **Time:** 200ps (ALU operation)",
        "type": "list",
        "section": "MIPS Pipeline Case Study",
        "subsection": "MIPS Pipeline Overview"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-4--MEM--Memory-Access-",
        "title": "Stage 4: MEM (Memory Access)",
        "front": "Stage 4: MEM (Memory Access)",
        "back": "1. Access memory operand (for load/store only)\n2. **Time:** 200ps (memory access)\n3. **Note:** R-format and branch instructions skip this stage",
        "type": "list",
        "section": "MIPS Pipeline Case Study",
        "subsection": "MIPS Pipeline Overview"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-5--WB--Write-Back-",
        "title": "Stage 5: WB (Write Back)",
        "front": "Stage 5: WB (Write Back)",
        "back": "1. Write result back to register\n2. **Time:** 100ps (register write)",
        "type": "list",
        "section": "MIPS Pipeline Case Study",
        "subsection": "MIPS Pipeline Overview"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Load-Word--lw-",
        "title": "Load Word (lw)",
        "front": "Load Word (lw)",
        "back": "lw $t0, 4($s1) # $t0 = memory[$s1 + 4] IF: Fetch instruction (200ps) ID: Decode, read $s1 (100ps) EX: Calculate address $s1 + 4 (200ps) MEM: Read memory[$s1 + 4] (200ps) WB: Write to $t0 (100ps) Total: 800ps",
        "type": "concept",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Instruction Types and Pipeline Usage"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Store-Word--sw-",
        "title": "Store Word (sw)",
        "front": "Store Word (sw)",
        "back": "sw $t0, 4($s1) # memory[$s1 + 4] = $t0 IF: Fetch instruction (200ps) ID: Decode, read $s1 and $t0 (100ps) EX: Calculate address $s1 + 4 (200ps) MEM: Write memory[$s1 + 4] (200ps) WB: (no write back for store) Total: 700ps (no WB stage needed)",
        "type": "concept",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Instruction Types and Pipeline Usage"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-R-Format--Register-Operations-",
        "title": "R-Format (Register Operations)",
        "front": "R-Format (Register Operations)",
        "back": "add $s0, $t0, $t1 # $s0 = $t0 + $t1 IF: Fetch instruction (200ps) ID: Decode, read $t0 and $t1 (100ps) EX: ALU operation $t0 + $t1 (200ps) MEM: (no memory access) WB: Write to $s0 (100ps) Total: 600ps",
        "type": "concept",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Instruction Types and Pipeline Usage"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Branch--beq-",
        "title": "Branch (beq)",
        "front": "Branch (beq)",
        "back": "beq $t0, $t1, label # if $t0 == $t1, branch to label IF: Fetch instruction (200ps) ID: Decode, read $t0 and $t1 (100ps) EX: Compare $t0 and $t1, calculate target address (200ps) MEM: (no memory access) WB: (no write back) Total: 500ps",
        "type": "concept",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Instruction Types and Pipeline Usage"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Critical-Constraint",
        "title": "Critical Constraint",
        "front": "Critical Constraint",
        "back": "Pipeline clock cycle is limited by the **slowest stage**.",
        "type": "definition",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Clock Cycle"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. IF: 200ps\n2. ID: 100ps\n3. EX: 200ps\n4. MEM: 200ps\n5. WB: 100ps\n6. **Clock cycle = 200ps** (slowest stage)",
        "type": "list",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Clock Cycle"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Implication",
        "title": "Implication",
        "front": "Implication",
        "back": "All stages must complete within one clock cycle, even if they don't need the full time.",
        "type": "definition",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Clock Cycle"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Wasted-Time",
        "title": "Wasted Time",
        "front": "Wasted Time",
        "back": "1. ID stage completes in 100ps but must wait 200ps\n2. WB stage completes in 100ps but must wait 200ps\n3. **Trade-off:** Simpler design vs. efficiency",
        "type": "list",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Clock Cycle"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Non-Pipelined",
        "title": "Non-Pipelined",
        "front": "Non-Pipelined",
        "back": "1. Longest instruction: 800ps (lw)\n2. Throughput: 1 instruction per 800ps = 1.25 × 10^9 instructions/second",
        "type": "list",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Throughput"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Pipelined",
        "title": "Pipelined",
        "front": "Pipelined",
        "back": "1. Clock cycle: 200ps (slowest stage)\n2. Throughput: 1 instruction per 200ps = 5 × 10^9 instructions/second\n3. **Speedup: 4x** (close to ideal 5x for 5 stages)",
        "type": "list",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Throughput"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Key-Point",
        "title": "Key Point",
        "front": "Key Point",
        "back": "Even though some instructions take 800ps to complete, the pipeline can start a new instruction every 200ps.",
        "type": "definition",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Throughput"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Non-Pipelined-Execution",
        "title": "Non-Pipelined Execution",
        "front": "Non-Pipelined Execution",
        "back": "Time: 0-800 800-1500 1500-2100 2100-2600 Inst 1: [lw] Inst 2: [sw] Inst 3: [add] Inst 4: [beq]",
        "type": "definition",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Timing Diagram"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Pipelined-Execution",
        "title": "Pipelined Execution",
        "front": "Pipelined Execution",
        "back": "Time: 0-200 200-400 400-600 600-800 800-1000 1000-1200 Inst 1: [IF] [ID] [EX] [MEM] [WB] Inst 2: [IF] [ID] [EX] [MEM] [WB] Inst 3: [IF] [ID] [EX] [MEM] [WB] Inst 4: [IF] [ID] [EX] [MEM] [WB]",
        "type": "definition",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Timing Diagram"
      },
      {
        "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Observation",
        "title": "Observation",
        "front": "Observation",
        "back": "At time 800ps, Instruction 1 completes, but Instructions 2, 3, and 4 are already in progress.",
        "type": "definition",
        "section": "MIPS Pipeline Case Study",
        "subsection": "Pipeline Timing Diagram"
      },
      {
        "id": "2-Pipeline-Hazards-What-are-Hazards--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Situations that prevent starting the next instruction in the next cycle.",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "What are Hazards?"
      },
      {
        "id": "2-Pipeline-Hazards-What-are-Hazards--Impact",
        "title": "Impact",
        "front": "Impact",
        "back": "Cause pipeline stalls (bubbles), reducing performance.",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "What are Hazards?"
      },
      {
        "id": "2-Pipeline-Hazards-What-are-Hazards--Types",
        "title": "Types",
        "front": "Types",
        "back": "1. **Structure Hazards:** Resource conflicts\n2. **Data Hazards:** Data dependencies\n3. **Control Hazards:** Branch dependencies",
        "type": "list",
        "section": "Pipeline Hazards",
        "subsection": "What are Hazards?"
      },
      {
        "id": "2-Pipeline-Hazards-Structure-Hazards-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "A required resource is busy when needed.",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Structure Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Structure-Hazards-Common-Cause",
        "title": "Common Cause",
        "front": "Common Cause",
        "back": "Multiple instructions need the same hardware resource simultaneously.",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Structure Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Structure-Hazards-Example--Single-Memory-for-Instructions-and-Data",
        "title": "Example: Single Memory for Instructions and Data",
        "front": "Example: Single Memory for Instructions and Data",
        "back": "",
        "type": "concept",
        "section": "Pipeline Hazards",
        "subsection": "Structure Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Structure-Hazards-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "Cycle 1: Instruction 1 in MEM stage (accessing data memory) Cycle 1: Instruction 2 in IF stage (needs to fetch instruction) └─► CONFLICT! Both need memory access",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Structure Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Structure-Hazards-Solution-Options",
        "title": "Solution Options",
        "front": "Solution Options",
        "back": "1. **Stall Pipeline:**\n2. Insert \"bubble\" (NOP - No Operation)\n3. Performance penalty\n4. **Separate Instruction and Data Memory:**\n5. Harvard Architecture\n6. No conflict possible\n7. More expensive\n8. **Cache with Separate I-Cache and D-Cache:**\n9. Instruction cache for IF stage\n10. Data cache for MEM stage\n11. Modern solution",
        "type": "list",
        "section": "Pipeline Hazards",
        "subsection": "Structure Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Structure-Hazards-Other-Structure-Hazards",
        "title": "Other Structure Hazards",
        "front": "Other Structure Hazards",
        "back": "1. Multiple instructions needing ALU simultaneously\n2. Register file port conflicts (need multiple read/write ports)",
        "type": "list",
        "section": "Pipeline Hazards",
        "subsection": "Structure Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Data-Hazards-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Attempt to use data before it's ready.",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Data Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Data-Hazards-Cause",
        "title": "Cause",
        "front": "Cause",
        "back": "Instruction depends on result of previous instruction that hasn't completed yet.",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Data Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Data-Hazards-Example-",
        "title": "Example:",
        "front": "Example:",
        "back": "add $s0, $t0, $t1 # I1: $s0 = $t0 + $t1 sub $t2, $s0, $t3 # I2: $t2 = $s0 - $t3 (depends on I1)",
        "type": "concept",
        "section": "Pipeline Hazards",
        "subsection": "Data Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Data-Hazards-Pipeline-Timeline",
        "title": "Pipeline Timeline",
        "front": "Pipeline Timeline",
        "back": "Time: 1 2 3 4 5 6 I1: [IF] [ID] [EX] [MEM] [WB] I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here, but I1 writes in cycle 5!",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Data Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Data-Hazards-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "I2 needs $s0 in cycle 3 (ID stage), but I1 doesn't write $s0 until cycle 5 (WB stage).",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Data Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Data-Hazards-Solutions",
        "title": "Solutions",
        "front": "Solutions",
        "back": "1. **Stall Pipeline:** Insert bubbles until data is ready\n2. **Forwarding (Bypassing):** Use result directly from EX/MEM stage\n3. **Instruction Reordering:** Compiler reorders instructions to avoid hazard",
        "type": "list",
        "section": "Pipeline Hazards",
        "subsection": "Data Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Control-Hazards-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Deciding on control action depends on previous instruction.",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Control Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Control-Hazards-Cause",
        "title": "Cause",
        "front": "Cause",
        "back": "Branch instructions determine which instruction to fetch next, but decision isn't known until later in pipeline.",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Control Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Control-Hazards-Example-",
        "title": "Example:",
        "front": "Example:",
        "back": "beq $t0, $t1, label # Branch if $t0 == $t1 add $s0, $s1, $s2 # Next instruction (may or may not execute)",
        "type": "concept",
        "section": "Pipeline Hazards",
        "subsection": "Control Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Control-Hazards-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "Time: 1 2 3 4 5 beq: [IF] [ID] [EX] [MEM] [WB] add: [IF] [ID] [EX] [MEM] [WB] └─► Branch decision made here But we already fetched 'add'!",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Control Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Control-Hazards-Issue",
        "title": "Issue",
        "front": "Issue",
        "back": "We don't know if branch will be taken until EX stage, but we already fetched the next instruction.",
        "type": "definition",
        "section": "Pipeline Hazards",
        "subsection": "Control Hazards"
      },
      {
        "id": "2-Pipeline-Hazards-Control-Hazards-Solutions",
        "title": "Solutions",
        "front": "Solutions",
        "back": "1. **Stall on Branch:** Wait until branch decision is known\n2. **Branch Prediction:** Predict whether branch will be taken\n3. **Delayed Branch:** Always execute instruction after branch\n4. **Multiple Streams:** Fetch from both possible paths\n5. **Prefetch Branch Target:** Prefetch target instruction",
        "type": "list",
        "section": "Pipeline Hazards",
        "subsection": "Control Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-1--RAW--Read-After-Write----True-Dependency",
        "title": "1. RAW (Read After Write) - True Dependency",
        "front": "1. RAW (Read After Write) - True Dependency",
        "back": "",
        "type": "concept",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Instruction 2 tries to read an operand before Instruction 1 writes to it.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
        "title": "Example",
        "front": "Example",
        "back": "I1: add $s0, $t0, $t1 # I1 writes to $s0 I2: sub $t2, $s0, $t3 # I2 reads from $s0",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
        "title": "Timeline",
        "front": "Timeline",
        "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 written here I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here (too early!)",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
        "title": "Frequency",
        "front": "Frequency",
        "back": "Extremely common - most data dependencies are RAW.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Forwarding (bypassing) - use result from EX/MEM stage directly.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-2--WAR--Write-After-Read----Anti-Dependency",
        "title": "2. WAR (Write After Read) - Anti-Dependency",
        "front": "2. WAR (Write After Read) - Anti-Dependency",
        "back": "",
        "type": "concept",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Instruction 2 tries to write to a destination before Instruction 1 reads from it.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
        "title": "Example",
        "front": "Example",
        "back": "I1: add $t4, $t1, $t5 # I1 reads from $t5 I2: add $t5, $t1, $t2 # I2 writes to $t5",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
        "title": "Timeline",
        "front": "Timeline",
        "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t5 here I2: [IF] [ID] [EX] [MEM] [WB] └─► Writes $t5 here",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
        "title": "Frequency",
        "front": "Frequency",
        "back": "Uncommon/impossible in simple in-order pipelines.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Why",
        "title": "Why",
        "front": "Why",
        "back": "In simple pipelines, instructions execute in order, so I1 always reads before I2 writes.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Occurs-In",
        "title": "Occurs In",
        "front": "Occurs In",
        "back": "Out-of-order execution, superscalar processors.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-3--WAW--Write-After-Write----Output-Dependency",
        "title": "3. WAW (Write After Write) - Output Dependency",
        "front": "3. WAW (Write After Write) - Output Dependency",
        "back": "",
        "type": "concept",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Instruction 2 tries to write to an operand before Instruction 1 writes to it.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
        "title": "Example",
        "front": "Example",
        "back": "I1: add $s0, $t0, $t1 # I1 writes to $s0 I2: add $s0, $t2, $t3 # I2 writes to $s0",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
        "title": "Timeline",
        "front": "Timeline",
        "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Writes $s0 here I2: [IF] [ID] [EX] [MEM] [WB] └─► Writes $s0 here (must wait)",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
        "title": "Frequency",
        "front": "Frequency",
        "back": "Possible in simple pipelines, but not in the very simple pipeline we're assuming.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Delay I2's write until I1 completes.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-4--RAR--Read-After-Read----Not-a-Hazard",
        "title": "4. RAR (Read After Read) - Not a Hazard",
        "front": "4. RAR (Read After Read) - Not a Hazard",
        "back": "",
        "type": "concept",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Both instructions read from the same register.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
        "title": "Example",
        "front": "Example",
        "back": "I1: add $t1, $t2, $t3 # I1 reads from $t2 I2: add $t5, $t4, $t2 # I2 reads from $t2",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Why-Not-a-Hazard",
        "title": "Why Not a Hazard",
        "front": "Why Not a Hazard",
        "back": "Reading doesn't change the register value. Order doesn't matter.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
        "title": "Timeline",
        "front": "Timeline",
        "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t2 I2: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t2 (no problem!)",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Types of Data Hazards"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Use result directly from pipeline stage where it's computed, without waiting for it to be written to register.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Forwarding (Bypassing)"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Problem-Without-Forwarding",
        "title": "Problem Without Forwarding",
        "front": "Problem Without Forwarding",
        "back": "Time: 1 2 3 4 5 6 7 8 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available here I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0, must wait (stall) [stall] [stall] [EX] [MEM] [WB]",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Forwarding (Bypassing)"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Solution-With-Forwarding",
        "title": "Solution With Forwarding",
        "front": "Solution With Forwarding",
        "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 computed here I2: [IF] [ID] [EX] [MEM] [WB] └─► Forward $s0 directly from I1's EX stage",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Forwarding (Bypassing)"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Implementation",
        "title": "Implementation",
        "front": "Implementation",
        "back": "1. **Extra Connections:** Datapath connections from EX/MEM stage to EX stage inputs\n2. **Forwarding Unit:** Detects data hazards and selects forwarded data\n3. **Multiplexers:** Route forwarded data to ALU inputs",
        "type": "list",
        "section": "Data Hazards and Forwarding",
        "subsection": "Forwarding (Bypassing)"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Forwarding-Paths",
        "title": "Forwarding Paths",
        "front": "Forwarding Paths",
        "back": "1. **EX/MEM → EX:** Forward result from previous instruction's EX stage\n2. **MEM/WB → EX:** Forward result from two instructions ago\n3. **EX/MEM → MEM:** Forward result for store instructions",
        "type": "list",
        "section": "Data Hazards and Forwarding",
        "subsection": "Forwarding (Bypassing)"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Example",
        "title": "Example",
        "front": "Example",
        "back": "add $s0, $t0, $t1 # I1 sub $t2, $s0, $t3 # I2: needs $s0",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Forwarding (Bypassing)"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--With-Forwarding",
        "title": "With Forwarding",
        "front": "With Forwarding",
        "back": "1. I1 computes $s0 in EX stage (cycle 3)\n2. I2 needs $s0 in EX stage (cycle 4)\n3. Forwarding unit detects hazard\n4. Routes I1's EX output directly to I2's EX input\n5. **No stall needed!**",
        "type": "list",
        "section": "Data Hazards and Forwarding",
        "subsection": "Forwarding (Bypassing)"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Limitations",
        "title": "Limitations",
        "front": "Limitations",
        "back": "1. Forwarding can't help if data isn't computed yet\n2. Load instructions: Data only available after MEM stage\n3. May still need 1-cycle stall for load-use hazards",
        "type": "list",
        "section": "Data Hazards and Forwarding",
        "subsection": "Forwarding (Bypassing)"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Special-Case",
        "title": "Special Case",
        "front": "Special Case",
        "back": "Load instruction followed by instruction using loaded value.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Load-Use Hazard"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Example",
        "title": "Example",
        "front": "Example",
        "back": "lw $s0, 0($t0) # I1: Load from memory add $t2, $s0, $t1 # I2: Use loaded value",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Load-Use Hazard"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Timeline",
        "title": "Timeline",
        "front": "Timeline",
        "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available here (after memory read) I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here (too early!)",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Load-Use Hazard"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "$s0 only available after MEM stage, but I2 needs it in EX stage.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Load-Use Hazard"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "**1-cycle stall** + forwarding Time: 1 2 3 4 5 6 7 8 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available I2: [IF] [ID] [stall] [EX] [MEM] [WB] └─► Forward $s0 from I1's MEM stage",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Load-Use Hazard"
      },
      {
        "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Key-Point",
        "title": "Key Point",
        "front": "Key Point",
        "back": "Even with forwarding, load-use hazards require at least 1 stall cycle.",
        "type": "definition",
        "section": "Data Hazards and Forwarding",
        "subsection": "Load-Use Hazard"
      },
      {
        "id": "2-Control-Hazards-The-Branch-Problem-Issue",
        "title": "Issue",
        "front": "Issue",
        "back": "Branch instruction determines which instruction to fetch next, but decision isn't known until later in pipeline.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "The Branch Problem"
      },
      {
        "id": "2-Control-Hazards-The-Branch-Problem-Example",
        "title": "Example",
        "front": "Example",
        "back": "beq $t0, $t1, label # Branch if $t0 == $t1 add $s0, $s1, $s2 # Next instruction (may be wrong!) sub $t2, $t3, $t4 # Instruction at label (may be correct)",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "The Branch Problem"
      },
      {
        "id": "2-Control-Hazards-The-Branch-Problem-Pipeline-Timeline",
        "title": "Pipeline Timeline",
        "front": "Pipeline Timeline",
        "back": "Time: 1 2 3 4 5 beq: [IF] [ID] [EX] [MEM] [WB] └─► Branch decision made here add: [IF] [ID] [EX] [MEM] [WB] └─► Already fetched, but may be wrong!",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "The Branch Problem"
      },
      {
        "id": "2-Control-Hazards-The-Branch-Problem-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "1. Branch decision (taken/not taken) known in EX stage\n2. But we already fetched next instruction in IF stage\n3. If branch is taken, we fetched wrong instruction\n4. Must flush pipeline and fetch correct instruction",
        "type": "list",
        "section": "Control Hazards",
        "subsection": "The Branch Problem"
      },
      {
        "id": "2-Control-Hazards-Branch-Penalty-Cost",
        "title": "Cost",
        "front": "Cost",
        "back": "2-3 cycles wasted when branch is taken.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Branch Penalty"
      },
      {
        "id": "2-Control-Hazards-Branch-Penalty-Why",
        "title": "Why",
        "front": "Why",
        "back": "1. Branch decision in EX stage (cycle 3)\n2. Wrong instruction already in pipeline (cycles 2-3)\n3. Must flush and fetch correct instruction\n4. **Total penalty: 2 cycles minimum**",
        "type": "list",
        "section": "Control Hazards",
        "subsection": "Branch Penalty"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-1--Stall-on-Branch",
        "title": "1. Stall on Branch",
        "front": "1. Stall on Branch",
        "back": "",
        "type": "concept",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
        "title": "Approach",
        "front": "Approach",
        "back": "Don't fetch next instruction until branch decision is known.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
        "title": "Implementation",
        "front": "Implementation",
        "back": "beq: [IF] [ID] [EX] [MEM] [WB] next: [IF] [stall] [stall] [IF] [ID] [EX] [MEM] [WB] └─► Wait for branch decision",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
        "title": "Performance",
        "front": "Performance",
        "back": "2-cycle penalty for every branch (taken or not).",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Advantage",
        "title": "Advantage",
        "front": "Advantage",
        "back": "Simple, always correct.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
        "title": "Disadvantage",
        "front": "Disadvantage",
        "back": "High performance penalty.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-2--Branch-Prediction",
        "title": "2. Branch Prediction",
        "front": "2. Branch Prediction",
        "back": "",
        "type": "concept",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
        "title": "Approach",
        "front": "Approach",
        "back": "Predict whether branch will be taken, fetch predicted instruction.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Predictions",
        "title": "Predictions",
        "front": "Predictions",
        "back": "1. **Always Not Taken:** Assume branch never taken\n2. If correct: No penalty\n3. If wrong: 2-cycle penalty\n4. **Always Taken:** Assume branch always taken\n5. Fetch target immediately\n6. If correct: No penalty\n7. If wrong: 2-cycle penalty\n8. **Dynamic Prediction:** Use history to predict\n9. Branch prediction buffer/cache\n10. Tracks previous branch behavior\n11. More accurate predictions",
        "type": "list",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
        "title": "Performance",
        "front": "Performance",
        "back": "1. Correct prediction: No penalty\n2. Wrong prediction: 2-cycle penalty\n3. **Accuracy matters!**",
        "type": "list",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-3--Delayed-Branch",
        "title": "3. Delayed Branch",
        "front": "3. Delayed Branch",
        "back": "",
        "type": "concept",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
        "title": "Approach",
        "front": "Approach",
        "back": "Always execute instruction immediately after branch.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Example",
        "title": "Example",
        "front": "Example",
        "back": "beq $t0, $t1, label add $s0, $s1, $s2 # Always executes (delay slot) # If branch taken, jump to label # If branch not taken, continue normally",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Compiler-s-Job",
        "title": "Compiler's Job",
        "front": "Compiler's Job",
        "back": "Fill delay slot with useful instruction (or NOP if none available).",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
        "title": "Performance",
        "front": "Performance",
        "back": "No penalty if delay slot filled usefully.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
        "title": "Disadvantage",
        "front": "Disadvantage",
        "back": "Complicates compiler and instruction set.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-4--Multiple-Streams",
        "title": "4. Multiple Streams",
        "front": "4. Multiple Streams",
        "back": "",
        "type": "concept",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
        "title": "Approach",
        "front": "Approach",
        "back": "Fetch from both possible paths (taken and not taken).",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
        "title": "Implementation",
        "front": "Implementation",
        "back": "1. Fetch next sequential instruction\n2. Also fetch branch target instruction\n3. Execute both until branch decision known\n4. Discard wrong path",
        "type": "list",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
        "title": "Disadvantage",
        "front": "Disadvantage",
        "back": "Wastes resources, complex.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-5--Prefetch-Branch-Target",
        "title": "5. Prefetch Branch Target",
        "front": "5. Prefetch Branch Target",
        "back": "",
        "type": "concept",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
        "title": "Approach",
        "front": "Approach",
        "back": "Prefetch instruction at branch target while branch executes.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
        "title": "Implementation",
        "front": "Implementation",
        "back": "1. When branch detected, start fetching target\n2. If branch taken, target already fetched\n3. If branch not taken, discard prefetched instruction",
        "type": "list",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
        "title": "Performance",
        "front": "Performance",
        "back": "Reduces penalty if branch taken.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-6--Loop-Buffer",
        "title": "6. Loop Buffer",
        "front": "6. Loop Buffer",
        "back": "",
        "type": "concept",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
        "title": "Approach",
        "front": "Approach",
        "back": "Small buffer holding recently fetched instructions.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Use-Case",
        "title": "Use Case",
        "front": "Use Case",
        "back": "Small loops that fit in buffer.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Benefit",
        "title": "Benefit",
        "front": "Benefit",
        "back": "If loop branches back, instructions already in buffer (no fetch needed).",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Solutions to Control Hazards"
      },
      {
        "id": "2-Control-Hazards-Modern-Branch-Prediction-Techniques",
        "title": "Techniques",
        "front": "Techniques",
        "back": "1. **1-bit Predictor:** Remember last outcome\n2. **2-bit Predictor:** State machine (strong/weak taken/not taken)\n3. **Branch Target Buffer (BTB):** Cache branch targets\n4. **Return Address Stack:** Predict return addresses\n5. **Correlation-based:** Use history of other branches",
        "type": "list",
        "section": "Control Hazards",
        "subsection": "Modern Branch Prediction"
      },
      {
        "id": "2-Control-Hazards-Modern-Branch-Prediction-Performance",
        "title": "Performance",
        "front": "Performance",
        "back": "Modern processors achieve >95% branch prediction accuracy.",
        "type": "definition",
        "section": "Control Hazards",
        "subsection": "Modern Branch Prediction"
      },
      {
        "id": "2-Key-Concepts-Summary-Processor-Organization-Principles-Processor-Organization-Principles",
        "title": "Processor Organization Principles",
        "front": "Processor Organization Principles",
        "back": "1. **Five Fundamental Operations:**\n2. Fetch, Interpret, Fetch Data, Process Data, Write Data\n3. All instructions follow this pattern (with variations)\n4. **Register Hierarchy:**\n5. Fastest memory level\n6. Minimize main memory accesses\n7. Two categories: User-visible and Control/Status\n8. **Instruction Cycle:**\n9. Fetch → (Indirect) → Execute → (Interrupt)\n10. Each phase has specific data flow patterns",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Processor Organization Principles"
      },
      {
        "id": "2-Key-Concepts-Summary-Pipelining-Fundamentals-Pipelining-Fundamentals",
        "title": "Pipelining Fundamentals",
        "front": "Pipelining Fundamentals",
        "back": "1. **Goal:** Improve throughput, not latency\n2. **Method:** Overlap execution of multiple instructions\n3. **Ideal Speedup:** Equal to number of stages (if balanced)\n4. **Clock Cycle:** Limited by slowest stage",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Pipelining Fundamentals"
      },
      {
        "id": "2-Key-Concepts-Summary-Pipeline-Hazards-Pipeline-Hazards",
        "title": "Pipeline Hazards",
        "front": "Pipeline Hazards",
        "back": "1. **Structure Hazards:**\n2. Resource conflicts\n3. Solved by: Separate resources, stalling\n4. **Data Hazards:**\n5. Data dependencies\n6. Solved by: Forwarding, stalling, instruction reordering\n7. Types: RAW (common), WAR (rare), WAW (possible), RAR (not a hazard)\n8. **Control Hazards:**\n9. Branch dependencies\n10. Solved by: Prediction, stalling, delayed branch\n11. Penalty: 2-3 cycles typically",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Pipeline Hazards"
      },
      {
        "id": "2-Key-Concepts-Summary-Performance-Optimization-Performance-Optimization",
        "title": "Performance Optimization",
        "front": "Performance Optimization",
        "back": "1. **Forwarding:** Eliminates most data hazard stalls\n2. **Branch Prediction:** Reduces control hazard penalty\n3. **Balanced Pipeline:** Minimize wasted time in stages\n4. **Hazard Detection:** Identify and handle hazards efficiently",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Performance Optimization"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-1--Register-Organization-Question",
        "title": "Question",
        "front": "Question",
        "back": "What is the difference between user-visible registers and control/status registers?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Register Organization"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-1--Register-Organization-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **User-Visible Registers:** Can be directly accessed by programs (assembly/machine code). Used for data operations, addresses, condition codes. Examples: General-purpose registers, stack pointer.\n2. **Control/Status Registers:** Used internally by processor and OS. Not directly accessible to user programs. Control instruction execution. Examples: PC, IR, MAR, MBR, PSW.",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Register Organization"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Question",
        "title": "Question",
        "front": "Question",
        "back": "A 5-stage pipeline has stage times: 200ps, 150ps, 200ps, 180ps, 150ps. What is the clock cycle time and ideal speedup?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Pipeline Speedup"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Clock cycle = slowest stage = 200ps\n2. Non-pipelined time = 200 + 150 + 200 + 180 + 150 = 880ps\n3. Pipelined throughput = 1 instruction per 200ps\n4. Ideal speedup = 880/200 = 4.4x\n5. Maximum possible speedup = 5x (number of stages)",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Pipeline Speedup"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "Clock cycle = 200ps, Ideal speedup ≈ 4.4x",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Pipeline Speedup"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-3--Data-Hazard-Detection-Question",
        "title": "Question",
        "front": "Question",
        "back": "Identify the data hazard in this code: add $s0, $t0, $t1 sub $t2, $s0, $t3 mul $s1, $s0, $t4",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: Data Hazard Detection"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-3--Data-Hazard-Detection-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **RAW Hazard 1:** `sub` reads $s0 before `add` writes it\n2. **RAW Hazard 2:** `mul` reads $s0 before `add` writes it\n3. **Solution:** Forwarding can handle both (if $s0 available in time)",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: Data Hazard Detection"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Question",
        "title": "Question",
        "front": "Question",
        "back": "In a 5-stage pipeline, a branch instruction makes its decision in the EX stage. What is the minimum branch penalty?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Control Hazard Penalty"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Branch decision in EX stage (cycle 3)\n2. Wrong instruction already fetched in IF stage (cycle 2)\n3. Must flush wrong instruction and fetch correct one\n4. **Minimum penalty: 2 cycles** (cycles 2-3 wasted)",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Control Hazard Penalty"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "2 cycles minimum",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Control Hazard Penalty"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-5--Forwarding-Analysis-Question",
        "title": "Question",
        "front": "Question",
        "back": "Can forwarding eliminate the stall in this sequence? lw $s0, 0($t0) add $t2, $s0, $t1",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Forwarding Analysis"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-5--Forwarding-Analysis-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **No, cannot completely eliminate stall**\n2. $s0 only available after MEM stage of `lw`\n3. `add` needs $s0 in EX stage\n4. **1-cycle stall required** (load-use hazard)\n5. Forwarding can be used after the stall to avoid additional delays",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Forwarding Analysis"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Question",
        "title": "Question",
        "front": "Question",
        "back": "A pipeline has 5 stages, each taking 100ps. If 20% of instructions cause 1-cycle stalls, what is the average CPI (Cycles Per Instruction)?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 6: Pipeline Efficiency"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Ideal CPI = 1 (one instruction per cycle in steady state)\n2. 20% of instructions cause 1 extra cycle\n3. Average CPI = 1 + 0.2 × 1 = 1.2",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 6: Pipeline Efficiency"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "Average CPI = 1.2",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 6: Pipeline Efficiency"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Question",
        "title": "Question",
        "front": "Question",
        "back": "A program has 20% branch instructions. With 80% prediction accuracy, what is the average branch penalty?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 7: Branch Prediction Impact"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. 20% of instructions are branches\n2. 80% predicted correctly → 0 penalty\n3. 20% predicted incorrectly → 2-cycle penalty\n4. Average penalty per branch = 0.8 × 0 + 0.2 × 2 = 0.4 cycles\n5. Average penalty per instruction = 0.2 × 0.4 = 0.08 cycles",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 7: Branch Prediction Impact"
      },
      {
        "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **Understand Data Flow:**\n2. Trace how data moves through pipeline stages\n3. Understand register usage and memory access patterns\n4. Visualize instruction execution step-by-step\n5. **Master Hazard Types:**\n6. Structure: Resource conflicts\n7. Data: Dependencies (RAW most important)\n8. Control: Branches\n9. **Practice Pipeline Diagrams:**\n10. Draw pipeline timing diagrams\n11. Identify hazards visually\n12. Show forwarding paths\n13. **Calculate Performance:**\n14. Throughput vs. latency\n15. Speedup calculations\n16. CPI and performance impact\n17. **Compare Solutions:**\n18. Forwarding vs. stalling\n19. Branch prediction strategies\n20. Pipeline design trade-offs\n21. **Relate to Real Processors:**\n22. MIPS pipeline as concrete example\n23. Modern processors use similar concepts\n24. Understand why certain designs are used\n25. **Processors are complex:** Multiple components working together\n26. **Registers are critical:** Fastest memory, essential for performance\n27. **Pipelining improves throughput:** Overlap execution for speed\n28. **Hazards limit performance:** Must be detected and handled\n29. **Forwarding is powerful:** Eliminates most data hazard stalls\n30. **Branches are expensive:** Control hazards require sophisticated solutions\n31. Instruction sets (Group 3) - what instructions look like\n32. Memory systems (Group 4) - how data is stored and retrieved\n33. I/O systems (Group 6) - how external communication works",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 7: Branch Prediction Impact"
      }
    ]
  },
  "3": {
    "group": 3,
    "totalCards": 162,
    "sections": [
      {
        "section": "Detailed Study Guide",
        "subsections": [
          {
            "subsection": "General",
            "cardCount": 1,
            "cards": [
              {
                "id": "3-Detailed-Study-Guide--Detailed-Study-Guide",
                "title": "Detailed Study Guide",
                "front": "Detailed Study Guide",
                "back": "1. [Introduction: What is an Instruction Set?](#introduction-what-is-an-instruction-set)\n2. [Elements of a Machine Instruction](#elements-of-a-machine-instruction)\n3. [Number of Addresses in Instructions](#number-of-addresses-in-instructions)\n4. [Types of Operands](#types-of-operands)\n5. [Types of Operations](#types-of-operations)\n6. [Instruction Set Design Considerations](#instruction-set-design-considerations)\n7. [Design Trade-offs](#design-trade-offs)\n8. [Key Concepts Summary](#key-concepts-summary)\n9. [Practice Problems and Examples](#practice-problems-and-examples)",
                "type": "list",
                "section": "Detailed Study Guide",
                "subsection": ""
              }
            ]
          }
        ]
      },
      {
        "section": "Introduction: What is an Instruction Set?",
        "subsections": [
          {
            "subsection": "Definition",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Introduction--What-is-an-Instruction-Set--Definition-Instruction-Set",
                "title": "Instruction Set",
                "front": "Instruction Set",
                "back": "The vocabulary of commands understood by a given computer architecture.",
                "type": "definition",
                "section": "Introduction: What is an Instruction Set?",
                "subsection": "Definition"
              },
              {
                "id": "3-Introduction--What-is-an-Instruction-Set--Definition-Key-Characteristics",
                "title": "Key Characteristics",
                "front": "Key Characteristics",
                "back": "1. Different computers have different instruction sets\n2. But many aspects are common across architectures\n3. All computers are built from similar underlying principles\n4. All computers must provide a few basic operations",
                "type": "list",
                "section": "Introduction: What is an Instruction Set?",
                "subsection": "Definition"
              }
            ]
          },
          {
            "subsection": "Common Goals",
            "cardCount": 3,
            "cards": [
              {
                "id": "3-Introduction--What-is-an-Instruction-Set--Common-Goals-Design-Objectives",
                "title": "Design Objectives",
                "front": "Design Objectives",
                "back": "1. **Easy to build hardware:** Simple instructions are easier to implement\n2. **Easy to build compiler:** Instructions should map well from high-level languages\n3. **Maximize performance:** Fast execution\n4. **Minimize cost:** Affordable to manufacture\n5. **Minimize energy:** Power-efficient operation",
                "type": "list",
                "section": "Introduction: What is an Instruction Set?",
                "subsection": "Common Goals"
              },
              {
                "id": "3-Introduction--What-is-an-Instruction-Set--Common-Goals-Modern-Trend",
                "title": "Modern Trend",
                "front": "Modern Trend",
                "back": "Many modern computers have **simple instruction sets** (RISC - Reduced Instruction Set Computer).",
                "type": "definition",
                "section": "Introduction: What is an Instruction Set?",
                "subsection": "Common Goals"
              },
              {
                "id": "3-Introduction--What-is-an-Instruction-Set--Common-Goals-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "The instruction set is the **interface** between software and hardware. It defines what operations the processor can perform and how programs specify those operations.",
                "type": "definition",
                "section": "Introduction: What is an Instruction Set?",
                "subsection": "Common Goals"
              }
            ]
          }
        ]
      },
      {
        "section": "Elements of a Machine Instruction",
        "subsections": [
          {
            "subsection": "Four Essential Elements",
            "cardCount": 17,
            "cards": [
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-1--Operation-Code--Opcode-",
                "title": "1. Operation Code (Opcode)",
                "front": "1. Operation Code (Opcode)",
                "back": "",
                "type": "concept",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Specifies the operation to be performed.",
                "type": "definition",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. ADD: Addition\n2. SUB: Subtraction\n3. MUL: Multiplication\n4. LOAD: Load from memory\n5. STORE: Store to memory\n6. JUMP: Unconditional branch\n7. BRANCH: Conditional branch\n8. I/O: Input/Output operations",
                "type": "list",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Representation",
                "title": "Representation",
                "front": "Representation",
                "back": "1. Binary code (machine language)\n2. Each operation has a unique binary pattern\n3. Opcode field in instruction word",
                "type": "list",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Example",
                "title": "Example",
                "front": "Example",
                "back": "Opcode: 000000 (6 bits) = ADD operation Opcode: 100011 (6 bits) = LOAD WORD operation",
                "type": "definition",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-2--Source-Operand-Reference",
                "title": "2. Source Operand Reference",
                "front": "2. Source Operand Reference",
                "back": "",
                "type": "concept",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Specifies one or more source operands (inputs for the operation).",
                "type": "definition",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Operation may involve one or more source operands\n2. Unary operations: 1 source operand (e.g., NOT, NEGATE)\n3. Binary operations: 2 source operands (e.g., ADD, SUBTRACT)\n4. Some operations have no source operands (e.g., NOP - No Operation)",
                "type": "list",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Example",
                "title": "Example",
                "front": "Example",
                "back": "ADD R1, R2, R3 │ │ └─► Source operand 2 (R3) │ └─────► Source operand 1 (R2) └─────────► Destination (R1)",
                "type": "definition",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-3--Result-Operand-Reference",
                "title": "3. Result Operand Reference",
                "front": "3. Result Operand Reference",
                "back": "",
                "type": "concept",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Specifies where the result of the operation should be stored.",
                "type": "definition",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Not all operations produce results (e.g., BRANCH, JUMP)\n2. Result may be stored in:\n3. Register\n4. Memory location\n5. Condition codes (flags)\n6. Multiple locations",
                "type": "list",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Example",
                "title": "Example",
                "front": "Example",
                "back": "ADD R1, R2, R3 └─► Result stored in R1",
                "type": "definition",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-4--Next-Instruction-Reference",
                "title": "4. Next Instruction Reference",
                "front": "4. Next Instruction Reference",
                "back": "",
                "type": "concept",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Tells the processor where to fetch the next instruction.",
                "type": "definition",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. In most architectures, this is **implicit** (from Program Counter)\n2. PC is automatically incremented after each instruction\n3. Only explicit for:\n4. Branch instructions (conditional)\n5. Jump instructions (unconditional)\n6. Subroutine calls\n7. Returns from subroutines",
                "type": "list",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              },
              {
                "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Example",
                "title": "Example",
                "front": "Example",
                "back": "Normal: PC = PC + 4 (next sequential instruction) Branch: PC = target_address (if condition true) Jump: PC = target_address (always)",
                "type": "definition",
                "section": "Elements of a Machine Instruction",
                "subsection": "Four Essential Elements"
              }
            ]
          },
          {
            "subsection": "Complete Instruction Structure",
            "cardCount": 1,
            "cards": [
              {
                "id": "3-Elements-of-a-Machine-Instruction-Complete-Instruction-Structure-Note",
                "title": "Note",
                "front": "Note",
                "back": "Actual structure varies by instruction type and architecture.",
                "type": "definition",
                "section": "Elements of a Machine Instruction",
                "subsection": "Complete Instruction Structure"
              }
            ]
          }
        ]
      },
      {
        "section": "Number of Addresses in Instructions",
        "subsections": [
          {
            "subsection": "Maximum Number Needed",
            "cardCount": 4,
            "cards": [
              {
                "id": "3-Number-of-Addresses-in-Instructions-Maximum-Number-Needed-Question",
                "title": "Question",
                "front": "Question",
                "back": "What is the maximum number of addresses one might need in an instruction?",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Maximum Number Needed"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Maximum-Number-Needed-Analysis",
                "title": "Analysis",
                "front": "Analysis",
                "back": "1. **Source Operands:**\n2. Arithmetic/logic operations are unary (1 source) or binary (2 sources)\n3. Maximum: **2 addresses** for source operands\n4. **Result Storage:**\n5. Result must be stored somewhere\n6. Maximum: **1 address** for destination\n7. **Next Instruction:**\n8. Address of next instruction\n9. Maximum: **1 address** (usually implicit)",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Maximum Number Needed"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Maximum-Number-Needed-Theoretical-Maximum",
                "title": "Theoretical Maximum",
                "front": "Theoretical Maximum",
                "back": "3 addresses (2 sources + 1 destination)",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Maximum Number Needed"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Maximum-Number-Needed-Practical-Maximum",
                "title": "Practical Maximum",
                "front": "Practical Maximum",
                "back": "3 addresses (next instruction usually implicit via PC)",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Maximum Number Needed"
              }
            ]
          },
          {
            "subsection": "Instruction Address Categories",
            "cardCount": 32,
            "cards": [
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Zero-Address-Instructions",
                "title": "Zero-Address Instructions",
                "front": "Zero-Address Instructions",
                "back": "",
                "type": "concept",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Instructions that don't explicitly specify addresses.",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Application",
                "title": "Application",
                "front": "Application",
                "back": "**Stack-based architecture**",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-How-It-Works",
                "title": "How It Works",
                "front": "How It Works",
                "back": "1. Operands are on a **stack** (Last-In-First-Out)\n2. Top two stack elements are in processor registers\n3. Operations work on top of stack\n4. Results pushed back onto stack",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Stack-Operations",
                "title": "Stack Operations",
                "front": "Stack Operations",
                "back": "1. **PUSH:** Push value onto stack\n2. **POP:** Pop value from stack\n3. **ADD:** Pop two values, add them, push result\n4. **MULTIPLY:** Pop two values, multiply, push result",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Example---Postfix-Notation",
                "title": "Example - Postfix Notation",
                "front": "Example - Postfix Notation",
                "back": "Expression: (A + B) × C Postfix: A B + C × Instructions: PUSH A # Stack: [A] PUSH B # Stack: [A, B] ADD # Pop B, Pop A, Add, Push result # Stack: [A+B] PUSH C # Stack: [A+B, C] MULTIPLY # Pop C, Pop (A+B), Multiply, Push result # Stack: [(A+B)×C]",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Short instructions (no address fields)\n2. Simple hardware\n3. Good for expression evaluation",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. Requires postfix notation\n2. More instructions needed\n3. Stack management overhead",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-One-Address-Instructions",
                "title": "One-Address Instructions",
                "front": "One-Address Instructions",
                "back": "",
                "type": "concept",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "One explicit address, one implicit (accumulator).",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-How-It-Works",
                "title": "How It Works",
                "front": "How It Works",
                "back": "1. One operand specified explicitly (in instruction)\n2. Other operand is implicit (in **Accumulator register - AC**)\n3. Result stored in accumulator",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "LOAD A # AC = A ADD B # AC = AC + B STORE C # C = AC",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-To-compute--C---A---B",
                "title": "To compute: C = A + B",
                "front": "To compute: C = A + B",
                "back": "LOAD A # AC = A ADD B # AC = A + B STORE C # C = A + B",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Accumulator is implicit source and destination\n2. Only one general-purpose register (AC)\n3. Common in early computers",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Short instructions\n2. Simple hardware\n3. Fewer bits needed",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. Limited flexibility\n2. More instructions needed\n3. Accumulator becomes bottleneck",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Two-Address-Instructions",
                "title": "Two-Address Instructions",
                "front": "Two-Address Instructions",
                "back": "",
                "type": "concept",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Two explicit addresses.",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-How-It-Works",
                "title": "How It Works",
                "front": "How It Works",
                "back": "1. First address: Source operand 1\n2. Second address: Source operand 2 AND destination\n3. One address serves dual purpose",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "ADD A, B # A = A + B # B is source, A is source and destination",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-To-compute--C---A---B",
                "title": "To compute: C = A + B",
                "front": "To compute: C = A + B",
                "back": "MOVE C, A # C = A (copy A to C) ADD C, B # C = C + B (add B to C)",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. More flexible than one-address\n2. Common in many architectures\n3. One operand modified in place",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Moderate instruction length\n2. Good flexibility\n3. Efficient for many operations",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. One operand is destroyed\n2. May need extra MOVE instructions",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Three-Address-Instructions",
                "title": "Three-Address Instructions",
                "front": "Three-Address Instructions",
                "back": "",
                "type": "concept",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Three explicit addresses.",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-How-It-Works",
                "title": "How It Works",
                "front": "How It Works",
                "back": "1. First address: Source operand 1\n2. Second address: Source operand 2\n3. Third address: Destination (separate from sources)",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "ADD C, A, B # C = A + B # A and B unchanged",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-To-compute--C---A---B",
                "title": "To compute: C = A + B",
                "front": "To compute: C = A + B",
                "back": "ADD C, A, B # Single instruction!",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Most flexible\n2. No operands destroyed\n3. Common in modern RISC architectures",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Maximum flexibility\n2. No operand destruction\n3. Fewer instructions needed\n4. Easier for compilers",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. Longer instructions (more bits)\n2. More complex hardware\n3. More register ports needed",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Instruction Address Categories"
              }
            ]
          },
          {
            "subsection": "Modern Practice",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Number-of-Addresses-in-Instructions-Modern-Practice-Most-contemporary-machines-employ-a-mixture",
                "title": "Most contemporary machines employ a mixture",
                "front": "Most contemporary machines employ a mixture",
                "back": "1. **Two-address instructions:** For most operations\n2. **Three-address instructions:** For arithmetic/logical operations\n3. **One-address instructions:** For special cases (stack operations)\n4. **Zero-address instructions:** Rarely used (stack machines)",
                "type": "list",
                "section": "Number of Addresses in Instructions",
                "subsection": "Modern Practice"
              },
              {
                "id": "3-Number-of-Addresses-in-Instructions-Modern-Practice-Reason",
                "title": "Reason",
                "front": "Reason",
                "back": "Balance between flexibility and instruction size.",
                "type": "definition",
                "section": "Number of Addresses in Instructions",
                "subsection": "Modern Practice"
              }
            ]
          }
        ]
      },
      {
        "section": "Types of Operands",
        "subsections": [
          {
            "subsection": "Overview",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Types-of-Operands-Overview-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "The data types that machine instructions operate on.",
                "type": "definition",
                "section": "Types of Operands",
                "subsection": "Overview"
              },
              {
                "id": "3-Types-of-Operands-Overview-Key-Point",
                "title": "Key Point",
                "front": "Key Point",
                "back": "Machine instructions operate on **data**, and different types of data require different handling.",
                "type": "definition",
                "section": "Types of Operands",
                "subsection": "Overview"
              }
            ]
          },
          {
            "subsection": "Four Main Categories",
            "cardCount": 20,
            "cards": [
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-1--Addresses",
                "title": "1. Addresses",
                "front": "1. Addresses",
                "back": "",
                "type": "concept",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "1. Pointing to data locations\n2. Specifying instruction locations (for branches/jumps)\n3. Array indexing\n4. Pointer operations",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Typically same size as address bus width\n2. 32-bit systems: 32-bit addresses\n3. 64-bit systems: 64-bit addresses\n4. Unsigned integers",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Uses",
                "title": "Uses",
                "front": "Uses",
                "back": "1. Memory addressing\n2. Array indexing\n3. Pointer arithmetic\n4. Function calls (return addresses)",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "LOAD R1, [1000] # Address: 1000 BRANCH label # Address: label",
                "type": "definition",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-2--Numbers",
                "title": "2. Numbers",
                "front": "2. Numbers",
                "back": "",
                "type": "concept",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Types",
                "title": "Types",
                "front": "Types",
                "back": "1. **Signed integers:** Two's complement representation\n2. Range: -2^(n-1) to 2^(n-1) - 1 (for n bits)\n3. Example: 8-bit signed: -128 to +127\n4. **Unsigned integers:** Binary representation\n5. Range: 0 to 2^n - 1 (for n bits)\n6. Example: 8-bit unsigned: 0 to 255\n7. **IEEE 754 standard:** Most common format\n8. **Single precision:** 32 bits (1 sign + 8 exponent + 23 mantissa)\n9. **Double precision:** 64 bits (1 sign + 11 exponent + 52 mantissa)\n10. **Special values:** Infinity, NaN (Not a Number)",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. Arithmetic: ADD, SUBTRACT, MULTIPLY, DIVIDE\n2. Comparison: Compare, test for zero\n3. Conversion: Integer ↔ Floating-point",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "ADD R1, R2, R3 # Integer addition FADD F1, F2, F3 # Floating-point addition",
                "type": "definition",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-3--Characters",
                "title": "3. Characters",
                "front": "3. Characters",
                "back": "",
                "type": "concept",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Text data represented as character codes.",
                "type": "definition",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Common-Encodings",
                "title": "Common Encodings",
                "front": "Common Encodings",
                "back": "1. **ASCII:** 7-bit (128 characters), extended to 8-bit (256 characters)\n2. 'A' = 65 (0x41)\n3. 'a' = 97 (0x61)\n4. '0' = 48 (0x30)\n5. **Unicode/UTF-8:** Multi-byte encoding for international characters\n6. Variable length (1-4 bytes per character)\n7. Supports millions of characters",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. Comparison: Compare strings\n2. Conversion: Character ↔ Number\n3. Manipulation: Concatenate, extract",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "LOAD R1, 'A' # Load ASCII code 65 COMPARE R1, R2 # Compare characters",
                "type": "definition",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-4--Logical-Data",
                "title": "4. Logical Data",
                "front": "4. Logical Data",
                "back": "",
                "type": "concept",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Bit-level data treated as logical values.",
                "type": "definition",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Each bit is independent\n2. No arithmetic meaning\n3. Used for:\n4. Boolean operations\n5. Bit masks\n6. Flags\n7. Packed data",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. **AND:** Bitwise AND\n2. **OR:** Bitwise OR\n3. **XOR:** Bitwise exclusive OR\n4. **NOT:** Bitwise complement\n5. **SHIFT:** Left/right shift\n6. **ROTATE:** Circular shift",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "AND R1, R2, R3 # R1 = R2 AND R3 (bitwise) OR R1, R2, R3 # R1 = R2 OR R3 (bitwise) XOR R1, R2, R3 # R1 = R2 XOR R3 (bitwise) SHIFT R1, R2, 3 # R1 = R2 << 3 (left shift by 3)",
                "type": "definition",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              },
              {
                "id": "3-Types-of-Operands-Four-Main-Categories-Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. Setting/clearing flags\n2. Extracting bit fields\n3. Packing multiple values into one word\n4. Cryptography operations",
                "type": "list",
                "section": "Types of Operands",
                "subsection": "Four Main Categories"
              }
            ]
          }
        ]
      },
      {
        "section": "Types of Operations",
        "subsections": [
          {
            "subsection": "Overview",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Types-of-Operations-Overview-Key-Point",
                "title": "Key Point",
                "front": "Key Point",
                "back": "The number of different opcodes varies widely from machine to machine, but the same general types of operations are found on all machines.",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Overview"
              },
              {
                "id": "3-Types-of-Operations-Overview-Categorization",
                "title": "Categorization",
                "front": "Categorization",
                "back": "Operations can be grouped into several categories.",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Overview"
              }
            ]
          },
          {
            "subsection": "Seven Main Categories",
            "cardCount": 34,
            "cards": [
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-1--Data-Transfer",
                "title": "1. Data Transfer",
                "front": "1. Data Transfer",
                "back": "",
                "type": "concept",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Move data between locations.",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. **LOAD:** Transfer from memory to register\n2. **STORE:** Transfer from register to memory\n3. **MOVE:** Transfer between registers\n4. **PUSH:** Push onto stack\n5. **POP:** Pop from stack\n6. **EXCHANGE:** Swap two operands",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Most common type of operation\n2. No data transformation (just movement)\n3. May involve address calculation",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "LOAD R1, [1000] # R1 = memory[1000] STORE R1, [2000] # memory[2000] = R1 MOVE R2, R1 # R2 = R1",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-2--Arithmetic",
                "title": "2. Arithmetic",
                "front": "2. Arithmetic",
                "back": "",
                "type": "concept",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Perform mathematical calculations.",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. **ADD:** Addition\n2. **SUBTRACT:** Subtraction\n3. **MULTIPLY:** Multiplication\n4. **DIVIDE:** Division\n5. **MODULO:** Remainder\n6. **INCREMENT:** Add 1\n7. **DECREMENT:** Subtract 1\n8. **NEGATE:** Two's complement negation\n9. **ABSOLUTE VALUE:** |x|",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Types",
                "title": "Types",
                "front": "Types",
                "back": "1. **Integer arithmetic:** Operates on integers\n2. **Floating-point arithmetic:** Operates on floating-point numbers\n3. **Fixed-point arithmetic:** Operates on fixed-point numbers",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "ADD R1, R2, R3 # R1 = R2 + R3 SUB R1, R2, R3 # R1 = R2 - R3 MUL R1, R2, R3 # R1 = R2 × R3 DIV R1, R2, R3 # R1 = R2 ÷ R3",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-3--Logical",
                "title": "3. Logical",
                "front": "3. Logical",
                "back": "",
                "type": "concept",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Perform bitwise logical operations.",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. **AND:** Bitwise AND\n2. **OR:** Bitwise OR\n3. **XOR:** Bitwise exclusive OR\n4. **NOT:** Bitwise complement (one's complement)\n5. **NAND:** Bitwise NAND\n6. **NOR:** Bitwise NOR",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Uses",
                "title": "Uses",
                "front": "Uses",
                "back": "1. Bit manipulation\n2. Masking\n3. Setting/clearing flags\n4. Boolean logic",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "AND R1, R2, R3 # R1 = R2 AND R3 OR R1, R2, R3 # R1 = R2 OR R3 XOR R1, R2, R3 # R1 = R2 XOR R3 NOT R1, R2 # R1 = NOT R2",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-4--Conversion",
                "title": "4. Conversion",
                "front": "4. Conversion",
                "back": "",
                "type": "concept",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Convert data from one format to another.",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. **Integer to Floating-point:** Convert integer to float\n2. **Floating-point to Integer:** Convert float to integer (truncate/round)\n3. **Sign Extension:** Extend signed number to more bits\n4. **Zero Extension:** Extend unsigned number to more bits\n5. **Byte Swap:** Change byte order (endianness)",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "INT_TO_FLOAT F1, R1 # F1 = (float) R1 FLOAT_TO_INT R1, F1 # R1 = (int) F1 SIGN_EXTEND R1, R2 # Extend R2 (8-bit) to R1 (32-bit)",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-5--I-O--Input-Output-",
                "title": "5. I/O (Input/Output)",
                "front": "5. I/O (Input/Output)",
                "back": "",
                "type": "concept",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Transfer data between processor and I/O devices.",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. **IN:** Read from I/O port\n2. **OUT:** Write to I/O port\n3. **READ:** Read from I/O device\n4. **WRITE:** Write to I/O device",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. May be memory-mapped (treated like memory)\n2. May use special I/O instructions\n3. Often involves device addressing",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "IN R1, PORT5 # R1 = input from port 5 OUT PORT5, R1 # Output R1 to port 5",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-6--System-Control",
                "title": "6. System Control",
                "front": "6. System Control",
                "back": "",
                "type": "concept",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Control processor and system operation.",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. **HALT:** Stop processor\n2. **NOP:** No operation (do nothing)\n3. **WAIT:** Wait for interrupt\n4. **INTERRUPT ENABLE/DISABLE:** Control interrupts\n5. **PRIVILEGE MODE:** Change processor mode\n6. **CACHE CONTROL:** Flush/invalidate cache\n7. **TLB CONTROL:** Translation Lookaside Buffer operations",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Usually privileged (OS/kernel only)\n2. Control system behavior\n3. Not available to user programs",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "HALT # Stop processor NOP # No operation EI # Enable interrupts DI # Disable interrupts",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-7--Transfer-of-Control",
                "title": "7. Transfer of Control",
                "front": "7. Transfer of Control",
                "back": "",
                "type": "concept",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Alter the normal sequential execution flow.",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
                "title": "Operations",
                "front": "Operations",
                "back": "1. **JUMP:** Unconditional branch\n2. **BRANCH:** Conditional branch\n3. **CALL:** Subroutine call\n4. **RETURN:** Return from subroutine\n5. **SKIP:** Skip next instruction",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Conditional-Branches",
                "title": "Conditional Branches",
                "front": "Conditional Branches",
                "back": "1. **BRANCH IF ZERO:** Branch if result is zero\n2. **BRANCH IF NOT ZERO:** Branch if result is not zero\n3. **BRANCH IF EQUAL:** Branch if two values equal\n4. **BRANCH IF NOT EQUAL:** Branch if two values not equal\n5. **BRANCH IF LESS:** Branch if first < second\n6. **BRANCH IF GREATER:** Branch if first > second\n7. **BRANCH IF LESS OR EQUAL:** Branch if first ≤ second\n8. **BRANCH IF GREATER OR EQUAL:** Branch if first ≥ second",
                "type": "list",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              },
              {
                "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
                "title": "Example",
                "front": "Example",
                "back": "JUMP label # Unconditional jump to label BRANCH IF ZERO label # Jump if zero flag set CALL subroutine # Call function RETURN # Return from function",
                "type": "definition",
                "section": "Types of Operations",
                "subsection": "Seven Main Categories"
              }
            ]
          }
        ]
      },
      {
        "section": "Instruction Set Design Considerations",
        "subsections": [
          {
            "subsection": "Five Key Design Aspects",
            "cardCount": 20,
            "cards": [
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-1--Operation-Repertoire",
                "title": "1. Operation Repertoire",
                "front": "1. Operation Repertoire",
                "back": "",
                "type": "concept",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
                "title": "Questions",
                "front": "Questions",
                "back": "1. How many operations to provide?\n2. Which operations to include?\n3. How complex should operations be?",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Trade-offs",
                "title": "Trade-offs",
                "front": "Trade-offs",
                "back": "1. **More operations:** More functionality, but more complex hardware\n2. **Fewer operations:** Simpler hardware, but may need multiple instructions for complex operations\n3. **Complex operations:** Fewer instructions, but slower execution\n4. **Simple operations:** Faster execution, but more instructions needed",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **CISC (Complex Instruction Set Computer):** Many complex instructions\n2. **RISC (Reduced Instruction Set Computer):** Few simple instructions",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-2--Data-Types",
                "title": "2. Data Types",
                "front": "2. Data Types",
                "back": "",
                "type": "concept",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
                "title": "Questions",
                "front": "Questions",
                "back": "1. What data types to support?\n2. How are they represented?\n3. What operations are available for each type?",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Common-Types",
                "title": "Common Types",
                "front": "Common Types",
                "back": "1. Integers (signed/unsigned, various sizes)\n2. Floating-point (single/double precision)\n3. Characters\n4. Logical (bit strings)\n5. Addresses",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Considerations",
                "title": "Considerations",
                "front": "Considerations",
                "back": "1. Hardware support vs. software emulation\n2. Performance vs. cost\n3. Compatibility requirements",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-3--Instruction-Format",
                "title": "3. Instruction Format",
                "front": "3. Instruction Format",
                "back": "",
                "type": "concept",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
                "title": "Questions",
                "front": "Questions",
                "back": "1. How long should instructions be?\n2. How many addresses per instruction?\n3. How are fields organized?\n4. Fixed-length or variable-length?",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Factors",
                "title": "Factors",
                "front": "Factors",
                "back": "1. **Instruction length:** Affects code density and memory usage\n2. **Number of addresses:** Affects flexibility and instruction size\n3. **Field sizes:** Must accommodate opcodes, registers, addresses, immediates\n4. **Format consistency:** Regular formats simplify decoding",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **Fixed-length:** All instructions same size (e.g., 32 bits)\n2. **Variable-length:** Different instructions different sizes (e.g., x86: 1-15 bytes)",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-4--Registers",
                "title": "4. Registers",
                "front": "4. Registers",
                "back": "",
                "type": "concept",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
                "title": "Questions",
                "front": "Questions",
                "back": "1. How many registers?\n2. What are they used for?\n3. How are they organized?",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Considerations",
                "title": "Considerations",
                "front": "Considerations",
                "back": "1. **More registers:** Better performance, but more expensive\n2. **Fewer registers:** Cheaper, but more memory accesses\n3. **Special-purpose vs. general-purpose:** Flexibility vs. optimization\n4. **Register windows:** For procedure calls",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **MIPS:** 32 general-purpose registers\n2. **x86:** 8 general-purpose registers (32-bit), 16 (64-bit)\n3. **ARM:** 16 general-purpose registers",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-5--Addressing",
                "title": "5. Addressing",
                "front": "5. Addressing",
                "back": "",
                "type": "concept",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
                "title": "Questions",
                "front": "Questions",
                "back": "1. What addressing modes to support?\n2. How are addresses specified?\n3. How are addresses calculated?",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Addressing-Modes",
                "title": "Addressing Modes",
                "front": "Addressing Modes",
                "back": "1. Immediate\n2. Direct\n3. Indirect\n4. Register\n5. Register indirect\n6. Displacement (base + offset)\n7. Indexed\n8. Stack",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              },
              {
                "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Considerations",
                "title": "Considerations",
                "front": "Considerations",
                "back": "1. **More modes:** More flexibility, but more complex\n2. **Fewer modes:** Simpler, but may need more instructions\n3. **Address calculation:** Hardware vs. software",
                "type": "list",
                "section": "Instruction Set Design Considerations",
                "subsection": "Five Key Design Aspects"
              }
            ]
          }
        ]
      },
      {
        "section": "Design Trade-offs",
        "subsections": [
          {
            "subsection": "Fewer Addresses per Instruction",
            "cardCount": 3,
            "cards": [
              {
                "id": "3-Design-Trade-offs-Fewer-Addresses-per-Instruction-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **More primitive instructions:** Simpler processor design\n2. **Shorter instructions:** Fewer bits needed\n3. **Lower hardware complexity:** Easier to implement",
                "type": "list",
                "section": "Design Trade-offs",
                "subsection": "Fewer Addresses per Instruction"
              },
              {
                "id": "3-Design-Trade-offs-Fewer-Addresses-per-Instruction-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **More total instructions:** Programs are longer\n2. **Longer execution times:** More instructions to execute\n3. **More complex programs:** Harder to write and optimize",
                "type": "list",
                "section": "Design Trade-offs",
                "subsection": "Fewer Addresses per Instruction"
              },
              {
                "id": "3-Design-Trade-offs-Fewer-Addresses-per-Instruction-Example",
                "title": "Example",
                "front": "Example",
                "back": "3-address: ADD C, A, B # 1 instruction 1-address: LOAD A, ADD B, STORE C # 3 instructions",
                "type": "definition",
                "section": "Design Trade-offs",
                "subsection": "Fewer Addresses per Instruction"
              }
            ]
          },
          {
            "subsection": "One-Address vs. Multiple-Address",
            "cardCount": 4,
            "cards": [
              {
                "id": "3-Design-Trade-offs-One-Address-vs--Multiple-Address-One-Address--Accumulator-",
                "title": "One-Address (Accumulator)",
                "front": "One-Address (Accumulator)",
                "back": "1. **Single register (AC):** Limited flexibility\n2. **More memory references:** Slower execution\n3. **Simpler hardware:** Lower cost",
                "type": "list",
                "section": "Design Trade-offs",
                "subsection": "One-Address vs. Multiple-Address"
              },
              {
                "id": "3-Design-Trade-offs-One-Address-vs--Multiple-Address-Multiple-Address",
                "title": "Multiple-Address",
                "front": "Multiple-Address",
                "back": "1. **Multiple registers:** More flexibility\n2. **Fewer memory references:** Faster execution (registers are faster)\n3. **More complex hardware:** Higher cost",
                "type": "list",
                "section": "Design Trade-offs",
                "subsection": "One-Address vs. Multiple-Address"
              },
              {
                "id": "3-Design-Trade-offs-One-Address-vs--Multiple-Address-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "Register references are **faster** than memory references, so multiple registers speed up execution.",
                "type": "definition",
                "section": "Design Trade-offs",
                "subsection": "One-Address vs. Multiple-Address"
              },
              {
                "id": "3-Design-Trade-offs-One-Address-vs--Multiple-Address-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "Most contemporary machines use a **mixture of two- and three-address instructions** for flexibility and performance.",
                "type": "definition",
                "section": "Design Trade-offs",
                "subsection": "One-Address vs. Multiple-Address"
              }
            ]
          },
          {
            "subsection": "Other Factors",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Design-Trade-offs-Other-Factors-Additional-Considerations",
                "title": "Additional Considerations",
                "front": "Additional Considerations",
                "back": "1. **Memory vs. Register References:**\n2. Fewer registers → fewer bits needed for register reference\n3. More registers → more flexibility but more bits needed\n4. **Addressing Modes:**\n5. More modes → more flexibility but more bits needed\n6. Mode specification takes 1 or more bits\n7. **Instruction Format Variety:**\n8. Fixed format: Simpler decoding\n9. Variable format: Better code density\n10. Most processors use **variety of formats**",
                "type": "list",
                "section": "Design Trade-offs",
                "subsection": "Other Factors"
              },
              {
                "id": "3-Design-Trade-offs-Other-Factors-Example",
                "title": "Example",
                "front": "Example",
                "back": "R-format: ADD R1, R2, R3 # All registers I-format: ADD R1, R2, 100 # Register + immediate J-format: JUMP label # Jump address",
                "type": "definition",
                "section": "Design Trade-offs",
                "subsection": "Other Factors"
              }
            ]
          }
        ]
      },
      {
        "section": "Key Concepts Summary",
        "subsections": [
          {
            "subsection": "Instruction Set Fundamentals",
            "cardCount": 1,
            "cards": [
              {
                "id": "3-Key-Concepts-Summary-Instruction-Set-Fundamentals-Instruction-Set-Fundamentals",
                "title": "Instruction Set Fundamentals",
                "front": "Instruction Set Fundamentals",
                "back": "1. **Instruction Set = Vocabulary:** Defines what operations processor can perform\n2. **Four Elements:** Opcode, source operands, result, next instruction\n3. **Address Count:** 0, 1, 2, or 3 addresses (trade-offs exist)\n4. **Operand Types:** Addresses, numbers, characters, logical data\n5. **Operation Types:** Data transfer, arithmetic, logical, conversion, I/O, system control, transfer of control",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Instruction Set Fundamentals"
              }
            ]
          },
          {
            "subsection": "Design Principles",
            "cardCount": 1,
            "cards": [
              {
                "id": "3-Key-Concepts-Summary-Design-Principles-Design-Principles",
                "title": "Design Principles",
                "front": "Design Principles",
                "back": "1. **Trade-offs Everywhere:**\n2. Flexibility vs. simplicity\n3. Performance vs. cost\n4. Instruction size vs. functionality\n5. **Modern Trend:**\n6. Simple instruction sets (RISC)\n7. Multiple registers\n8. Load-store architecture\n9. Regular instruction formats\n10. **Key Factors:**\n11. Operation repertoire\n12. Data types\n13. Instruction format\n14. Registers\n15. Addressing modes",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Design Principles"
              }
            ]
          }
        ]
      },
      {
        "section": "Practice Problems and Examples",
        "subsections": [
          {
            "subsection": "Problem 1: Instruction Elements",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Practice-Problems-and-Examples-Problem-1--Instruction-Elements-Question",
                "title": "Question",
                "front": "Question",
                "back": "Identify the four elements in this instruction: `ADD R1, R2, R3`",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Instruction Elements"
              },
              {
                "id": "3-Practice-Problems-and-Examples-Problem-1--Instruction-Elements-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **Opcode:** ADD (operation code)\n2. **Source Operand 1:** R2\n3. **Source Operand 2:** R3\n4. **Result Operand:** R1\n5. **Next Instruction:** Implicit (PC + instruction_size)",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Instruction Elements"
              }
            ]
          },
          {
            "subsection": "Problem 2: Address Count Comparison",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Practice-Problems-and-Examples-Problem-2--Address-Count-Comparison-Question",
                "title": "Question",
                "front": "Question",
                "back": "Convert this 3-address instruction to 1-address format: `MULTIPLY C, A, B`",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Address Count Comparison"
              },
              {
                "id": "3-Practice-Problems-and-Examples-Problem-2--Address-Count-Comparison-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "LOAD A # AC = A MULTIPLY B # AC = AC × B STORE C # C = AC",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Address Count Comparison"
              }
            ]
          },
          {
            "subsection": "Problem 3: Operand Types",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Practice-Problems-and-Examples-Problem-3--Operand-Types-Question",
                "title": "Question",
                "front": "Question",
                "back": "Classify the operand types in: `ADD R1, R2, 42`",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: Operand Types"
              },
              {
                "id": "3-Practice-Problems-and-Examples-Problem-3--Operand-Types-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **R1:** Register (address of register)\n2. **R2:** Register (address of register)\n3. **42:** Immediate (number - integer constant)",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: Operand Types"
              }
            ]
          },
          {
            "subsection": "Problem 4: Operation Categories",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Practice-Problems-and-Examples-Problem-4--Operation-Categories-Question",
                "title": "Question",
                "front": "Question",
                "back": "1. `LOAD R1, [1000]`\n2. `ADD R1, R2, R3`\n3. `AND R1, R2, R3`\n4. `BRANCH IF ZERO label`",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Operation Categories"
              },
              {
                "id": "3-Practice-Problems-and-Examples-Problem-4--Operation-Categories-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. `LOAD`: Data transfer\n2. `ADD`: Arithmetic\n3. `AND`: Logical\n4. `BRANCH`: Transfer of control",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Operation Categories"
              }
            ]
          },
          {
            "subsection": "Problem 5: Design Trade-off",
            "cardCount": 2,
            "cards": [
              {
                "id": "3-Practice-Problems-and-Examples-Problem-5--Design-Trade-off-Question",
                "title": "Question",
                "front": "Question",
                "back": "Why do modern processors use multiple registers instead of a single accumulator?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Design Trade-off"
              },
              {
                "id": "3-Practice-Problems-and-Examples-Problem-5--Design-Trade-off-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **Performance:** Register accesses are much faster than memory accesses\n2. **Flexibility:** Multiple registers allow more operations without memory access\n3. **Parallelism:** Can work with multiple values simultaneously\n4. **Compiler optimization:** Easier to optimize code with more registers\n5. **Understand Trade-offs:**\n6. Every design decision has pros and cons\n7. Compare different approaches\n8. Understand why certain choices are made\n9. **Practice Conversions:**\n10. Convert between different address formats\n11. Understand how same operation can be expressed differently\n12. **Classify Operations:**\n13. Learn to identify operation types\n14. Understand what each category does\n15. **Think About Implementation:**\n16. How would hardware implement this?\n17. What are the performance implications?\n18. What are the cost implications?\n19. **Compare Architectures:**\n20. RISC vs. CISC\n21. Different register organizations\n22. Different addressing modes\n23. **What instructions are:** Vocabulary of processor commands\n24. **What they contain:** Opcode, operands, results, next instruction\n25. **How many addresses:** 0, 1, 2, or 3 (with trade-offs)\n26. **What data types:** Addresses, numbers, characters, logical\n27. **What operations:** Seven main categories\n28. **How to design:** Five key considerations with trade-offs\n29. Analyze different instruction sets\n30. Understand design decisions\n31. Evaluate performance implications\n32. Appreciate modern RISC architectures",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Design Trade-off"
              }
            ]
          }
        ]
      },
      {
        "section": "Conclusion",
        "subsections": [
          {
            "subsection": "General",
            "cardCount": 1,
            "cards": [
              {
                "id": "3-Conclusion--Next",
                "title": "Next",
                "front": "Next",
                "back": "Part 2 covers the MIPS architecture as a concrete example, showing how these principles are applied in practice. *End of Group 3 Part 1 Study Guide*",
                "type": "definition",
                "section": "Conclusion",
                "subsection": ""
              }
            ]
          }
        ]
      }
    ],
    "allCards": [
      {
        "id": "3-Detailed-Study-Guide--Detailed-Study-Guide",
        "title": "Detailed Study Guide",
        "front": "Detailed Study Guide",
        "back": "1. [Introduction: What is an Instruction Set?](#introduction-what-is-an-instruction-set)\n2. [Elements of a Machine Instruction](#elements-of-a-machine-instruction)\n3. [Number of Addresses in Instructions](#number-of-addresses-in-instructions)\n4. [Types of Operands](#types-of-operands)\n5. [Types of Operations](#types-of-operations)\n6. [Instruction Set Design Considerations](#instruction-set-design-considerations)\n7. [Design Trade-offs](#design-trade-offs)\n8. [Key Concepts Summary](#key-concepts-summary)\n9. [Practice Problems and Examples](#practice-problems-and-examples)",
        "type": "list",
        "section": "Detailed Study Guide",
        "subsection": ""
      },
      {
        "id": "3-Introduction--What-is-an-Instruction-Set--Definition-Instruction-Set",
        "title": "Instruction Set",
        "front": "Instruction Set",
        "back": "The vocabulary of commands understood by a given computer architecture.",
        "type": "definition",
        "section": "Introduction: What is an Instruction Set?",
        "subsection": "Definition"
      },
      {
        "id": "3-Introduction--What-is-an-Instruction-Set--Definition-Key-Characteristics",
        "title": "Key Characteristics",
        "front": "Key Characteristics",
        "back": "1. Different computers have different instruction sets\n2. But many aspects are common across architectures\n3. All computers are built from similar underlying principles\n4. All computers must provide a few basic operations",
        "type": "list",
        "section": "Introduction: What is an Instruction Set?",
        "subsection": "Definition"
      },
      {
        "id": "3-Introduction--What-is-an-Instruction-Set--Common-Goals-Design-Objectives",
        "title": "Design Objectives",
        "front": "Design Objectives",
        "back": "1. **Easy to build hardware:** Simple instructions are easier to implement\n2. **Easy to build compiler:** Instructions should map well from high-level languages\n3. **Maximize performance:** Fast execution\n4. **Minimize cost:** Affordable to manufacture\n5. **Minimize energy:** Power-efficient operation",
        "type": "list",
        "section": "Introduction: What is an Instruction Set?",
        "subsection": "Common Goals"
      },
      {
        "id": "3-Introduction--What-is-an-Instruction-Set--Common-Goals-Modern-Trend",
        "title": "Modern Trend",
        "front": "Modern Trend",
        "back": "Many modern computers have **simple instruction sets** (RISC - Reduced Instruction Set Computer).",
        "type": "definition",
        "section": "Introduction: What is an Instruction Set?",
        "subsection": "Common Goals"
      },
      {
        "id": "3-Introduction--What-is-an-Instruction-Set--Common-Goals-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "The instruction set is the **interface** between software and hardware. It defines what operations the processor can perform and how programs specify those operations.",
        "type": "definition",
        "section": "Introduction: What is an Instruction Set?",
        "subsection": "Common Goals"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-1--Operation-Code--Opcode-",
        "title": "1. Operation Code (Opcode)",
        "front": "1. Operation Code (Opcode)",
        "back": "",
        "type": "concept",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Specifies the operation to be performed.",
        "type": "definition",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. ADD: Addition\n2. SUB: Subtraction\n3. MUL: Multiplication\n4. LOAD: Load from memory\n5. STORE: Store to memory\n6. JUMP: Unconditional branch\n7. BRANCH: Conditional branch\n8. I/O: Input/Output operations",
        "type": "list",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Representation",
        "title": "Representation",
        "front": "Representation",
        "back": "1. Binary code (machine language)\n2. Each operation has a unique binary pattern\n3. Opcode field in instruction word",
        "type": "list",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Example",
        "title": "Example",
        "front": "Example",
        "back": "Opcode: 000000 (6 bits) = ADD operation Opcode: 100011 (6 bits) = LOAD WORD operation",
        "type": "definition",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-2--Source-Operand-Reference",
        "title": "2. Source Operand Reference",
        "front": "2. Source Operand Reference",
        "back": "",
        "type": "concept",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Specifies one or more source operands (inputs for the operation).",
        "type": "definition",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Operation may involve one or more source operands\n2. Unary operations: 1 source operand (e.g., NOT, NEGATE)\n3. Binary operations: 2 source operands (e.g., ADD, SUBTRACT)\n4. Some operations have no source operands (e.g., NOP - No Operation)",
        "type": "list",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Example",
        "title": "Example",
        "front": "Example",
        "back": "ADD R1, R2, R3 │ │ └─► Source operand 2 (R3) │ └─────► Source operand 1 (R2) └─────────► Destination (R1)",
        "type": "definition",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-3--Result-Operand-Reference",
        "title": "3. Result Operand Reference",
        "front": "3. Result Operand Reference",
        "back": "",
        "type": "concept",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Specifies where the result of the operation should be stored.",
        "type": "definition",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Not all operations produce results (e.g., BRANCH, JUMP)\n2. Result may be stored in:\n3. Register\n4. Memory location\n5. Condition codes (flags)\n6. Multiple locations",
        "type": "list",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Example",
        "title": "Example",
        "front": "Example",
        "back": "ADD R1, R2, R3 └─► Result stored in R1",
        "type": "definition",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-4--Next-Instruction-Reference",
        "title": "4. Next Instruction Reference",
        "front": "4. Next Instruction Reference",
        "back": "",
        "type": "concept",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Tells the processor where to fetch the next instruction.",
        "type": "definition",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. In most architectures, this is **implicit** (from Program Counter)\n2. PC is automatically incremented after each instruction\n3. Only explicit for:\n4. Branch instructions (conditional)\n5. Jump instructions (unconditional)\n6. Subroutine calls\n7. Returns from subroutines",
        "type": "list",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Four-Essential-Elements-Example",
        "title": "Example",
        "front": "Example",
        "back": "Normal: PC = PC + 4 (next sequential instruction) Branch: PC = target_address (if condition true) Jump: PC = target_address (always)",
        "type": "definition",
        "section": "Elements of a Machine Instruction",
        "subsection": "Four Essential Elements"
      },
      {
        "id": "3-Elements-of-a-Machine-Instruction-Complete-Instruction-Structure-Note",
        "title": "Note",
        "front": "Note",
        "back": "Actual structure varies by instruction type and architecture.",
        "type": "definition",
        "section": "Elements of a Machine Instruction",
        "subsection": "Complete Instruction Structure"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Maximum-Number-Needed-Question",
        "title": "Question",
        "front": "Question",
        "back": "What is the maximum number of addresses one might need in an instruction?",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Maximum Number Needed"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Maximum-Number-Needed-Analysis",
        "title": "Analysis",
        "front": "Analysis",
        "back": "1. **Source Operands:**\n2. Arithmetic/logic operations are unary (1 source) or binary (2 sources)\n3. Maximum: **2 addresses** for source operands\n4. **Result Storage:**\n5. Result must be stored somewhere\n6. Maximum: **1 address** for destination\n7. **Next Instruction:**\n8. Address of next instruction\n9. Maximum: **1 address** (usually implicit)",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Maximum Number Needed"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Maximum-Number-Needed-Theoretical-Maximum",
        "title": "Theoretical Maximum",
        "front": "Theoretical Maximum",
        "back": "3 addresses (2 sources + 1 destination)",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Maximum Number Needed"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Maximum-Number-Needed-Practical-Maximum",
        "title": "Practical Maximum",
        "front": "Practical Maximum",
        "back": "3 addresses (next instruction usually implicit via PC)",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Maximum Number Needed"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Zero-Address-Instructions",
        "title": "Zero-Address Instructions",
        "front": "Zero-Address Instructions",
        "back": "",
        "type": "concept",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Instructions that don't explicitly specify addresses.",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Application",
        "title": "Application",
        "front": "Application",
        "back": "**Stack-based architecture**",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-How-It-Works",
        "title": "How It Works",
        "front": "How It Works",
        "back": "1. Operands are on a **stack** (Last-In-First-Out)\n2. Top two stack elements are in processor registers\n3. Operations work on top of stack\n4. Results pushed back onto stack",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Stack-Operations",
        "title": "Stack Operations",
        "front": "Stack Operations",
        "back": "1. **PUSH:** Push value onto stack\n2. **POP:** Pop value from stack\n3. **ADD:** Pop two values, add them, push result\n4. **MULTIPLY:** Pop two values, multiply, push result",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Example---Postfix-Notation",
        "title": "Example - Postfix Notation",
        "front": "Example - Postfix Notation",
        "back": "Expression: (A + B) × C Postfix: A B + C × Instructions: PUSH A # Stack: [A] PUSH B # Stack: [A, B] ADD # Pop B, Pop A, Add, Push result # Stack: [A+B] PUSH C # Stack: [A+B, C] MULTIPLY # Pop C, Pop (A+B), Multiply, Push result # Stack: [(A+B)×C]",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Short instructions (no address fields)\n2. Simple hardware\n3. Good for expression evaluation",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. Requires postfix notation\n2. More instructions needed\n3. Stack management overhead",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-One-Address-Instructions",
        "title": "One-Address Instructions",
        "front": "One-Address Instructions",
        "back": "",
        "type": "concept",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "One explicit address, one implicit (accumulator).",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-How-It-Works",
        "title": "How It Works",
        "front": "How It Works",
        "back": "1. One operand specified explicitly (in instruction)\n2. Other operand is implicit (in **Accumulator register - AC**)\n3. Result stored in accumulator",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "LOAD A # AC = A ADD B # AC = AC + B STORE C # C = AC",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-To-compute--C---A---B",
        "title": "To compute: C = A + B",
        "front": "To compute: C = A + B",
        "back": "LOAD A # AC = A ADD B # AC = A + B STORE C # C = A + B",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Accumulator is implicit source and destination\n2. Only one general-purpose register (AC)\n3. Common in early computers",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Short instructions\n2. Simple hardware\n3. Fewer bits needed",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. Limited flexibility\n2. More instructions needed\n3. Accumulator becomes bottleneck",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Two-Address-Instructions",
        "title": "Two-Address Instructions",
        "front": "Two-Address Instructions",
        "back": "",
        "type": "concept",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Two explicit addresses.",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-How-It-Works",
        "title": "How It Works",
        "front": "How It Works",
        "back": "1. First address: Source operand 1\n2. Second address: Source operand 2 AND destination\n3. One address serves dual purpose",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "ADD A, B # A = A + B # B is source, A is source and destination",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-To-compute--C---A---B",
        "title": "To compute: C = A + B",
        "front": "To compute: C = A + B",
        "back": "MOVE C, A # C = A (copy A to C) ADD C, B # C = C + B (add B to C)",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. More flexible than one-address\n2. Common in many architectures\n3. One operand modified in place",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Moderate instruction length\n2. Good flexibility\n3. Efficient for many operations",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. One operand is destroyed\n2. May need extra MOVE instructions",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Three-Address-Instructions",
        "title": "Three-Address Instructions",
        "front": "Three-Address Instructions",
        "back": "",
        "type": "concept",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Three explicit addresses.",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-How-It-Works",
        "title": "How It Works",
        "front": "How It Works",
        "back": "1. First address: Source operand 1\n2. Second address: Source operand 2\n3. Third address: Destination (separate from sources)",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "ADD C, A, B # C = A + B # A and B unchanged",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-To-compute--C---A---B",
        "title": "To compute: C = A + B",
        "front": "To compute: C = A + B",
        "back": "ADD C, A, B # Single instruction!",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Most flexible\n2. No operands destroyed\n3. Common in modern RISC architectures",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Maximum flexibility\n2. No operand destruction\n3. Fewer instructions needed\n4. Easier for compilers",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Instruction-Address-Categories-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. Longer instructions (more bits)\n2. More complex hardware\n3. More register ports needed",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Instruction Address Categories"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Modern-Practice-Most-contemporary-machines-employ-a-mixture",
        "title": "Most contemporary machines employ a mixture",
        "front": "Most contemporary machines employ a mixture",
        "back": "1. **Two-address instructions:** For most operations\n2. **Three-address instructions:** For arithmetic/logical operations\n3. **One-address instructions:** For special cases (stack operations)\n4. **Zero-address instructions:** Rarely used (stack machines)",
        "type": "list",
        "section": "Number of Addresses in Instructions",
        "subsection": "Modern Practice"
      },
      {
        "id": "3-Number-of-Addresses-in-Instructions-Modern-Practice-Reason",
        "title": "Reason",
        "front": "Reason",
        "back": "Balance between flexibility and instruction size.",
        "type": "definition",
        "section": "Number of Addresses in Instructions",
        "subsection": "Modern Practice"
      },
      {
        "id": "3-Types-of-Operands-Overview-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "The data types that machine instructions operate on.",
        "type": "definition",
        "section": "Types of Operands",
        "subsection": "Overview"
      },
      {
        "id": "3-Types-of-Operands-Overview-Key-Point",
        "title": "Key Point",
        "front": "Key Point",
        "back": "Machine instructions operate on **data**, and different types of data require different handling.",
        "type": "definition",
        "section": "Types of Operands",
        "subsection": "Overview"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-1--Addresses",
        "title": "1. Addresses",
        "front": "1. Addresses",
        "back": "",
        "type": "concept",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "1. Pointing to data locations\n2. Specifying instruction locations (for branches/jumps)\n3. Array indexing\n4. Pointer operations",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Typically same size as address bus width\n2. 32-bit systems: 32-bit addresses\n3. 64-bit systems: 64-bit addresses\n4. Unsigned integers",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Uses",
        "title": "Uses",
        "front": "Uses",
        "back": "1. Memory addressing\n2. Array indexing\n3. Pointer arithmetic\n4. Function calls (return addresses)",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "LOAD R1, [1000] # Address: 1000 BRANCH label # Address: label",
        "type": "definition",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-2--Numbers",
        "title": "2. Numbers",
        "front": "2. Numbers",
        "back": "",
        "type": "concept",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Types",
        "title": "Types",
        "front": "Types",
        "back": "1. **Signed integers:** Two's complement representation\n2. Range: -2^(n-1) to 2^(n-1) - 1 (for n bits)\n3. Example: 8-bit signed: -128 to +127\n4. **Unsigned integers:** Binary representation\n5. Range: 0 to 2^n - 1 (for n bits)\n6. Example: 8-bit unsigned: 0 to 255\n7. **IEEE 754 standard:** Most common format\n8. **Single precision:** 32 bits (1 sign + 8 exponent + 23 mantissa)\n9. **Double precision:** 64 bits (1 sign + 11 exponent + 52 mantissa)\n10. **Special values:** Infinity, NaN (Not a Number)",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. Arithmetic: ADD, SUBTRACT, MULTIPLY, DIVIDE\n2. Comparison: Compare, test for zero\n3. Conversion: Integer ↔ Floating-point",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "ADD R1, R2, R3 # Integer addition FADD F1, F2, F3 # Floating-point addition",
        "type": "definition",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-3--Characters",
        "title": "3. Characters",
        "front": "3. Characters",
        "back": "",
        "type": "concept",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Text data represented as character codes.",
        "type": "definition",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Common-Encodings",
        "title": "Common Encodings",
        "front": "Common Encodings",
        "back": "1. **ASCII:** 7-bit (128 characters), extended to 8-bit (256 characters)\n2. 'A' = 65 (0x41)\n3. 'a' = 97 (0x61)\n4. '0' = 48 (0x30)\n5. **Unicode/UTF-8:** Multi-byte encoding for international characters\n6. Variable length (1-4 bytes per character)\n7. Supports millions of characters",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. Comparison: Compare strings\n2. Conversion: Character ↔ Number\n3. Manipulation: Concatenate, extract",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "LOAD R1, 'A' # Load ASCII code 65 COMPARE R1, R2 # Compare characters",
        "type": "definition",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-4--Logical-Data",
        "title": "4. Logical Data",
        "front": "4. Logical Data",
        "back": "",
        "type": "concept",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Bit-level data treated as logical values.",
        "type": "definition",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Each bit is independent\n2. No arithmetic meaning\n3. Used for:\n4. Boolean operations\n5. Bit masks\n6. Flags\n7. Packed data",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. **AND:** Bitwise AND\n2. **OR:** Bitwise OR\n3. **XOR:** Bitwise exclusive OR\n4. **NOT:** Bitwise complement\n5. **SHIFT:** Left/right shift\n6. **ROTATE:** Circular shift",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "AND R1, R2, R3 # R1 = R2 AND R3 (bitwise) OR R1, R2, R3 # R1 = R2 OR R3 (bitwise) XOR R1, R2, R3 # R1 = R2 XOR R3 (bitwise) SHIFT R1, R2, 3 # R1 = R2 << 3 (left shift by 3)",
        "type": "definition",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operands-Four-Main-Categories-Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. Setting/clearing flags\n2. Extracting bit fields\n3. Packing multiple values into one word\n4. Cryptography operations",
        "type": "list",
        "section": "Types of Operands",
        "subsection": "Four Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Overview-Key-Point",
        "title": "Key Point",
        "front": "Key Point",
        "back": "The number of different opcodes varies widely from machine to machine, but the same general types of operations are found on all machines.",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Overview"
      },
      {
        "id": "3-Types-of-Operations-Overview-Categorization",
        "title": "Categorization",
        "front": "Categorization",
        "back": "Operations can be grouped into several categories.",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Overview"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-1--Data-Transfer",
        "title": "1. Data Transfer",
        "front": "1. Data Transfer",
        "back": "",
        "type": "concept",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Move data between locations.",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. **LOAD:** Transfer from memory to register\n2. **STORE:** Transfer from register to memory\n3. **MOVE:** Transfer between registers\n4. **PUSH:** Push onto stack\n5. **POP:** Pop from stack\n6. **EXCHANGE:** Swap two operands",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Most common type of operation\n2. No data transformation (just movement)\n3. May involve address calculation",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "LOAD R1, [1000] # R1 = memory[1000] STORE R1, [2000] # memory[2000] = R1 MOVE R2, R1 # R2 = R1",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-2--Arithmetic",
        "title": "2. Arithmetic",
        "front": "2. Arithmetic",
        "back": "",
        "type": "concept",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Perform mathematical calculations.",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. **ADD:** Addition\n2. **SUBTRACT:** Subtraction\n3. **MULTIPLY:** Multiplication\n4. **DIVIDE:** Division\n5. **MODULO:** Remainder\n6. **INCREMENT:** Add 1\n7. **DECREMENT:** Subtract 1\n8. **NEGATE:** Two's complement negation\n9. **ABSOLUTE VALUE:** |x|",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Types",
        "title": "Types",
        "front": "Types",
        "back": "1. **Integer arithmetic:** Operates on integers\n2. **Floating-point arithmetic:** Operates on floating-point numbers\n3. **Fixed-point arithmetic:** Operates on fixed-point numbers",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "ADD R1, R2, R3 # R1 = R2 + R3 SUB R1, R2, R3 # R1 = R2 - R3 MUL R1, R2, R3 # R1 = R2 × R3 DIV R1, R2, R3 # R1 = R2 ÷ R3",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-3--Logical",
        "title": "3. Logical",
        "front": "3. Logical",
        "back": "",
        "type": "concept",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Perform bitwise logical operations.",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. **AND:** Bitwise AND\n2. **OR:** Bitwise OR\n3. **XOR:** Bitwise exclusive OR\n4. **NOT:** Bitwise complement (one's complement)\n5. **NAND:** Bitwise NAND\n6. **NOR:** Bitwise NOR",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Uses",
        "title": "Uses",
        "front": "Uses",
        "back": "1. Bit manipulation\n2. Masking\n3. Setting/clearing flags\n4. Boolean logic",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "AND R1, R2, R3 # R1 = R2 AND R3 OR R1, R2, R3 # R1 = R2 OR R3 XOR R1, R2, R3 # R1 = R2 XOR R3 NOT R1, R2 # R1 = NOT R2",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-4--Conversion",
        "title": "4. Conversion",
        "front": "4. Conversion",
        "back": "",
        "type": "concept",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Convert data from one format to another.",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. **Integer to Floating-point:** Convert integer to float\n2. **Floating-point to Integer:** Convert float to integer (truncate/round)\n3. **Sign Extension:** Extend signed number to more bits\n4. **Zero Extension:** Extend unsigned number to more bits\n5. **Byte Swap:** Change byte order (endianness)",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "INT_TO_FLOAT F1, R1 # F1 = (float) R1 FLOAT_TO_INT R1, F1 # R1 = (int) F1 SIGN_EXTEND R1, R2 # Extend R2 (8-bit) to R1 (32-bit)",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-5--I-O--Input-Output-",
        "title": "5. I/O (Input/Output)",
        "front": "5. I/O (Input/Output)",
        "back": "",
        "type": "concept",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Transfer data between processor and I/O devices.",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. **IN:** Read from I/O port\n2. **OUT:** Write to I/O port\n3. **READ:** Read from I/O device\n4. **WRITE:** Write to I/O device",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. May be memory-mapped (treated like memory)\n2. May use special I/O instructions\n3. Often involves device addressing",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "IN R1, PORT5 # R1 = input from port 5 OUT PORT5, R1 # Output R1 to port 5",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-6--System-Control",
        "title": "6. System Control",
        "front": "6. System Control",
        "back": "",
        "type": "concept",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Control processor and system operation.",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. **HALT:** Stop processor\n2. **NOP:** No operation (do nothing)\n3. **WAIT:** Wait for interrupt\n4. **INTERRUPT ENABLE/DISABLE:** Control interrupts\n5. **PRIVILEGE MODE:** Change processor mode\n6. **CACHE CONTROL:** Flush/invalidate cache\n7. **TLB CONTROL:** Translation Lookaside Buffer operations",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Usually privileged (OS/kernel only)\n2. Control system behavior\n3. Not available to user programs",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "HALT # Stop processor NOP # No operation EI # Enable interrupts DI # Disable interrupts",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-7--Transfer-of-Control",
        "title": "7. Transfer of Control",
        "front": "7. Transfer of Control",
        "back": "",
        "type": "concept",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Alter the normal sequential execution flow.",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Operations",
        "title": "Operations",
        "front": "Operations",
        "back": "1. **JUMP:** Unconditional branch\n2. **BRANCH:** Conditional branch\n3. **CALL:** Subroutine call\n4. **RETURN:** Return from subroutine\n5. **SKIP:** Skip next instruction",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Conditional-Branches",
        "title": "Conditional Branches",
        "front": "Conditional Branches",
        "back": "1. **BRANCH IF ZERO:** Branch if result is zero\n2. **BRANCH IF NOT ZERO:** Branch if result is not zero\n3. **BRANCH IF EQUAL:** Branch if two values equal\n4. **BRANCH IF NOT EQUAL:** Branch if two values not equal\n5. **BRANCH IF LESS:** Branch if first < second\n6. **BRANCH IF GREATER:** Branch if first > second\n7. **BRANCH IF LESS OR EQUAL:** Branch if first ≤ second\n8. **BRANCH IF GREATER OR EQUAL:** Branch if first ≥ second",
        "type": "list",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Types-of-Operations-Seven-Main-Categories-Example",
        "title": "Example",
        "front": "Example",
        "back": "JUMP label # Unconditional jump to label BRANCH IF ZERO label # Jump if zero flag set CALL subroutine # Call function RETURN # Return from function",
        "type": "definition",
        "section": "Types of Operations",
        "subsection": "Seven Main Categories"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-1--Operation-Repertoire",
        "title": "1. Operation Repertoire",
        "front": "1. Operation Repertoire",
        "back": "",
        "type": "concept",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
        "title": "Questions",
        "front": "Questions",
        "back": "1. How many operations to provide?\n2. Which operations to include?\n3. How complex should operations be?",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Trade-offs",
        "title": "Trade-offs",
        "front": "Trade-offs",
        "back": "1. **More operations:** More functionality, but more complex hardware\n2. **Fewer operations:** Simpler hardware, but may need multiple instructions for complex operations\n3. **Complex operations:** Fewer instructions, but slower execution\n4. **Simple operations:** Faster execution, but more instructions needed",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **CISC (Complex Instruction Set Computer):** Many complex instructions\n2. **RISC (Reduced Instruction Set Computer):** Few simple instructions",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-2--Data-Types",
        "title": "2. Data Types",
        "front": "2. Data Types",
        "back": "",
        "type": "concept",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
        "title": "Questions",
        "front": "Questions",
        "back": "1. What data types to support?\n2. How are they represented?\n3. What operations are available for each type?",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Common-Types",
        "title": "Common Types",
        "front": "Common Types",
        "back": "1. Integers (signed/unsigned, various sizes)\n2. Floating-point (single/double precision)\n3. Characters\n4. Logical (bit strings)\n5. Addresses",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Considerations",
        "title": "Considerations",
        "front": "Considerations",
        "back": "1. Hardware support vs. software emulation\n2. Performance vs. cost\n3. Compatibility requirements",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-3--Instruction-Format",
        "title": "3. Instruction Format",
        "front": "3. Instruction Format",
        "back": "",
        "type": "concept",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
        "title": "Questions",
        "front": "Questions",
        "back": "1. How long should instructions be?\n2. How many addresses per instruction?\n3. How are fields organized?\n4. Fixed-length or variable-length?",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Factors",
        "title": "Factors",
        "front": "Factors",
        "back": "1. **Instruction length:** Affects code density and memory usage\n2. **Number of addresses:** Affects flexibility and instruction size\n3. **Field sizes:** Must accommodate opcodes, registers, addresses, immediates\n4. **Format consistency:** Regular formats simplify decoding",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **Fixed-length:** All instructions same size (e.g., 32 bits)\n2. **Variable-length:** Different instructions different sizes (e.g., x86: 1-15 bytes)",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-4--Registers",
        "title": "4. Registers",
        "front": "4. Registers",
        "back": "",
        "type": "concept",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
        "title": "Questions",
        "front": "Questions",
        "back": "1. How many registers?\n2. What are they used for?\n3. How are they organized?",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Considerations",
        "title": "Considerations",
        "front": "Considerations",
        "back": "1. **More registers:** Better performance, but more expensive\n2. **Fewer registers:** Cheaper, but more memory accesses\n3. **Special-purpose vs. general-purpose:** Flexibility vs. optimization\n4. **Register windows:** For procedure calls",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **MIPS:** 32 general-purpose registers\n2. **x86:** 8 general-purpose registers (32-bit), 16 (64-bit)\n3. **ARM:** 16 general-purpose registers",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-5--Addressing",
        "title": "5. Addressing",
        "front": "5. Addressing",
        "back": "",
        "type": "concept",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Questions",
        "title": "Questions",
        "front": "Questions",
        "back": "1. What addressing modes to support?\n2. How are addresses specified?\n3. How are addresses calculated?",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Addressing-Modes",
        "title": "Addressing Modes",
        "front": "Addressing Modes",
        "back": "1. Immediate\n2. Direct\n3. Indirect\n4. Register\n5. Register indirect\n6. Displacement (base + offset)\n7. Indexed\n8. Stack",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Instruction-Set-Design-Considerations-Five-Key-Design-Aspects-Considerations",
        "title": "Considerations",
        "front": "Considerations",
        "back": "1. **More modes:** More flexibility, but more complex\n2. **Fewer modes:** Simpler, but may need more instructions\n3. **Address calculation:** Hardware vs. software",
        "type": "list",
        "section": "Instruction Set Design Considerations",
        "subsection": "Five Key Design Aspects"
      },
      {
        "id": "3-Design-Trade-offs-Fewer-Addresses-per-Instruction-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **More primitive instructions:** Simpler processor design\n2. **Shorter instructions:** Fewer bits needed\n3. **Lower hardware complexity:** Easier to implement",
        "type": "list",
        "section": "Design Trade-offs",
        "subsection": "Fewer Addresses per Instruction"
      },
      {
        "id": "3-Design-Trade-offs-Fewer-Addresses-per-Instruction-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **More total instructions:** Programs are longer\n2. **Longer execution times:** More instructions to execute\n3. **More complex programs:** Harder to write and optimize",
        "type": "list",
        "section": "Design Trade-offs",
        "subsection": "Fewer Addresses per Instruction"
      },
      {
        "id": "3-Design-Trade-offs-Fewer-Addresses-per-Instruction-Example",
        "title": "Example",
        "front": "Example",
        "back": "3-address: ADD C, A, B # 1 instruction 1-address: LOAD A, ADD B, STORE C # 3 instructions",
        "type": "definition",
        "section": "Design Trade-offs",
        "subsection": "Fewer Addresses per Instruction"
      },
      {
        "id": "3-Design-Trade-offs-One-Address-vs--Multiple-Address-One-Address--Accumulator-",
        "title": "One-Address (Accumulator)",
        "front": "One-Address (Accumulator)",
        "back": "1. **Single register (AC):** Limited flexibility\n2. **More memory references:** Slower execution\n3. **Simpler hardware:** Lower cost",
        "type": "list",
        "section": "Design Trade-offs",
        "subsection": "One-Address vs. Multiple-Address"
      },
      {
        "id": "3-Design-Trade-offs-One-Address-vs--Multiple-Address-Multiple-Address",
        "title": "Multiple-Address",
        "front": "Multiple-Address",
        "back": "1. **Multiple registers:** More flexibility\n2. **Fewer memory references:** Faster execution (registers are faster)\n3. **More complex hardware:** Higher cost",
        "type": "list",
        "section": "Design Trade-offs",
        "subsection": "One-Address vs. Multiple-Address"
      },
      {
        "id": "3-Design-Trade-offs-One-Address-vs--Multiple-Address-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "Register references are **faster** than memory references, so multiple registers speed up execution.",
        "type": "definition",
        "section": "Design Trade-offs",
        "subsection": "One-Address vs. Multiple-Address"
      },
      {
        "id": "3-Design-Trade-offs-One-Address-vs--Multiple-Address-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "Most contemporary machines use a **mixture of two- and three-address instructions** for flexibility and performance.",
        "type": "definition",
        "section": "Design Trade-offs",
        "subsection": "One-Address vs. Multiple-Address"
      },
      {
        "id": "3-Design-Trade-offs-Other-Factors-Additional-Considerations",
        "title": "Additional Considerations",
        "front": "Additional Considerations",
        "back": "1. **Memory vs. Register References:**\n2. Fewer registers → fewer bits needed for register reference\n3. More registers → more flexibility but more bits needed\n4. **Addressing Modes:**\n5. More modes → more flexibility but more bits needed\n6. Mode specification takes 1 or more bits\n7. **Instruction Format Variety:**\n8. Fixed format: Simpler decoding\n9. Variable format: Better code density\n10. Most processors use **variety of formats**",
        "type": "list",
        "section": "Design Trade-offs",
        "subsection": "Other Factors"
      },
      {
        "id": "3-Design-Trade-offs-Other-Factors-Example",
        "title": "Example",
        "front": "Example",
        "back": "R-format: ADD R1, R2, R3 # All registers I-format: ADD R1, R2, 100 # Register + immediate J-format: JUMP label # Jump address",
        "type": "definition",
        "section": "Design Trade-offs",
        "subsection": "Other Factors"
      },
      {
        "id": "3-Key-Concepts-Summary-Instruction-Set-Fundamentals-Instruction-Set-Fundamentals",
        "title": "Instruction Set Fundamentals",
        "front": "Instruction Set Fundamentals",
        "back": "1. **Instruction Set = Vocabulary:** Defines what operations processor can perform\n2. **Four Elements:** Opcode, source operands, result, next instruction\n3. **Address Count:** 0, 1, 2, or 3 addresses (trade-offs exist)\n4. **Operand Types:** Addresses, numbers, characters, logical data\n5. **Operation Types:** Data transfer, arithmetic, logical, conversion, I/O, system control, transfer of control",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Instruction Set Fundamentals"
      },
      {
        "id": "3-Key-Concepts-Summary-Design-Principles-Design-Principles",
        "title": "Design Principles",
        "front": "Design Principles",
        "back": "1. **Trade-offs Everywhere:**\n2. Flexibility vs. simplicity\n3. Performance vs. cost\n4. Instruction size vs. functionality\n5. **Modern Trend:**\n6. Simple instruction sets (RISC)\n7. Multiple registers\n8. Load-store architecture\n9. Regular instruction formats\n10. **Key Factors:**\n11. Operation repertoire\n12. Data types\n13. Instruction format\n14. Registers\n15. Addressing modes",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Design Principles"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-1--Instruction-Elements-Question",
        "title": "Question",
        "front": "Question",
        "back": "Identify the four elements in this instruction: `ADD R1, R2, R3`",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Instruction Elements"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-1--Instruction-Elements-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **Opcode:** ADD (operation code)\n2. **Source Operand 1:** R2\n3. **Source Operand 2:** R3\n4. **Result Operand:** R1\n5. **Next Instruction:** Implicit (PC + instruction_size)",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Instruction Elements"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-2--Address-Count-Comparison-Question",
        "title": "Question",
        "front": "Question",
        "back": "Convert this 3-address instruction to 1-address format: `MULTIPLY C, A, B`",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Address Count Comparison"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-2--Address-Count-Comparison-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "LOAD A # AC = A MULTIPLY B # AC = AC × B STORE C # C = AC",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Address Count Comparison"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-3--Operand-Types-Question",
        "title": "Question",
        "front": "Question",
        "back": "Classify the operand types in: `ADD R1, R2, 42`",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: Operand Types"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-3--Operand-Types-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **R1:** Register (address of register)\n2. **R2:** Register (address of register)\n3. **42:** Immediate (number - integer constant)",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: Operand Types"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-4--Operation-Categories-Question",
        "title": "Question",
        "front": "Question",
        "back": "1. `LOAD R1, [1000]`\n2. `ADD R1, R2, R3`\n3. `AND R1, R2, R3`\n4. `BRANCH IF ZERO label`",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Operation Categories"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-4--Operation-Categories-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. `LOAD`: Data transfer\n2. `ADD`: Arithmetic\n3. `AND`: Logical\n4. `BRANCH`: Transfer of control",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Operation Categories"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-5--Design-Trade-off-Question",
        "title": "Question",
        "front": "Question",
        "back": "Why do modern processors use multiple registers instead of a single accumulator?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Design Trade-off"
      },
      {
        "id": "3-Practice-Problems-and-Examples-Problem-5--Design-Trade-off-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **Performance:** Register accesses are much faster than memory accesses\n2. **Flexibility:** Multiple registers allow more operations without memory access\n3. **Parallelism:** Can work with multiple values simultaneously\n4. **Compiler optimization:** Easier to optimize code with more registers\n5. **Understand Trade-offs:**\n6. Every design decision has pros and cons\n7. Compare different approaches\n8. Understand why certain choices are made\n9. **Practice Conversions:**\n10. Convert between different address formats\n11. Understand how same operation can be expressed differently\n12. **Classify Operations:**\n13. Learn to identify operation types\n14. Understand what each category does\n15. **Think About Implementation:**\n16. How would hardware implement this?\n17. What are the performance implications?\n18. What are the cost implications?\n19. **Compare Architectures:**\n20. RISC vs. CISC\n21. Different register organizations\n22. Different addressing modes\n23. **What instructions are:** Vocabulary of processor commands\n24. **What they contain:** Opcode, operands, results, next instruction\n25. **How many addresses:** 0, 1, 2, or 3 (with trade-offs)\n26. **What data types:** Addresses, numbers, characters, logical\n27. **What operations:** Seven main categories\n28. **How to design:** Five key considerations with trade-offs\n29. Analyze different instruction sets\n30. Understand design decisions\n31. Evaluate performance implications\n32. Appreciate modern RISC architectures",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Design Trade-off"
      },
      {
        "id": "3-Conclusion--Next",
        "title": "Next",
        "front": "Next",
        "back": "Part 2 covers the MIPS architecture as a concrete example, showing how these principles are applied in practice. *End of Group 3 Part 1 Study Guide*",
        "type": "definition",
        "section": "Conclusion",
        "subsection": ""
      }
    ]
  },
  "4": {
    "group": 4,
    "totalCards": 271,
    "sections": [
      {
        "section": "Detailed Study Guide",
        "subsections": [
          {
            "subsection": "General",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-Detailed-Study-Guide--Detailed-Study-Guide",
                "title": "Detailed Study Guide",
                "front": "Detailed Study Guide",
                "back": "1. [Memory Characteristics and Classification](#memory-characteristics-and-classification)\n2. [The Memory Hierarchy Concept](#the-memory-hierarchy-concept)\n3. [Locality of Reference](#locality-of-reference)\n4. [Cache Memory Fundamentals](#cache-memory-fundamentals)\n5. [Cache Mapping Techniques](#cache-mapping-techniques)\n6. [Cache Replacement Policies](#cache-replacement-policies)\n7. [Write Policies](#write-policies)\n8. [Cache Performance Analysis](#cache-performance-analysis)\n9. [Multi-Level Caches](#multi-level-caches)\n10. [Internal Memory: DRAM and SRAM](#internal-memory-dram-and-sram)\n11. [Error Detection and Correction](#error-detection-and-correction)\n12. [Advanced DRAM Technologies](#advanced-dram-technologies)\n13. [Key Concepts Summary](#key-concepts-summary)\n14. [Practice Problems and Examples](#practice-problems-and-examples)",
                "type": "list",
                "section": "Detailed Study Guide",
                "subsection": ""
              }
            ]
          }
        ]
      },
      {
        "section": "Memory Characteristics and Classification",
        "subsections": [
          {
            "subsection": "Key Characteristics of Memory Systems",
            "cardCount": 33,
            "cards": [
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-1--Location",
                "title": "1. Location",
                "front": "1. Location",
                "back": "",
                "type": "concept",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-CPU",
                "title": "CPU",
                "front": "CPU",
                "back": "1. **Registers:** Fastest, smallest, most expensive\n2. Located directly in processor\n3. Used for temporary storage during execution",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Internal",
                "title": "Internal",
                "front": "Internal",
                "back": "1. **Main Memory (RAM):** Primary storage\n2. **Cache Memory:** Fast buffer between CPU and main memory\n3. Accessible directly by processor",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-External",
                "title": "External",
                "front": "External",
                "back": "1. **Secondary Storage:** Disk drives, SSDs, tape\n2. Accessible via I/O controllers\n3. Persistent, non-volatile",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-2--Capacity",
                "title": "2. Capacity",
                "front": "2. Capacity",
                "back": "",
                "type": "concept",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Word-Size",
                "title": "Word Size",
                "front": "Word Size",
                "back": "1. Natural unit of organization\n2. Common sizes: 8, 16, 32, 64 bits\n3. Determines how much data can be processed at once",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Number-of-Words-Bytes",
                "title": "Number of Words/Bytes",
                "front": "Number of Words/Bytes",
                "back": "1. Total storage capacity\n2. External memory typically expressed in bytes (KB, MB, GB, TB)\n3. Internal memory may be expressed in words or bytes",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Relationship",
                "title": "Relationship",
                "front": "Relationship",
                "back": "1. Address length (A bits) → 2^A addressable units\n2. Example: 20-bit address → 2^20 = 1,048,576 locations",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-3--Unit-of-Transfer",
                "title": "3. Unit of Transfer",
                "front": "3. Unit of Transfer",
                "back": "",
                "type": "concept",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Internal-Memory",
                "title": "Internal Memory",
                "front": "Internal Memory",
                "back": "1. Usually governed by bus data width\n2. May equal word length, but often larger\n3. Example: 32-bit processor with 64-bit data bus",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-External-Memory",
                "title": "External Memory",
                "front": "External Memory",
                "back": "1. Usually a **block** (much larger than a word)\n2. Example: Disk sectors (512 bytes, 4 KB, etc.)",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Addressable-Unit",
                "title": "Addressable Unit",
                "front": "Addressable Unit",
                "back": "1. Smallest location that can be uniquely addressed\n2. Typically: byte (8 bits) or word (16/32/64 bits)",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-4--Access-Methods",
                "title": "4. Access Methods",
                "front": "4. Access Methods",
                "back": "",
                "type": "concept",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Sequential-Access",
                "title": "Sequential Access",
                "front": "Sequential Access",
                "back": "1. Memory organized into records\n2. Must start at beginning and read through in order\n3. Access time variable, depends on location\n4. **Example:** Magnetic tape",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Direct-Access",
                "title": "Direct Access",
                "front": "Direct Access",
                "back": "1. Individual blocks have unique addresses\n2. Access by jumping to vicinity plus sequential search\n3. Access time depends on location and previous location\n4. **Example:** Magnetic disk",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Random-Access",
                "title": "Random Access",
                "front": "Random Access",
                "back": "1. Individual addresses identify locations exactly\n2. Access time independent of location or previous access\n3. **Example:** RAM, cache",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Associative-Access",
                "title": "Associative Access",
                "front": "Associative Access",
                "back": "1. Word retrieved based on portion of contents (not address)\n2. Access time independent of location or previous access\n3. **Example:** Cache (when searching by tag)",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-5--Performance",
                "title": "5. Performance",
                "front": "5. Performance",
                "back": "",
                "type": "concept",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Access-Time--Latency-",
                "title": "Access Time (Latency)",
                "front": "Access Time (Latency)",
                "back": "1. Time between presenting address and getting valid data\n2. Critical for performance\n3. Measured in nanoseconds (ns) or clock cycles",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Memory-Cycle-Time",
                "title": "Memory Cycle Time",
                "front": "Memory Cycle Time",
                "back": "1. Time required for memory to \"recover\" before next access\n2. Access time + recovery time\n3. Concerned with system bus, not processor\n4. May be longer than access time",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Transfer-Rate",
                "title": "Transfer Rate",
                "front": "Transfer Rate",
                "back": "1. Rate at which data can be transferred into/out of memory\n2. Measured in bits/second or bytes/second\n3. For random-access memory: 1/(cycle time)\n4. Also called **bandwidth**",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Example",
                "title": "Example",
                "front": "Example",
                "back": "Access time: 50 ns Cycle time: 100 ns Transfer rate: 1/100ns = 10 MB/s (for 1-byte transfers)",
                "type": "definition",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-6--Physical-Types",
                "title": "6. Physical Types",
                "front": "6. Physical Types",
                "back": "",
                "type": "concept",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Semiconductor-Memory",
                "title": "Semiconductor Memory",
                "front": "Semiconductor Memory",
                "back": "1. RAM (Random Access Memory)\n2. ROM (Read-Only Memory)\n3. Flash memory",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Magnetic-Surface-Memory",
                "title": "Magnetic Surface Memory",
                "front": "Magnetic Surface Memory",
                "back": "1. Hard disk drives\n2. Magnetic tape",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Optical",
                "title": "Optical",
                "front": "Optical",
                "back": "1. CD, DVD, Blu-ray",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-7--Physical-Characteristics",
                "title": "7. Physical Characteristics",
                "front": "7. Physical Characteristics",
                "back": "",
                "type": "concept",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Volatile-vs--Nonvolatile",
                "title": "Volatile vs. Nonvolatile",
                "front": "Volatile vs. Nonvolatile",
                "back": "",
                "type": "definition",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Volatile-Memory",
                "title": "Volatile Memory",
                "front": "Volatile Memory",
                "back": "1. Information lost when power is switched off\n2. Requires continuous power to retain data\n3. **Examples:** DRAM, SRAM",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Nonvolatile-Memory",
                "title": "Nonvolatile Memory",
                "front": "Nonvolatile Memory",
                "back": "1. Information remains without deterioration\n2. No electrical power needed to retain information\n3. **Examples:** ROM, Flash, Magnetic disk",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Erasable-vs--Nonerasable",
                "title": "Erasable vs. Nonerasable",
                "front": "Erasable vs. Nonerasable",
                "back": "",
                "type": "definition",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Nonerasable-Memory",
                "title": "Nonerasable Memory",
                "front": "Nonerasable Memory",
                "back": "1. Cannot be altered (except by destroying storage unit)\n2. **Example:** ROM (Read-Only Memory)",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              },
              {
                "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Erasable-Memory",
                "title": "Erasable Memory",
                "front": "Erasable Memory",
                "back": "1. Can be written and rewritten\n2. **Examples:** RAM, EEPROM, Flash",
                "type": "list",
                "section": "Memory Characteristics and Classification",
                "subsection": "Key Characteristics of Memory Systems"
              }
            ]
          }
        ]
      },
      {
        "section": "The Memory Hierarchy Concept",
        "subsections": [
          {
            "subsection": "The Memory Dilemma",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-The-Memory-Hierarchy-Concept-The-Memory-Dilemma-Design-Constraints",
                "title": "Design Constraints",
                "front": "Design Constraints",
                "back": "1. **How much?** (Capacity)\n2. **How fast?** (Access time)\n3. **How expensive?** (Cost per bit)",
                "type": "list",
                "section": "The Memory Hierarchy Concept",
                "subsection": "The Memory Dilemma"
              },
              {
                "id": "4-The-Memory-Hierarchy-Concept-The-Memory-Dilemma-The-Trade-off",
                "title": "The Trade-off",
                "front": "The Trade-off",
                "back": "1. **Faster access time** → **Greater cost per bit**\n2. **Greater capacity** → **Smaller cost per bit**\n3. **Greater capacity** → **Slower access time**",
                "type": "list",
                "section": "The Memory Hierarchy Concept",
                "subsection": "The Memory Dilemma"
              },
              {
                "id": "4-The-Memory-Hierarchy-Concept-The-Memory-Dilemma-The-Problem",
                "title": "The Problem",
                "front": "The Problem",
                "back": "1. We want: Large capacity, fast access, low cost\n2. But: Can't have all three simultaneously!",
                "type": "list",
                "section": "The Memory Hierarchy Concept",
                "subsection": "The Memory Dilemma"
              }
            ]
          },
          {
            "subsection": "The Solution: Memory Hierarchy",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-The-Memory-Hierarchy-Concept-The-Solution--Memory-Hierarchy-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Use multiple levels of memory with different speeds and sizes.",
                "type": "definition",
                "section": "The Memory Hierarchy Concept",
                "subsection": "The Solution: Memory Hierarchy"
              },
              {
                "id": "4-The-Memory-Hierarchy-Concept-The-Solution--Memory-Hierarchy-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Store frequently accessed data in fast, expensive memory; store bulk data in slow, cheap memory.",
                "type": "definition",
                "section": "The Memory Hierarchy Concept",
                "subsection": "The Solution: Memory Hierarchy"
              }
            ]
          },
          {
            "subsection": "Memory Hierarchy Levels",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-The-Memory-Hierarchy-Concept-Memory-Hierarchy-Levels-From-Fastest-Smallest-Most-Expensive-to-Slowest-Largest-Cheapest",
                "title": "From Fastest/Smallest/Most Expensive to Slowest/Largest/Cheapest",
                "front": "From Fastest/Smallest/Most Expensive to Slowest/Largest/Cheapest",
                "back": "Level 1: CPU Registers Level 2: Cache Memory (L1, L2, L3) Level 3: Main Memory (DRAM) Level 4: Secondary Storage (Disk, SSD) Level 5: Tertiary Storage (Tape, Optical)",
                "type": "definition",
                "section": "The Memory Hierarchy Concept",
                "subsection": "Memory Hierarchy Levels"
              }
            ]
          },
          {
            "subsection": "Hierarchy Characteristics",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Characteristics-Going-Down-the-Hierarchy",
                "title": "Going Down the Hierarchy",
                "front": "Going Down the Hierarchy",
                "back": "1. **Decreasing cost per bit**\n2. Registers: Very expensive\n3. Cache: Expensive\n4. Main memory: Moderate cost\n5. Disk: Cheap\n6. **Increasing capacity**\n7. Registers: ~32-64 words\n8. Cache: KB to MB\n9. Main memory: GB\n10. Disk: TB\n11. **Increasing access time**\n12. Registers: 1 cycle (nanoseconds)\n13. Cache: 1-10 cycles (nanoseconds)\n14. Main memory: 50-100 cycles (nanoseconds)\n15. Disk: Millions of cycles (milliseconds)\n16. **Decreasing frequency of access**\n17. Most accesses: Registers\n18. Many accesses: Cache\n19. Some accesses: Main memory\n20. Few accesses: Disk",
                "type": "list",
                "section": "The Memory Hierarchy Concept",
                "subsection": "Hierarchy Characteristics"
              }
            ]
          },
          {
            "subsection": "Hierarchy Example",
            "cardCount": 4,
            "cards": [
              {
                "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Example-Typical-System",
                "title": "Typical System",
                "front": "Typical System",
                "back": "1. **L1 Cache:** 32 KB, 1 cycle access, $100/GB\n2. **L2 Cache:** 256 KB, 5 cycles access, $50/GB\n3. **L3 Cache:** 8 MB, 20 cycles access, $10/GB\n4. **Main Memory:** 16 GB, 100 cycles access, $1/GB\n5. **Disk:** 1 TB, 10,000,000 cycles access, $0.01/GB",
                "type": "list",
                "section": "The Memory Hierarchy Concept",
                "subsection": "Hierarchy Example"
              },
              {
                "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Example-Access-Distribution",
                "title": "Access Distribution",
                "front": "Access Distribution",
                "back": "1. 95% from L1 cache\n2. 4.999% from L2 cache\n3. 0.001% from L3 cache\n4. 0.000005% from main memory\n5. Even fewer from disk",
                "type": "list",
                "section": "The Memory Hierarchy Concept",
                "subsection": "Hierarchy Example"
              },
              {
                "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Example-Average-Access-Time-Calculation",
                "title": "Average Access Time Calculation",
                "front": "Average Access Time Calculation",
                "back": "AMAT = 0.95 × 1 + 0.04999 × 5 + 0.00001 × 20 + 0.00000005 × 100 = 0.95 + 0.25 + 0.0002 + 0.000005 ≈ 1.2 cycles",
                "type": "definition",
                "section": "The Memory Hierarchy Concept",
                "subsection": "Hierarchy Example"
              },
              {
                "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Example-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "Average access time is much closer to L1 access time (1 cycle) than main memory (100 cycles)!",
                "type": "definition",
                "section": "The Memory Hierarchy Concept",
                "subsection": "Hierarchy Example"
              }
            ]
          }
        ]
      },
      {
        "section": "Locality of Reference",
        "subsections": [
          {
            "subsection": "What is Locality?",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-Locality-of-Reference-What-is-Locality--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "During program execution, memory references tend to **cluster**.",
                "type": "definition",
                "section": "Locality of Reference",
                "subsection": "What is Locality?"
              },
              {
                "id": "4-Locality-of-Reference-What-is-Locality--Observation",
                "title": "Observation",
                "front": "Observation",
                "back": "Programs access a **small proportion** of their address space at any given time.",
                "type": "definition",
                "section": "Locality of Reference",
                "subsection": "What is Locality?"
              }
            ]
          },
          {
            "subsection": "Two Types of Locality",
            "cardCount": 10,
            "cards": [
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-1--Temporal-Locality",
                "title": "1. Temporal Locality",
                "front": "1. Temporal Locality",
                "back": "",
                "type": "concept",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              },
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Items accessed **recently** are likely to be accessed again **soon**.",
                "type": "definition",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              },
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "If an item is referenced, it will tend to be referenced again soon.",
                "type": "definition",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              },
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **Loop instructions:** Same instructions executed repeatedly\n2. **Reused variables:** Variables accessed multiple times\n3. **Function calls:** Same functions called repeatedly",
                "type": "list",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              },
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-Example",
                "title": "Example",
                "front": "Example",
                "back": "for (i = 0; i < 1000; i++) { sum = sum + array[i]; // 'sum' accessed every iteration",
                "type": "definition",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              },
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-2--Spatial-Locality",
                "title": "2. Spatial Locality",
                "front": "2. Spatial Locality",
                "back": "",
                "type": "concept",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              },
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Items **near** those accessed recently are likely to be accessed soon.",
                "type": "definition",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              },
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "If an item is referenced, items whose addresses are close by will tend to be referenced soon.",
                "type": "definition",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              },
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **Sequential instruction access:** Instructions stored sequentially\n2. **Array data:** Array elements stored contiguously\n3. **Stack operations:** Stack grows/shrinks sequentially",
                "type": "list",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              },
              {
                "id": "4-Locality-of-Reference-Two-Types-of-Locality-Example",
                "title": "Example",
                "front": "Example",
                "back": "for (i = 0; i < 1000; i++) { sum = sum + array[i]; // array[i], array[i+1], array[i+2] accessed sequentially",
                "type": "definition",
                "section": "Locality of Reference",
                "subsection": "Two Types of Locality"
              }
            ]
          },
          {
            "subsection": "Exploiting Locality",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-Locality-of-Reference-Exploiting-Locality-Memory-Hierarchy-Strategy",
                "title": "Memory Hierarchy Strategy",
                "front": "Memory Hierarchy Strategy",
                "back": "1. **Store everything on disk** (cheap, large, slow)\n2. **Copy recently accessed items to main memory:**\n3. Exploits temporal locality (recent items likely needed again)\n4. Main memory faster than disk\n5. **Copy more recently accessed items to cache:**\n6. Exploits temporal locality further\n7. Cache faster than main memory\n8. **Copy nearby items when accessing:**\n9. Exploits spatial locality\n10. When accessing one word, bring in entire block\n11. Adjacent words likely to be accessed soon",
                "type": "list",
                "section": "Locality of Reference",
                "subsection": "Exploiting Locality"
              },
              {
                "id": "4-Locality-of-Reference-Exploiting-Locality-Result",
                "title": "Result",
                "front": "Result",
                "back": "Most accesses satisfied by fast memory (cache), few require slow memory (disk).",
                "type": "definition",
                "section": "Locality of Reference",
                "subsection": "Exploiting Locality"
              }
            ]
          }
        ]
      },
      {
        "section": "Cache Memory Fundamentals",
        "subsections": [
          {
            "subsection": "What is Cache?",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Cache-Memory-Fundamentals-What-is-Cache--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "A small amount of fast memory located between the processor and main memory.",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "What is Cache?"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-What-is-Cache--Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "1. Store recently accessed data and instructions\n2. Reduce average memory access time\n3. Bridge the speed gap between CPU and main memory",
                "type": "list",
                "section": "Cache Memory Fundamentals",
                "subsection": "What is Cache?"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-What-is-Cache--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Small:** Typically KB to MB\n2. **Fast:** 1-10 cycles access time\n3. **Expensive:** High cost per bit\n4. **On-chip:** Often located on CPU chip",
                "type": "list",
                "section": "Cache Memory Fundamentals",
                "subsection": "What is Cache?"
              }
            ]
          },
          {
            "subsection": "Cache Operation Overview",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-Cache-Memory-Fundamentals-Cache-Operation-Overview-Read-Operation-",
                "title": "Read Operation:",
                "front": "Read Operation:",
                "back": "1. **CPU requests** contents of memory location\n2. **Check cache** for data\n3. **If present (Hit):**\n4. Get data from cache (fast)\n5. Deliver to CPU\n6. **If not present (Miss):**\n7. Read required **block** from main memory\n8. Load block into cache\n9. Deliver requested word to CPU",
                "type": "list",
                "section": "Cache Memory Fundamentals",
                "subsection": "Cache Operation Overview"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Cache-Operation-Overview-Write-Operation-",
                "title": "Write Operation:",
                "front": "Write Operation:",
                "back": "1. **CPU writes** data to memory location\n2. **Check cache** for location\n3. **If present (Hit):**\n4. Update cache\n5. May update main memory (depending on write policy)\n6. **If not present (Miss):**\n7. Load block into cache\n8. Update cache\n9. May update main memory",
                "type": "list",
                "section": "Cache Memory Fundamentals",
                "subsection": "Cache Operation Overview"
              }
            ]
          },
          {
            "subsection": "Key Definitions",
            "cardCount": 15,
            "cards": [
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Block--Line-",
                "title": "Block (Line)",
                "front": "Block (Line)",
                "back": "",
                "type": "concept",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Unit of data transfer between cache and main memory.",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. May be multiple words\n2. Typically 16-128 bytes\n3. When one word is accessed, entire block is brought into cache\n4. Exploits spatial locality\n5. Reduces number of memory accesses\n6. More efficient than word-by-word transfer",
                "type": "list",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Hit",
                "title": "Hit",
                "front": "Hit",
                "back": "",
                "type": "concept",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Access satisfied by upper level (cache).",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Hit-Ratio",
                "title": "Hit Ratio",
                "front": "Hit Ratio",
                "back": "`hits / total_accesses`",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. 1000 memory accesses\n2. 950 satisfied by cache\n3. Hit ratio = 950/1000 = 0.95 = 95%",
                "type": "list",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Miss",
                "title": "Miss",
                "front": "Miss",
                "back": "",
                "type": "concept",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Block not present in cache, must be copied from lower level (main memory).",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Miss-Ratio",
                "title": "Miss Ratio",
                "front": "Miss Ratio",
                "back": "`misses / total_accesses = 1 - hit_ratio`",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. Hit ratio = 95%\n2. Miss ratio = 5%",
                "type": "list",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Miss-Penalty",
                "title": "Miss Penalty",
                "front": "Miss Penalty",
                "back": "",
                "type": "concept",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Time taken to handle a miss.",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Components",
                "title": "Components",
                "front": "Components",
                "back": "1. Time to access main memory\n2. Time to transfer block to cache\n3. Time to deliver data to CPU",
                "type": "list",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Typical",
                "title": "Typical",
                "front": "Typical",
                "back": "10-100+ cycles",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "Key Definitions"
              }
            ]
          },
          {
            "subsection": "Cache Organization",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Cache-Memory-Fundamentals-Cache-Organization-Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "Cache Line: ┌──────┬──────┬──────────┐ │ Valid│ Tag │ Data │ │ Bit │ │ (Block) │ └──────┴──────┴──────────┘",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "Cache Organization"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Cache-Organization-Components",
                "title": "Components",
                "front": "Components",
                "back": "1. **Valid Bit:** Indicates if line contains valid data\n2. **Tag:** Identifies which memory block is stored\n3. **Data:** The actual data block",
                "type": "list",
                "section": "Cache Memory Fundamentals",
                "subsection": "Cache Organization"
              },
              {
                "id": "4-Cache-Memory-Fundamentals-Cache-Organization-Example",
                "title": "Example",
                "front": "Example",
                "back": "Line 0: [V=1] [Tag=0x1234] [Data: word0, word1, word2, word3] Line 1: [V=0] [Tag=----] [Data: ----] Line 2: [V=1] [Tag=0x5678] [Data: word0, word1, word2, word3]",
                "type": "definition",
                "section": "Cache Memory Fundamentals",
                "subsection": "Cache Organization"
              }
            ]
          }
        ]
      },
      {
        "section": "Cache Mapping Techniques",
        "subsections": [
          {
            "subsection": "The Mapping Problem",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Cache-Mapping-Techniques-The-Mapping-Problem-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "There are fewer cache lines than main memory blocks.",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "The Mapping Problem"
              },
              {
                "id": "4-Cache-Mapping-Techniques-The-Mapping-Problem-Question",
                "title": "Question",
                "front": "Question",
                "back": "How do we map main memory blocks to cache lines?",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "The Mapping Problem"
              },
              {
                "id": "4-Cache-Mapping-Techniques-The-Mapping-Problem-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. Main memory: 1 million blocks\n2. Cache: 1,000 lines\n3. Each block must map to one or more possible cache lines",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "The Mapping Problem"
              }
            ]
          },
          {
            "subsection": "Three Mapping Techniques",
            "cardCount": 30,
            "cards": [
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-1--Direct-Mapping",
                "title": "1. Direct Mapping",
                "front": "1. Direct Mapping",
                "back": "",
                "type": "concept",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Each block of main memory maps to **exactly one** cache line.",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Mapping-Formula",
                "title": "Mapping Formula",
                "front": "Mapping Formula",
                "back": "1. `i` = cache line number\n2. `j` = main memory block number\n3. `m` = number of lines in cache",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Address-Structure",
                "title": "Address Structure",
                "front": "Address Structure",
                "back": "┌──────────┬──────┬──────┐ │ Tag │ Line │ Word │ │ (s-r bits)│(r bits)│(w bits)│ └──────────┴──────┴──────┘",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Fields",
                "title": "Fields",
                "front": "Fields",
                "back": "1. **Tag:** High-order bits identifying which block\n2. **Line:** Cache line number (low-order bits of block address)\n3. **Word:** Word offset within block",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. Cache: 8 lines (3 bits for line number)\n2. Block size: 1 word (0 bits for word offset)\n3. Address: 22 (binary: 10110)",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Breaking-down-address-22",
                "title": "Breaking down address 22",
                "front": "Breaking down address 22",
                "back": "Binary: 1 0 1 1 0 │ │ └─► Line = 110 (binary) = 6 └─┴──────► Tag = 10 (binary) = 2",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "1. Extract line number from address\n2. Check if valid bit is set\n3. Compare tag in cache with tag from address\n4. If match: **Hit** (data in cache)\n5. If no match: **Miss** (load block from memory)",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Simple:** Easy to implement\n2. **Fast:** Direct lookup (no search needed)\n3. **Inexpensive:** Minimal hardware",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Fixed location:** Any given block can only be in one specific line\n2. **Thrashing:** If program accesses blocks that map to same line repeatedly, constant misses\n3. **Low flexibility:** No choice in placement",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Thrashing-Example",
                "title": "Thrashing Example",
                "front": "Thrashing Example",
                "back": "Blocks 0, 8, 16, 24 all map to line 0 (0 mod 8 = 0, 8 mod 8 = 0, etc.) Accessing: 0, 8, 0, 8, 0, 8... Result: Constant misses (each access evicts previous block)",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-2--Fully-Associative-Mapping",
                "title": "2. Fully Associative Mapping",
                "front": "2. Fully Associative Mapping",
                "back": "",
                "type": "concept",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "A main memory block can load into **any line** of cache.",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Address-Structure",
                "title": "Address Structure",
                "front": "Address Structure",
                "back": "┌──────────┬──────┐ │ Tag │ Word │ │ (s bits) │(w bits)│ └──────────┴──────┘",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Fields",
                "title": "Fields",
                "front": "Fields",
                "back": "1. **Tag:** Full block address (no line field needed)\n2. **Word:** Word offset within block",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "1. Extract tag from address\n2. **Search all cache lines** for matching tag\n3. If found: **Hit**\n4. If not found: **Miss** (load into any available line)",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Maximum flexibility:** Block can be placed anywhere\n2. **No thrashing:** No conflicts between blocks\n3. **Best hit ratio:** Optimal placement possible",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Expensive:** Requires comparators for all lines\n2. **Slow:** Must search all lines (parallel search needed for speed)\n3. **Complex:** More hardware complexity",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Hardware-Requirements",
                "title": "Hardware Requirements",
                "front": "Hardware Requirements",
                "back": "1. N comparators (one per cache line)\n2. Parallel tag comparison\n3. More expensive as cache size increases",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-3--Set-Associative-Mapping",
                "title": "3. Set-Associative Mapping",
                "front": "3. Set-Associative Mapping",
                "back": "",
                "type": "concept",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Compromise between direct and fully associative.",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Organization",
                "title": "Organization",
                "front": "Organization",
                "back": "1. Cache divided into **sets**\n2. Each set contains **k lines** (k-way set associative)\n3. Block maps to **one specific set**, but can be placed in **any line within that set**",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Mapping",
                "title": "Mapping",
                "front": "Mapping",
                "back": "1. Set number: `(Block number) mod (Number of sets)`\n2. Within set: Any of k lines",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Address-Structure",
                "title": "Address Structure",
                "front": "Address Structure",
                "back": "┌──────────┬──────┬──────┐ │ Tag │ Set │ Word │ │(s-d bits)│(d bits)│(w bits)│ └──────────┴──────┴──────┘",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Fields",
                "title": "Fields",
                "front": "Fields",
                "back": "1. **Tag:** Identifies block within set\n2. **Set:** Set number (determines which set)\n3. **Word:** Word offset within block",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Example---2-Way-Set-Associative",
                "title": "Example - 2-Way Set Associative",
                "front": "Example - 2-Way Set Associative",
                "back": "1. Cache: 8 lines total\n2. Sets: 4 sets (2 lines per set)\n3. Block 12: 12 mod 4 = 0 → Set 0, can be in either line of Set 0",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "1. Extract set number from address\n2. Search **only lines in that set** for matching tag\n3. If found: **Hit**\n4. If not found: **Miss** (load into any available line in set)",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Good flexibility:** Multiple choices per block\n2. **Reasonable cost:** Only k comparators needed (not all lines)\n3. **Better than direct:** Reduces thrashing\n4. **Better than fully associative:** Lower cost, faster",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **More complex than direct:** Requires set selection and search\n2. **More expensive than direct:** Needs k comparators\n3. **Less flexible than fully associative:** Limited to k choices",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Common-Configurations",
                "title": "Common Configurations",
                "front": "Common Configurations",
                "back": "1. **2-way:** 2 lines per set (common, good balance)\n2. **4-way:** 4 lines per set (very common)\n3. **8-way:** 8 lines per set (high-end processors)",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Three Mapping Techniques"
              }
            ]
          },
          {
            "subsection": "Comparison of Mapping Techniques",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-Cache-Mapping-Techniques-Comparison-of-Mapping-Techniques-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "Most processors use **set-associative** (typically 2-8 way) for good balance.",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Comparison of Mapping Techniques"
              }
            ]
          },
          {
            "subsection": "Associativity Spectrum",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-Cache-Mapping-Techniques-Associativity-Spectrum-For-a-cache-with-8-entries",
                "title": "For a cache with 8 entries",
                "front": "For a cache with 8 entries",
                "back": "1. **Direct (1-way):** 8 sets, 1 line per set\n2. **2-way:** 4 sets, 2 lines per set\n3. **4-way:** 2 sets, 4 lines per set\n4. **8-way (Fully Associative):** 1 set, 8 lines per set",
                "type": "list",
                "section": "Cache Mapping Techniques",
                "subsection": "Associativity Spectrum"
              },
              {
                "id": "4-Cache-Mapping-Techniques-Associativity-Spectrum-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "Direct mapping and fully associative are special cases of set-associative!",
                "type": "definition",
                "section": "Cache Mapping Techniques",
                "subsection": "Associativity Spectrum"
              }
            ]
          }
        ]
      },
      {
        "section": "Cache Replacement Policies",
        "subsections": [
          {
            "subsection": "When Replacement is Needed",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Cache-Replacement-Policies-When-Replacement-is-Needed-Situation",
                "title": "Situation",
                "front": "Situation",
                "back": "Cache is full, new block must be loaded.",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "When Replacement is Needed"
              },
              {
                "id": "4-Cache-Replacement-Policies-When-Replacement-is-Needed-Direct-Mapping",
                "title": "Direct Mapping",
                "front": "Direct Mapping",
                "back": "1. **No choice:** Only one possible line\n2. Replacement is automatic",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "When Replacement is Needed"
              },
              {
                "id": "4-Cache-Replacement-Policies-When-Replacement-is-Needed-Associative-Set-Associative",
                "title": "Associative/Set-Associative",
                "front": "Associative/Set-Associative",
                "back": "1. **Choice available:** Which line to replace?\n2. Need **replacement algorithm**",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "When Replacement is Needed"
              }
            ]
          },
          {
            "subsection": "Replacement Algorithms",
            "cardCount": 24,
            "cards": [
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-1--Least-Recently-Used--LRU-",
                "title": "1. Least Recently Used (LRU)",
                "front": "1. Least Recently Used (LRU)",
                "back": "",
                "type": "concept",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Replace the block that has been in cache **longest without reference**.",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Implementation",
                "title": "Implementation",
                "front": "Implementation",
                "back": "1. Track access order for each set\n2. Replace least recently accessed block",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Most effective:** Exploits temporal locality\n2. **Good hit ratio:** Keeps recently used blocks",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Complexity:** Requires tracking access history\n2. **Hardware cost:** Counters or state machines needed",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Example",
                "title": "Example",
                "front": "Example",
                "back": "Set with blocks: A, B, C Access order: A, B, A, C, B Next miss: Replace C (least recently used)",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-2--First-In-First-Out--FIFO-",
                "title": "2. First-In-First-Out (FIFO)",
                "front": "2. First-In-First-Out (FIFO)",
                "back": "",
                "type": "concept",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Replace the block that has been in cache **longest** (regardless of recent use).",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Implementation",
                "title": "Implementation",
                "front": "Implementation",
                "back": "1. Round-robin or circular buffer\n2. Replace oldest block",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Simple:** Easy to implement\n2. **Low cost:** Minimal hardware",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Less effective:** Doesn't consider recent usage\n2. **May evict frequently used blocks**",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Example",
                "title": "Example",
                "front": "Example",
                "back": "Blocks loaded: A, B, C (in that order) Next miss: Replace A (first in)",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-3--Least-Frequently-Used--LFU-",
                "title": "3. Least Frequently Used (LFU)",
                "front": "3. Least Frequently Used (LFU)",
                "back": "",
                "type": "concept",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Replace the block with **fewest references**.",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Implementation",
                "title": "Implementation",
                "front": "Implementation",
                "back": "1. Counter for each block\n2. Increment on access\n3. Replace block with lowest count",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Considers usage frequency:** Keeps frequently used blocks",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Complexity:** Counters needed\n2. **May keep old blocks:** Blocks accessed many times long ago",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Example",
                "title": "Example",
                "front": "Example",
                "back": "Block A: 10 accesses Block B: 5 accesses Block C: 2 accesses Next miss: Replace C (least frequently used)",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-4--Random",
                "title": "4. Random",
                "front": "4. Random",
                "back": "",
                "type": "concept",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Replace a **randomly selected** block.",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Implementation",
                "title": "Implementation",
                "front": "Implementation",
                "back": "1. Random number generator\n2. Select random line in set",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Very simple:** Minimal hardware\n2. **No tracking needed**",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Poor performance:** No locality consideration\n2. **Unpredictable:** May evict important blocks",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              },
              {
                "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Use",
                "title": "Use",
                "front": "Use",
                "back": "Rarely used, mainly for comparison",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "Replacement Algorithms"
              }
            ]
          },
          {
            "subsection": "Algorithm Comparison",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Cache-Replacement-Policies-Algorithm-Comparison-Effectiveness--Best-to-Worst-",
                "title": "Effectiveness (Best to Worst)",
                "front": "Effectiveness (Best to Worst)",
                "back": "1. LRU (most effective)\n2. LFU\n3. FIFO\n4. Random (least effective)",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Algorithm Comparison"
              },
              {
                "id": "4-Cache-Replacement-Policies-Algorithm-Comparison-Complexity--Simplest-to-Most-Complex-",
                "title": "Complexity (Simplest to Most Complex)",
                "front": "Complexity (Simplest to Most Complex)",
                "back": "1. Random (simplest)\n2. FIFO\n3. LRU\n4. LFU (most complex)",
                "type": "list",
                "section": "Cache Replacement Policies",
                "subsection": "Algorithm Comparison"
              },
              {
                "id": "4-Cache-Replacement-Policies-Algorithm-Comparison-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "**LRU** is most popular due to good effectiveness and reasonable implementation cost.",
                "type": "definition",
                "section": "Cache Replacement Policies",
                "subsection": "Algorithm Comparison"
              }
            ]
          }
        ]
      },
      {
        "section": "Write Policies",
        "subsections": [
          {
            "subsection": "The Write Problem",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-Write-Policies-The-Write-Problem-Issue",
                "title": "Issue",
                "front": "Issue",
                "back": "When CPU writes to cache, main memory must eventually be updated.",
                "type": "definition",
                "section": "Write Policies",
                "subsection": "The Write Problem"
              },
              {
                "id": "4-Write-Policies-The-Write-Problem-Questions",
                "title": "Questions",
                "front": "Questions",
                "back": "1. When should main memory be updated?\n2. What if cache block is replaced before being written to memory?\n3. What if multiple devices access main memory?",
                "type": "list",
                "section": "Write Policies",
                "subsection": "The Write Problem"
              }
            ]
          },
          {
            "subsection": "Two Write Policies",
            "cardCount": 13,
            "cards": [
              {
                "id": "4-Write-Policies-Two-Write-Policies-1--Write-Through",
                "title": "1. Write Through",
                "front": "1. Write Through",
                "back": "",
                "type": "concept",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Every write to cache **also writes to main memory** immediately.",
                "type": "definition",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "CPU Write → Update Cache → Update Main Memory (simultaneously)",
                "type": "definition",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Simple:** Straightforward implementation\n2. **Consistency:** Cache and memory always consistent\n3. **I/O compatibility:** I/O devices can read directly from memory",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **High memory traffic:** Every write goes to memory\n2. **Slow writes:** Memory access is slow\n3. **Bottleneck:** Memory bus becomes bottleneck",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Performance-Impact",
                "title": "Performance Impact",
                "front": "Performance Impact",
                "back": "1. Hold data waiting to be written\n2. CPU continues immediately\n3. Only stalls if buffer is full\n4. Reduces performance penalty",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-2--Write-Back",
                "title": "2. Write Back",
                "front": "2. Write Back",
                "back": "",
                "type": "concept",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Write only to cache initially. Write to memory only when block is replaced.",
                "type": "definition",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "CPU Write → Update Cache (only) When block replaced → Write to memory (if dirty)",
                "type": "definition",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Dirty-Bit",
                "title": "Dirty Bit",
                "front": "Dirty Bit",
                "back": "1. Indicates if block has been modified\n2. Set when block is written\n3. Checked when block is replaced\n4. If dirty: Write to memory before replacement",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Minimizes memory writes:** Only dirty blocks written\n2. **Faster writes:** No memory access during write\n3. **Better performance:** Lower memory traffic",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Complexity:** Need dirty bit tracking\n2. **Inconsistency:** Cache and memory may differ\n3. **I/O issues:** I/O must go through cache or use cache coherency",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              },
              {
                "id": "4-Write-Policies-Two-Write-Policies-Performance-Impact",
                "title": "Performance Impact",
                "front": "Performance Impact",
                "back": "Base CPI = 1 10% of instructions are stores Only 20% of replaced blocks are dirty Memory write takes 100 cycles Miss rate = 2% Effective CPI = 1 + 0.02 × 0.2 × 100 = 1.4 (Much better than write through!)",
                "type": "definition",
                "section": "Write Policies",
                "subsection": "Two Write Policies"
              }
            ]
          },
          {
            "subsection": "Write Allocation",
            "cardCount": 4,
            "cards": [
              {
                "id": "4-Write-Policies-Write-Allocation-Question",
                "title": "Question",
                "front": "Question",
                "back": "On write miss, should we load block into cache?",
                "type": "definition",
                "section": "Write Policies",
                "subsection": "Write Allocation"
              },
              {
                "id": "4-Write-Policies-Write-Allocation-Write-Allocate--Fetch-on-Write-Miss-",
                "title": "Write Allocate (Fetch on Write Miss)",
                "front": "Write Allocate (Fetch on Write Miss)",
                "back": "1. Load block into cache\n2. Update cache\n3. Use with write back",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Write Allocation"
              },
              {
                "id": "4-Write-Policies-Write-Allocation-No-Write-Allocate--Write-Around-",
                "title": "No Write Allocate (Write Around)",
                "front": "No Write Allocate (Write Around)",
                "back": "1. Write directly to memory\n2. Don't load into cache\n3. Use with write through",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Write Allocation"
              },
              {
                "id": "4-Write-Policies-Write-Allocation-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "1. **Write back + Write allocate:** Most common\n2. **Write through + No write allocate:** Less common",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Write Allocation"
              }
            ]
          },
          {
            "subsection": "Cache Coherency",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Write-Policies-Cache-Coherency-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "Multiple devices may access same memory.",
                "type": "definition",
                "section": "Write Policies",
                "subsection": "Cache Coherency"
              },
              {
                "id": "4-Write-Policies-Cache-Coherency-Scenarios",
                "title": "Scenarios",
                "front": "Scenarios",
                "back": "1. **I/O and CPU:** I/O writes to memory, cache has stale data\n2. **Multiple CPUs:** Each has own cache, one CPU writes, others have stale data",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Cache Coherency"
              },
              {
                "id": "4-Write-Policies-Cache-Coherency-Solutions",
                "title": "Solutions",
                "front": "Solutions",
                "back": "1. **Snooping:** Caches monitor bus for writes\n2. **Invalidation:** Mark cache lines as invalid when written by others\n3. **Update:** Update cache lines when written by others\n4. **Cache coherency protocols:** MESI (Modified, Exclusive, Shared, Invalid)",
                "type": "list",
                "section": "Write Policies",
                "subsection": "Cache Coherency"
              }
            ]
          }
        ]
      },
      {
        "section": "Cache Performance Analysis",
        "subsections": [
          {
            "subsection": "Performance Metrics",
            "cardCount": 15,
            "cards": [
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Average-Memory-Access-Time--AMAT-",
                "title": "Average Memory Access Time (AMAT)",
                "front": "Average Memory Access Time (AMAT)",
                "back": "",
                "type": "concept",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Formula",
                "title": "Formula",
                "front": "Formula",
                "back": "AMAT = Hit Time + (Miss Rate × Miss Penalty)",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Components",
                "title": "Components",
                "front": "Components",
                "back": "1. **Hit Time:** Time to access cache (typically 1-10 cycles)\n2. **Miss Rate:** Fraction of accesses that miss (0.0 to 1.0)\n3. **Miss Penalty:** Time to handle miss (typically 10-100+ cycles)",
                "type": "list",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Example",
                "title": "Example",
                "front": "Example",
                "back": "Hit time = 1 cycle Miss rate = 5% = 0.05 Miss penalty = 100 cycles AMAT = 1 + 0.05 × 100 = 1 + 5 = 6 cycles",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "Even with 5% miss rate, average access time is 6x hit time!",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-CPU-Time",
                "title": "CPU Time",
                "front": "CPU Time",
                "back": "",
                "type": "concept",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Formula",
                "title": "Formula",
                "front": "Formula",
                "back": "CPU Time = (CPU execution cycles + Memory stall cycles) × Clock cycle time",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Memory-Stall-Cycles",
                "title": "Memory Stall Cycles",
                "front": "Memory Stall Cycles",
                "back": "Memory stall cycles = (Instruction miss cycles) + (Data miss cycles)",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Instruction-Miss-Cycles",
                "title": "Instruction Miss Cycles",
                "front": "Instruction Miss Cycles",
                "back": "Instruction miss cycles = (Instructions) × (I-cache miss rate) × (Miss penalty)",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Data-Miss-Cycles",
                "title": "Data Miss Cycles",
                "front": "Data Miss Cycles",
                "back": "Data miss cycles = (Instructions) × (Load/store fraction) × (D-cache miss rate) × (Miss penalty)",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Effective-CPI",
                "title": "Effective CPI",
                "front": "Effective CPI",
                "back": "",
                "type": "concept",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Formula",
                "title": "Formula",
                "front": "Formula",
                "back": "CPI_actual = CPI_base + (Memory stall cycles per instruction)",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Memory-Stall-Cycles-per-Instruction",
                "title": "Memory Stall Cycles per Instruction",
                "front": "Memory Stall Cycles per Instruction",
                "back": "Stall cycles = (I-cache miss rate × Miss penalty) + (Load/store fraction × D-cache miss rate × Miss penalty)",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Example",
                "title": "Example",
                "front": "Example",
                "back": "Base CPI = 3 I-cache miss rate = 4% = 0.04 D-cache miss rate = 8% = 0.08 Load/store fraction = 60% = 0.6 Miss penalty = 125 cycles CPI_actual = 3 + (0.04 × 125) + (0.6 × 0.08 × 125) = 3 + 5 + 6 = 14 cycles",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              },
              {
                "id": "4-Cache-Performance-Analysis-Performance-Metrics-Performance-Impact",
                "title": "Performance Impact",
                "front": "Performance Impact",
                "back": "Cache misses increase CPI from 3 to 14 (4.7x slower)!",
                "type": "definition",
                "section": "Cache Performance Analysis",
                "subsection": "Performance Metrics"
              }
            ]
          },
          {
            "subsection": "Improving Cache Performance",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-Cache-Performance-Analysis-Improving-Cache-Performance-Strategies",
                "title": "Strategies",
                "front": "Strategies",
                "back": "1. **Reduce Miss Rate:**\n2. Larger cache\n3. Higher associativity\n4. Better replacement algorithm\n5. Larger block size (up to a point)\n6. **Reduce Miss Penalty:**\n7. Faster main memory\n8. Multi-level caches\n9. Write buffers\n10. **Reduce Hit Time:**\n11. Smaller cache\n12. Lower associativity\n13. On-chip cache",
                "type": "list",
                "section": "Cache Performance Analysis",
                "subsection": "Improving Cache Performance"
              },
              {
                "id": "4-Cache-Performance-Analysis-Improving-Cache-Performance-Trade-offs",
                "title": "Trade-offs",
                "front": "Trade-offs",
                "back": "1. Larger cache → Lower miss rate, but higher hit time\n2. Higher associativity → Lower miss rate, but higher hit time\n3. Larger blocks → Better spatial locality, but fewer blocks fit",
                "type": "list",
                "section": "Cache Performance Analysis",
                "subsection": "Improving Cache Performance"
              }
            ]
          }
        ]
      },
      {
        "section": "Multi-Level Caches",
        "subsections": [
          {
            "subsection": "Why Multiple Levels?",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-Multi-Level-Caches-Why-Multiple-Levels--Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "1. **Size:** Large enough for good hit rate\n2. **Speed:** Small enough for fast access",
                "type": "list",
                "section": "Multi-Level Caches",
                "subsection": "Why Multiple Levels?"
              },
              {
                "id": "4-Multi-Level-Caches-Why-Multiple-Levels--Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Use **multiple cache levels** with different characteristics.",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Why Multiple Levels?"
              }
            ]
          },
          {
            "subsection": "Two-Level Cache Organization",
            "cardCount": 4,
            "cards": [
              {
                "id": "4-Multi-Level-Caches-Two-Level-Cache-Organization-L1-Cache--Level-1-",
                "title": "L1 Cache (Level 1)",
                "front": "L1 Cache (Level 1)",
                "back": "1. **Location:** On CPU chip\n2. **Size:** Small (8-64 KB)\n3. **Speed:** Very fast (1-2 cycles)\n4. **Characteristics:**\n5. Split instruction and data caches\n6. Very close to processor\n7. Fastest access",
                "type": "list",
                "section": "Multi-Level Caches",
                "subsection": "Two-Level Cache Organization"
              },
              {
                "id": "4-Multi-Level-Caches-Two-Level-Cache-Organization-L2-Cache--Level-2-",
                "title": "L2 Cache (Level 2)",
                "front": "L2 Cache (Level 2)",
                "back": "1. **Location:** On CPU chip or off-chip\n2. **Size:** Medium (256 KB - 8 MB)\n3. **Speed:** Fast (5-20 cycles)\n4. **Characteristics:**\n5. Services misses from L1\n6. Larger than L1\n7. Slower than L1, but faster than main memory",
                "type": "list",
                "section": "Multi-Level Caches",
                "subsection": "Two-Level Cache Organization"
              },
              {
                "id": "4-Multi-Level-Caches-Two-Level-Cache-Organization-L3-Cache--Level-3-",
                "title": "L3 Cache (Level 3)",
                "front": "L3 Cache (Level 3)",
                "back": "1. **Location:** On CPU chip or off-chip\n2. **Size:** Large (8-64 MB)\n3. **Speed:** Moderate (20-50 cycles)\n4. **Characteristics:**\n5. Services misses from L2\n6. Shared among multiple cores\n7. Larger than L2",
                "type": "list",
                "section": "Multi-Level Caches",
                "subsection": "Two-Level Cache Organization"
              },
              {
                "id": "4-Multi-Level-Caches-Two-Level-Cache-Organization-Main-Memory",
                "title": "Main Memory",
                "front": "Main Memory",
                "back": "1. **Location:** Off-chip\n2. **Size:** Very large (GB)\n3. **Speed:** Slow (50-100+ cycles)\n4. **Characteristics:**\n5. Services misses from L3\n6. Largest capacity\n7. Slowest access",
                "type": "list",
                "section": "Multi-Level Caches",
                "subsection": "Two-Level Cache Organization"
              }
            ]
          },
          {
            "subsection": "Multi-Level Cache Operation",
            "cardCount": 5,
            "cards": [
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Access-Flow",
                "title": "Access Flow",
                "front": "Access Flow",
                "back": "CPU Request Check L1 Cache Check L2 Cache Check L3 Cache Access Main Memory",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Cache Operation"
              },
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Hit-at-L1",
                "title": "Hit at L1",
                "front": "Hit at L1",
                "back": "Fastest (1-2 cycles)",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Cache Operation"
              },
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Hit-at-L2",
                "title": "Hit at L2",
                "front": "Hit at L2",
                "back": "Fast (5-20 cycles)",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Cache Operation"
              },
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Hit-at-L3",
                "title": "Hit at L3",
                "front": "Hit at L3",
                "back": "Moderate (20-50 cycles)",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Cache Operation"
              },
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Miss--Main-Memory-",
                "title": "Miss (Main Memory)",
                "front": "Miss (Main Memory)",
                "back": "Slow (50-100+ cycles)",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Cache Operation"
              }
            ]
          },
          {
            "subsection": "Multi-Level Performance",
            "cardCount": 5,
            "cards": [
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Performance-Example-Calculation",
                "title": "Example Calculation",
                "front": "Example Calculation",
                "back": "",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Performance"
              },
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Performance-Given",
                "title": "Given",
                "front": "Given",
                "back": "1. Base CPI = 1\n2. Clock rate = 4 GHz (0.25 ns per cycle)\n3. L1 miss rate = 2%\n4. L2 access time = 5 ns\n5. L2 global miss rate = 0.5%\n6. Main memory access time = 100 ns",
                "type": "list",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Performance"
              },
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Performance-Without-L2",
                "title": "Without L2",
                "front": "Without L2",
                "back": "Miss penalty = 100 ns / 0.25 ns = 400 cycles CPI = 1 + 0.02 × 400 = 9",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Performance"
              },
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Performance-With-L2",
                "title": "With L2",
                "front": "With L2",
                "back": "L1 miss, L2 hit penalty = 5 ns / 0.25 ns = 20 cycles L1 miss, L2 miss penalty = 100 ns / 0.25 ns = 400 cycles CPI = 1 + 0.02 × 20 + 0.005 × 400 = 1 + 0.4 + 2",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Performance"
              },
              {
                "id": "4-Multi-Level-Caches-Multi-Level-Performance-Performance-Improvement",
                "title": "Performance Improvement",
                "front": "Performance Improvement",
                "back": "9/3.4 = 2.6x faster!",
                "type": "definition",
                "section": "Multi-Level Caches",
                "subsection": "Multi-Level Performance"
              }
            ]
          },
          {
            "subsection": "Unified vs. Split Caches",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Multi-Level-Caches-Unified-vs--Split-Caches-Unified-Cache",
                "title": "Unified Cache",
                "front": "Unified Cache",
                "back": "1. Single cache for both instructions and data\n2. **Advantages:**\n3. Higher hit rate (balances load automatically)\n4. Simpler design\n5. **Disadvantages:**\n6. Contention between instruction fetch and data access\n7. Problematic for pipelining",
                "type": "list",
                "section": "Multi-Level Caches",
                "subsection": "Unified vs. Split Caches"
              },
              {
                "id": "4-Multi-Level-Caches-Unified-vs--Split-Caches-Split-Cache",
                "title": "Split Cache",
                "front": "Split Cache",
                "back": "1. Separate instruction cache (I-cache) and data cache (D-cache)\n2. **Advantages:**\n3. No contention\n4. Better for pipelining\n5. Can optimize each separately\n6. **Disadvantages:**\n7. Lower hit rate (fixed allocation)\n8. More complex",
                "type": "list",
                "section": "Multi-Level Caches",
                "subsection": "Unified vs. Split Caches"
              },
              {
                "id": "4-Multi-Level-Caches-Unified-vs--Split-Caches-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "1. **L1:** Split (I-cache and D-cache)\n2. **L2/L3:** Unified (shared)",
                "type": "list",
                "section": "Multi-Level Caches",
                "subsection": "Unified vs. Split Caches"
              }
            ]
          }
        ]
      },
      {
        "section": "Internal Memory: DRAM and SRAM",
        "subsections": [
          {
            "subsection": "Semiconductor Memory Overview",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Semiconductor-Memory-Overview-Two-Main-Types",
                "title": "Two Main Types",
                "front": "Two Main Types",
                "back": "1. **RAM (Random Access Memory):**\n2. Read/Write\n3. Volatile\n4. Temporary storage\n5. Static (SRAM) or Dynamic (DRAM)\n6. **ROM (Read-Only Memory):**\n7. Read-only (mostly)\n8. Nonvolatile\n9. Permanent storage\n10. Various types (ROM, PROM, EPROM, EEPROM, Flash)",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Semiconductor Memory Overview"
              }
            ]
          },
          {
            "subsection": "Dynamic RAM (DRAM)",
            "cardCount": 10,
            "cards": [
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "",
                "type": "concept",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Basic-Cell",
                "title": "Basic Cell",
                "front": "Basic Cell",
                "back": "1. **Capacitor:** Stores charge (1) or no charge (0)\n2. **Transistor:** Switch to access capacitor",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "1. **Write:** Apply voltage to bit line, activate address line, charge/discharge capacitor\n2. **Read:** Activate address line, sense charge on capacitor, restore charge",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "",
                "type": "concept",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Storage-Mechanism",
                "title": "Storage Mechanism",
                "front": "Storage Mechanism",
                "back": "1. Bits stored as **charge in capacitors**\n2. Presence/absence of charge = binary 1/0\n3. **Essentially analogue:** Level of charge determines value",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Key-Properties",
                "title": "Key Properties",
                "front": "Key Properties",
                "back": "1. **Charges leak:** Capacitors lose charge over time\n2. **Needs refreshing:** Periodic refresh to maintain data\n3. **Dynamic:** Stored charge leaks away even with power",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Refresh-Requirements",
                "title": "Refresh Requirements",
                "front": "Refresh Requirements",
                "back": "1. Must refresh every few milliseconds (typically 64 ms)\n2. Refresh circuit included on chip\n3. Refresh process:\n4. Disable chip\n5. Count through rows\n6. Read and write back each row\n7. Takes time, slows performance",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Simpler construction:** Fewer transistors per cell\n2. **Smaller per bit:** Higher density\n3. **Less expensive:** Lower cost\n4. **High capacity:** Good for main memory",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Needs refresh circuits:** Additional complexity\n2. **Slower:** Refresh overhead\n3. **More complex timing:** Refresh cycles",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Use",
                "title": "Use",
                "front": "Use",
                "back": "**Main memory** (large capacity needed, cost-sensitive)",
                "type": "definition",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Dynamic RAM (DRAM)"
              }
            ]
          },
          {
            "subsection": "Static RAM (SRAM)",
            "cardCount": 9,
            "cards": [
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "",
                "type": "concept",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Static RAM (SRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Basic-Cell",
                "title": "Basic Cell",
                "front": "Basic Cell",
                "back": "1. **Flip-flop circuit:** Two cross-coupled inverters\n2. **Transistor arrangement:** Provides stable logic state\n3. **No capacitor:** State maintained by circuit",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Static RAM (SRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "1. **State 1:** C1 high, C2 low (T1, T4 off; T2, T3 on)\n2. **State 0:** C2 high, C1 low (T2, T3 off; T1, T4 on)\n3. **Write:** Apply value to bit lines\n4. **Read:** Sense value on bit line",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Static RAM (SRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "",
                "type": "concept",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Static RAM (SRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Storage-Mechanism",
                "title": "Storage Mechanism",
                "front": "Storage Mechanism",
                "back": "1. Bits stored as **on/off switches** (flip-flops)\n2. Digital: Clear 1 or 0 state\n3. **No charges to leak:** State maintained by circuit",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Static RAM (SRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Key-Properties",
                "title": "Key Properties",
                "front": "Key Properties",
                "back": "1. **No refresh needed:** Maintains state as long as powered\n2. **Faster:** No refresh overhead\n3. **More complex:** More transistors per cell",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Static RAM (SRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **No refresh needed:** Simpler operation\n2. **Faster:** Lower access time\n3. **Simpler timing:** No refresh cycles",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Static RAM (SRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **More complex construction:** More transistors\n2. **Larger per bit:** Lower density\n3. **More expensive:** Higher cost",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Static RAM (SRAM)"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Use",
                "title": "Use",
                "front": "Use",
                "back": "**Cache memory** (speed critical, smaller capacity)",
                "type": "definition",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "Static RAM (SRAM)"
              }
            ]
          },
          {
            "subsection": "SRAM vs. DRAM Comparison",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-SRAM-vs--DRAM-Comparison-Key-Insight",
                "title": "Key Insight",
                "front": "Key Insight",
                "back": "SRAM is faster but more expensive. DRAM is cheaper but slower. Use SRAM for small, fast cache; DRAM for large, cheap main memory.",
                "type": "definition",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "SRAM vs. DRAM Comparison"
              }
            ]
          },
          {
            "subsection": "DRAM Organization",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-DRAM-Organization-Internal-Structure",
                "title": "Internal Structure",
                "front": "Internal Structure",
                "back": "1. Organized as **2D array** of cells\n2. **Row and column addressing:**\n3. Reduces number of address pins\n4. Multiplex row and column addresses\n5. Example: 2048 × 2048 × 4 bits = 16 Mbit chip\n6. Only 11 address pins needed (2^11 = 2048)",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "DRAM Organization"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-DRAM-Organization-Module-Organization",
                "title": "Module Organization",
                "front": "Module Organization",
                "back": "1. Multiple chips combined to form memory module\n2. Example: 256 KB module = 8 chips × 32 Kbit each\n3. Example: 1 MB module = 8 chips × 1 Mbit each",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "DRAM Organization"
              },
              {
                "id": "4-Internal-Memory--DRAM-and-SRAM-DRAM-Organization-Interleaved-Memory",
                "title": "Interleaved Memory",
                "front": "Interleaved Memory",
                "back": "1. Multiple memory banks\n2. Each bank can service requests independently\n3. Consecutive words stored in different banks\n4. **K banks** can service **K requests** simultaneously\n5. Increases memory bandwidth",
                "type": "list",
                "section": "Internal Memory: DRAM and SRAM",
                "subsection": "DRAM Organization"
              }
            ]
          }
        ]
      },
      {
        "section": "Error Detection and Correction",
        "subsections": [
          {
            "subsection": "Why Error Correction?",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-Error-Detection-and-Correction-Why-Error-Correction--Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "Memory can have errors.",
                "type": "definition",
                "section": "Error Detection and Correction",
                "subsection": "Why Error Correction?"
              },
              {
                "id": "4-Error-Detection-and-Correction-Why-Error-Correction--Types-of-Errors",
                "title": "Types of Errors",
                "front": "Types of Errors",
                "back": "1. **Hard Failure:**\n2. Permanent defect\n3. Manufacturing defect\n4. Physical damage\n5. **Soft Error:**\n6. Random, non-destructive\n7. Caused by:\n8. Alpha particles\n9. Cosmic rays\n10. Electrical noise\n11. No permanent damage\n12. Data corruption",
                "type": "list",
                "section": "Error Detection and Correction",
                "subsection": "Why Error Correction?"
              }
            ]
          },
          {
            "subsection": "Hamming Error Correcting Code",
            "cardCount": 8,
            "cards": [
              {
                "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Detect and correct single-bit errors.",
                "type": "definition",
                "section": "Error Detection and Correction",
                "subsection": "Hamming Error Correcting Code"
              },
              {
                "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "1. Add **check bits** (redundancy) to data\n2. Check bits encode information about data bits\n3. Can detect and correct errors",
                "type": "list",
                "section": "Error Detection and Correction",
                "subsection": "Hamming Error Correcting Code"
              },
              {
                "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Hamming-Distance",
                "title": "Hamming Distance",
                "front": "Hamming Distance",
                "back": "1. Minimum number of bit positions in which two code words differ\n2. For single-bit error correction: Minimum distance = 3",
                "type": "list",
                "section": "Error Detection and Correction",
                "subsection": "Hamming Error Correcting Code"
              },
              {
                "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Implementation",
                "title": "Implementation",
                "front": "Implementation",
                "back": "1. Check bits placed at positions that are powers of 2 (1, 2, 4, 8, ...)\n2. Each check bit covers specific data bits\n3. Check bits calculated using XOR operations",
                "type": "list",
                "section": "Error Detection and Correction",
                "subsection": "Hamming Error Correcting Code"
              },
              {
                "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Example---8-bit-data",
                "title": "Example - 8-bit data",
                "front": "Example - 8-bit data",
                "back": "1. Need 4 check bits (positions 1, 2, 4, 8)\n2. Total: 12 bits (8 data + 4 check)",
                "type": "list",
                "section": "Error Detection and Correction",
                "subsection": "Hamming Error Correcting Code"
              },
              {
                "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Error-Detection",
                "title": "Error Detection",
                "front": "Error Detection",
                "back": "1. Recalculate check bits from data\n2. Compare with stored check bits\n3. If different: Error detected\n4. Pattern indicates which bit is wrong",
                "type": "list",
                "section": "Error Detection and Correction",
                "subsection": "Hamming Error Correcting Code"
              },
              {
                "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Error-Correction",
                "title": "Error Correction",
                "front": "Error Correction",
                "back": "1. Error pattern identifies bit position\n2. Flip that bit to correct error",
                "type": "list",
                "section": "Error Detection and Correction",
                "subsection": "Hamming Error Correcting Code"
              },
              {
                "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Overhead",
                "title": "Overhead",
                "front": "Overhead",
                "back": "1. More bits needed (redundancy)\n2. Example: 8 data bits → 12 total bits (50% overhead)\n3. Larger data words: Lower overhead percentage",
                "type": "list",
                "section": "Error Detection and Correction",
                "subsection": "Hamming Error Correcting Code"
              }
            ]
          }
        ]
      },
      {
        "section": "Advanced DRAM Technologies",
        "subsections": [
          {
            "subsection": "Traditional DRAM Limitations",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-Advanced-DRAM-Technologies-Traditional-DRAM-Limitations-Problems",
                "title": "Problems",
                "front": "Problems",
                "back": "1. **Internal architecture:** Slow access patterns\n2. **Interface:** Asynchronous, processor must wait\n3. **Bottleneck:** Memory interface limits performance",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Traditional DRAM Limitations"
              }
            ]
          },
          {
            "subsection": "Synchronous DRAM (SDRAM)",
            "cardCount": 4,
            "cards": [
              {
                "id": "4-Advanced-DRAM-Technologies-Synchronous-DRAM--SDRAM--Key-Innovation",
                "title": "Key Innovation",
                "front": "Key Innovation",
                "back": "Access synchronized with external clock.",
                "type": "definition",
                "section": "Advanced DRAM Technologies",
                "subsection": "Synchronous DRAM (SDRAM)"
              },
              {
                "id": "4-Advanced-DRAM-Technologies-Synchronous-DRAM--SDRAM--Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "1. Address presented to RAM\n2. RAM finds data\n3. **CPU knows when data will be ready** (synchronized with clock)\n4. CPU doesn't have to wait (can do other work)",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Synchronous DRAM (SDRAM)"
              },
              {
                "id": "4-Advanced-DRAM-Technologies-Synchronous-DRAM--SDRAM--Burst-Mode",
                "title": "Burst Mode",
                "front": "Burst Mode",
                "back": "1. Set up stream of data\n2. Fire out data in block\n3. More efficient than single-word transfers",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Synchronous DRAM (SDRAM)"
              },
              {
                "id": "4-Advanced-DRAM-Technologies-Synchronous-DRAM--SDRAM--Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Predictable timing\n2. CPU can pipeline other operations\n3. Better bandwidth utilization",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Synchronous DRAM (SDRAM)"
              }
            ]
          },
          {
            "subsection": "Double Data Rate SDRAM (DDR SDRAM)",
            "cardCount": 5,
            "cards": [
              {
                "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--Key-Innovation",
                "title": "Key Innovation",
                "front": "Key Innovation",
                "back": "Sends data **twice per clock cycle**.",
                "type": "definition",
                "section": "Advanced DRAM Technologies",
                "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
              },
              {
                "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--How",
                "title": "How",
                "front": "How",
                "back": "1. Data transfer on **both rising and falling edge** of clock\n2. Doubles data rate compared to SDRAM",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
              },
              {
                "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--Achieves-Higher-Rates-Through",
                "title": "Achieves Higher Rates Through",
                "front": "Achieves Higher Rates Through",
                "back": "1. **Double clocking:** Data on both edges\n2. **Higher bus clock rate:** Faster interface\n3. **Buffering scheme:** Prefetch and buffer data",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
              },
              {
                "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--Generations",
                "title": "Generations",
                "front": "Generations",
                "back": "1. **DDR:** 2x SDRAM\n2. **DDR2:** 2x DDR (4x SDRAM)\n3. **DDR3:** 2x DDR2 (8x SDRAM)\n4. **DDR4:** 2x DDR3 (16x SDRAM)\n5. **DDR5:** 2x DDR4 (32x SDRAM)",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
              },
              {
                "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--Each-Generation",
                "title": "Each Generation",
                "front": "Each Generation",
                "back": "1. Higher data rates\n2. Lower voltage (power efficiency)\n3. Better signal integrity\n4. More features",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
              }
            ]
          },
          {
            "subsection": "Other Advanced Technologies",
            "cardCount": 2,
            "cards": [
              {
                "id": "4-Advanced-DRAM-Technologies-Other-Advanced-Technologies-DDR-Variations",
                "title": "DDR Variations",
                "front": "DDR Variations",
                "back": "1. **GDDR:** Graphics DDR (for GPUs)\n2. **LPDDR:** Low Power DDR (for mobile devices)",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Other Advanced Technologies"
              },
              {
                "id": "4-Advanced-DRAM-Technologies-Other-Advanced-Technologies-Future-Technologies",
                "title": "Future Technologies",
                "front": "Future Technologies",
                "back": "1. **HBM (High Bandwidth Memory):** 3D stacked memory\n2. **HMC (Hybrid Memory Cube):** Advanced 3D memory",
                "type": "list",
                "section": "Advanced DRAM Technologies",
                "subsection": "Other Advanced Technologies"
              }
            ]
          }
        ]
      },
      {
        "section": "Key Concepts Summary",
        "subsections": [
          {
            "subsection": "Memory Hierarchy Principles",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-Key-Concepts-Summary-Memory-Hierarchy-Principles-Memory-Hierarchy-Principles",
                "title": "Memory Hierarchy Principles",
                "front": "Memory Hierarchy Principles",
                "back": "1. **Trade-offs:** Speed, capacity, cost cannot all be optimized simultaneously\n2. **Hierarchy Solution:** Use multiple levels with different characteristics\n3. **Locality:** Temporal and spatial locality enable hierarchy to work\n4. **Performance:** Average access time much closer to fast memory than slow memory",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Memory Hierarchy Principles"
              }
            ]
          },
          {
            "subsection": "Cache Fundamentals",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-Key-Concepts-Summary-Cache-Fundamentals-Cache-Fundamentals",
                "title": "Cache Fundamentals",
                "front": "Cache Fundamentals",
                "back": "1. **Purpose:** Bridge speed gap between CPU and main memory\n2. **Operation:** Store recently accessed blocks\n3. **Metrics:** Hit rate, miss rate, miss penalty\n4. **Performance:** AMAT = Hit time + (Miss rate × Miss penalty)",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Cache Fundamentals"
              }
            ]
          },
          {
            "subsection": "Cache Design",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-Key-Concepts-Summary-Cache-Design-Cache-Design",
                "title": "Cache Design",
                "front": "Cache Design",
                "back": "1. **Mapping:** Direct, associative, set-associative (trade-offs)\n2. **Replacement:** LRU most effective, but more complex\n3. **Write Policy:** Write back better performance, write through simpler\n4. **Size:** Larger = better hit rate, but slower hit time",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Cache Design"
              }
            ]
          },
          {
            "subsection": "Memory Technologies",
            "cardCount": 1,
            "cards": [
              {
                "id": "4-Key-Concepts-Summary-Memory-Technologies-Memory-Technologies",
                "title": "Memory Technologies",
                "front": "Memory Technologies",
                "back": "1. **DRAM:** Cheap, dense, needs refresh, used for main memory\n2. **SRAM:** Fast, expensive, no refresh, used for cache\n3. **Error Correction:** Hamming codes detect and correct errors\n4. **Advanced DRAM:** SDRAM, DDR improve performance",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Memory Technologies"
              }
            ]
          }
        ]
      },
      {
        "section": "Practice Problems and Examples",
        "subsections": [
          {
            "subsection": "Problem 1: Cache Address Breakdown",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Practice-Problems-and-Examples-Problem-1--Cache-Address-Breakdown-Question",
                "title": "Question",
                "front": "Question",
                "back": "A direct-mapped cache has 32 lines, block size 8 bytes. Main memory is 16 MB. How is a 24-bit address divided?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Cache Address Breakdown"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-1--Cache-Address-Breakdown-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Cache lines: 32 = 2^5 → 5 bits for line\n2. Block size: 8 bytes = 2^3 → 3 bits for word offset\n3. Tag: 24 - 5 - 3 = 16 bits",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Cache Address Breakdown"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-1--Cache-Address-Breakdown-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. Tag: 16 bits\n2. Line: 5 bits\n3. Word: 3 bits",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Cache Address Breakdown"
              }
            ]
          },
          {
            "subsection": "Problem 2: AMAT Calculation",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Practice-Problems-and-Examples-Problem-2--AMAT-Calculation-Question",
                "title": "Question",
                "front": "Question",
                "back": "Cache has hit time 2 ns, miss rate 3%, miss penalty 50 ns. What is AMAT?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: AMAT Calculation"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-2--AMAT-Calculation-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "AMAT = Hit time + (Miss rate × Miss penalty) = 2 + (0.03 × 50)",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: AMAT Calculation"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-2--AMAT-Calculation-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "3.5 ns",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: AMAT Calculation"
              }
            ]
          },
          {
            "subsection": "Problem 3: CPI with Cache",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Practice-Problems-and-Examples-Problem-3--CPI-with-Cache-Question",
                "title": "Question",
                "front": "Question",
                "back": "Base CPI = 2, I-cache miss rate = 2%, D-cache miss rate = 5%, 40% loads/stores, miss penalty = 100 cycles. What is actual CPI?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: CPI with Cache"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-3--CPI-with-Cache-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Instruction miss cycles = 0.02 × 100 = 2 Data miss cycles = 0.4 × 0.05 × 100 = 2 CPI_actual = 2 + 2 + 2 = 6",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: CPI with Cache"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-3--CPI-with-Cache-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "CPI = 6",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: CPI with Cache"
              }
            ]
          },
          {
            "subsection": "Problem 4: Set-Associative Mapping",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Practice-Problems-and-Examples-Problem-4--Set-Associative-Mapping-Question",
                "title": "Question",
                "front": "Question",
                "back": "4-way set associative cache, 64 lines total. How many sets? Block 100 maps to which set?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Set-Associative Mapping"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-4--Set-Associative-Mapping-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Total lines: 64\n2. Ways per set: 4\n3. Number of sets: 64 / 4 = 16 sets\n4. Set bits: log2(16) = 4 bits\n5. Block 100: 100 mod 16 = 4 → Set 4",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Set-Associative Mapping"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-4--Set-Associative-Mapping-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "16 sets, Block 100 → Set 4",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Set-Associative Mapping"
              }
            ]
          },
          {
            "subsection": "Problem 5: Multi-Level Cache",
            "cardCount": 3,
            "cards": [
              {
                "id": "4-Practice-Problems-and-Examples-Problem-5--Multi-Level-Cache-Question",
                "title": "Question",
                "front": "Question",
                "back": "L1 hit time = 1 cycle, miss rate = 5%, L2 hit time = 10 cycles, global miss rate = 1%, main memory = 100 cycles. What is AMAT?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Multi-Level Cache"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-5--Multi-Level-Cache-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "L1 hit: 0.95 × 1 = 0.95 cycles L1 miss, L2 hit: 0.05 × 0.8 × 10 = 0.4 cycles (80% of L1 misses hit in L2) L1 miss, L2 miss: 0.05 × 0.2 × 100 = 1.0 cycles (20% of L1 misses miss in L2) AMAT = 0.95 + 0.4 + 1.0 = 2.35 cycles",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Multi-Level Cache"
              },
              {
                "id": "4-Practice-Problems-and-Examples-Problem-5--Multi-Level-Cache-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **Understand Trade-offs:**\n2. Every design decision has pros and cons\n3. Larger cache vs. faster cache\n4. Higher associativity vs. lower cost\n5. **Master Calculations:**\n6. AMAT formula\n7. CPI with cache misses\n8. Address breakdown for different mappings\n9. **Visualize Cache Organization:**\n10. Draw cache structures\n11. Understand tag, line, word fields\n12. Trace cache operations\n13. **Compare Techniques:**\n14. Direct vs. associative vs. set-associative\n15. Write through vs. write back\n16. Replacement algorithms\n17. **Understand Locality:**\n18. Why hierarchy works\n19. How to exploit locality\n20. Impact on performance\n21. **Memory hierarchy** solves the speed/capacity/cost trade-off\n22. **Locality of reference** makes hierarchy effective\n23. **Cache memory** bridges the CPU-memory speed gap\n24. **Mapping techniques** balance flexibility and cost\n25. **Multi-level caches** further improve performance\n26. **DRAM and SRAM** serve different roles in the hierarchy\n27. Memory is often the performance bottleneck\n28. Cache design significantly impacts performance\n29. Memory hierarchy is fundamental to computer architecture",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Multi-Level Cache"
              }
            ]
          }
        ]
      }
    ],
    "allCards": [
      {
        "id": "4-Detailed-Study-Guide--Detailed-Study-Guide",
        "title": "Detailed Study Guide",
        "front": "Detailed Study Guide",
        "back": "1. [Memory Characteristics and Classification](#memory-characteristics-and-classification)\n2. [The Memory Hierarchy Concept](#the-memory-hierarchy-concept)\n3. [Locality of Reference](#locality-of-reference)\n4. [Cache Memory Fundamentals](#cache-memory-fundamentals)\n5. [Cache Mapping Techniques](#cache-mapping-techniques)\n6. [Cache Replacement Policies](#cache-replacement-policies)\n7. [Write Policies](#write-policies)\n8. [Cache Performance Analysis](#cache-performance-analysis)\n9. [Multi-Level Caches](#multi-level-caches)\n10. [Internal Memory: DRAM and SRAM](#internal-memory-dram-and-sram)\n11. [Error Detection and Correction](#error-detection-and-correction)\n12. [Advanced DRAM Technologies](#advanced-dram-technologies)\n13. [Key Concepts Summary](#key-concepts-summary)\n14. [Practice Problems and Examples](#practice-problems-and-examples)",
        "type": "list",
        "section": "Detailed Study Guide",
        "subsection": ""
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-1--Location",
        "title": "1. Location",
        "front": "1. Location",
        "back": "",
        "type": "concept",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-CPU",
        "title": "CPU",
        "front": "CPU",
        "back": "1. **Registers:** Fastest, smallest, most expensive\n2. Located directly in processor\n3. Used for temporary storage during execution",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Internal",
        "title": "Internal",
        "front": "Internal",
        "back": "1. **Main Memory (RAM):** Primary storage\n2. **Cache Memory:** Fast buffer between CPU and main memory\n3. Accessible directly by processor",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-External",
        "title": "External",
        "front": "External",
        "back": "1. **Secondary Storage:** Disk drives, SSDs, tape\n2. Accessible via I/O controllers\n3. Persistent, non-volatile",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-2--Capacity",
        "title": "2. Capacity",
        "front": "2. Capacity",
        "back": "",
        "type": "concept",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Word-Size",
        "title": "Word Size",
        "front": "Word Size",
        "back": "1. Natural unit of organization\n2. Common sizes: 8, 16, 32, 64 bits\n3. Determines how much data can be processed at once",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Number-of-Words-Bytes",
        "title": "Number of Words/Bytes",
        "front": "Number of Words/Bytes",
        "back": "1. Total storage capacity\n2. External memory typically expressed in bytes (KB, MB, GB, TB)\n3. Internal memory may be expressed in words or bytes",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Relationship",
        "title": "Relationship",
        "front": "Relationship",
        "back": "1. Address length (A bits) → 2^A addressable units\n2. Example: 20-bit address → 2^20 = 1,048,576 locations",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-3--Unit-of-Transfer",
        "title": "3. Unit of Transfer",
        "front": "3. Unit of Transfer",
        "back": "",
        "type": "concept",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Internal-Memory",
        "title": "Internal Memory",
        "front": "Internal Memory",
        "back": "1. Usually governed by bus data width\n2. May equal word length, but often larger\n3. Example: 32-bit processor with 64-bit data bus",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-External-Memory",
        "title": "External Memory",
        "front": "External Memory",
        "back": "1. Usually a **block** (much larger than a word)\n2. Example: Disk sectors (512 bytes, 4 KB, etc.)",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Addressable-Unit",
        "title": "Addressable Unit",
        "front": "Addressable Unit",
        "back": "1. Smallest location that can be uniquely addressed\n2. Typically: byte (8 bits) or word (16/32/64 bits)",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-4--Access-Methods",
        "title": "4. Access Methods",
        "front": "4. Access Methods",
        "back": "",
        "type": "concept",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Sequential-Access",
        "title": "Sequential Access",
        "front": "Sequential Access",
        "back": "1. Memory organized into records\n2. Must start at beginning and read through in order\n3. Access time variable, depends on location\n4. **Example:** Magnetic tape",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Direct-Access",
        "title": "Direct Access",
        "front": "Direct Access",
        "back": "1. Individual blocks have unique addresses\n2. Access by jumping to vicinity plus sequential search\n3. Access time depends on location and previous location\n4. **Example:** Magnetic disk",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Random-Access",
        "title": "Random Access",
        "front": "Random Access",
        "back": "1. Individual addresses identify locations exactly\n2. Access time independent of location or previous access\n3. **Example:** RAM, cache",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Associative-Access",
        "title": "Associative Access",
        "front": "Associative Access",
        "back": "1. Word retrieved based on portion of contents (not address)\n2. Access time independent of location or previous access\n3. **Example:** Cache (when searching by tag)",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-5--Performance",
        "title": "5. Performance",
        "front": "5. Performance",
        "back": "",
        "type": "concept",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Access-Time--Latency-",
        "title": "Access Time (Latency)",
        "front": "Access Time (Latency)",
        "back": "1. Time between presenting address and getting valid data\n2. Critical for performance\n3. Measured in nanoseconds (ns) or clock cycles",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Memory-Cycle-Time",
        "title": "Memory Cycle Time",
        "front": "Memory Cycle Time",
        "back": "1. Time required for memory to \"recover\" before next access\n2. Access time + recovery time\n3. Concerned with system bus, not processor\n4. May be longer than access time",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Transfer-Rate",
        "title": "Transfer Rate",
        "front": "Transfer Rate",
        "back": "1. Rate at which data can be transferred into/out of memory\n2. Measured in bits/second or bytes/second\n3. For random-access memory: 1/(cycle time)\n4. Also called **bandwidth**",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Example",
        "title": "Example",
        "front": "Example",
        "back": "Access time: 50 ns Cycle time: 100 ns Transfer rate: 1/100ns = 10 MB/s (for 1-byte transfers)",
        "type": "definition",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-6--Physical-Types",
        "title": "6. Physical Types",
        "front": "6. Physical Types",
        "back": "",
        "type": "concept",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Semiconductor-Memory",
        "title": "Semiconductor Memory",
        "front": "Semiconductor Memory",
        "back": "1. RAM (Random Access Memory)\n2. ROM (Read-Only Memory)\n3. Flash memory",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Magnetic-Surface-Memory",
        "title": "Magnetic Surface Memory",
        "front": "Magnetic Surface Memory",
        "back": "1. Hard disk drives\n2. Magnetic tape",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Optical",
        "title": "Optical",
        "front": "Optical",
        "back": "1. CD, DVD, Blu-ray",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-7--Physical-Characteristics",
        "title": "7. Physical Characteristics",
        "front": "7. Physical Characteristics",
        "back": "",
        "type": "concept",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Volatile-vs--Nonvolatile",
        "title": "Volatile vs. Nonvolatile",
        "front": "Volatile vs. Nonvolatile",
        "back": "",
        "type": "definition",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Volatile-Memory",
        "title": "Volatile Memory",
        "front": "Volatile Memory",
        "back": "1. Information lost when power is switched off\n2. Requires continuous power to retain data\n3. **Examples:** DRAM, SRAM",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Nonvolatile-Memory",
        "title": "Nonvolatile Memory",
        "front": "Nonvolatile Memory",
        "back": "1. Information remains without deterioration\n2. No electrical power needed to retain information\n3. **Examples:** ROM, Flash, Magnetic disk",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Erasable-vs--Nonerasable",
        "title": "Erasable vs. Nonerasable",
        "front": "Erasable vs. Nonerasable",
        "back": "",
        "type": "definition",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Nonerasable-Memory",
        "title": "Nonerasable Memory",
        "front": "Nonerasable Memory",
        "back": "1. Cannot be altered (except by destroying storage unit)\n2. **Example:** ROM (Read-Only Memory)",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-Memory-Characteristics-and-Classification-Key-Characteristics-of-Memory-Systems-Erasable-Memory",
        "title": "Erasable Memory",
        "front": "Erasable Memory",
        "back": "1. Can be written and rewritten\n2. **Examples:** RAM, EEPROM, Flash",
        "type": "list",
        "section": "Memory Characteristics and Classification",
        "subsection": "Key Characteristics of Memory Systems"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-The-Memory-Dilemma-Design-Constraints",
        "title": "Design Constraints",
        "front": "Design Constraints",
        "back": "1. **How much?** (Capacity)\n2. **How fast?** (Access time)\n3. **How expensive?** (Cost per bit)",
        "type": "list",
        "section": "The Memory Hierarchy Concept",
        "subsection": "The Memory Dilemma"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-The-Memory-Dilemma-The-Trade-off",
        "title": "The Trade-off",
        "front": "The Trade-off",
        "back": "1. **Faster access time** → **Greater cost per bit**\n2. **Greater capacity** → **Smaller cost per bit**\n3. **Greater capacity** → **Slower access time**",
        "type": "list",
        "section": "The Memory Hierarchy Concept",
        "subsection": "The Memory Dilemma"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-The-Memory-Dilemma-The-Problem",
        "title": "The Problem",
        "front": "The Problem",
        "back": "1. We want: Large capacity, fast access, low cost\n2. But: Can't have all three simultaneously!",
        "type": "list",
        "section": "The Memory Hierarchy Concept",
        "subsection": "The Memory Dilemma"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-The-Solution--Memory-Hierarchy-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Use multiple levels of memory with different speeds and sizes.",
        "type": "definition",
        "section": "The Memory Hierarchy Concept",
        "subsection": "The Solution: Memory Hierarchy"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-The-Solution--Memory-Hierarchy-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Store frequently accessed data in fast, expensive memory; store bulk data in slow, cheap memory.",
        "type": "definition",
        "section": "The Memory Hierarchy Concept",
        "subsection": "The Solution: Memory Hierarchy"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-Memory-Hierarchy-Levels-From-Fastest-Smallest-Most-Expensive-to-Slowest-Largest-Cheapest",
        "title": "From Fastest/Smallest/Most Expensive to Slowest/Largest/Cheapest",
        "front": "From Fastest/Smallest/Most Expensive to Slowest/Largest/Cheapest",
        "back": "Level 1: CPU Registers Level 2: Cache Memory (L1, L2, L3) Level 3: Main Memory (DRAM) Level 4: Secondary Storage (Disk, SSD) Level 5: Tertiary Storage (Tape, Optical)",
        "type": "definition",
        "section": "The Memory Hierarchy Concept",
        "subsection": "Memory Hierarchy Levels"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Characteristics-Going-Down-the-Hierarchy",
        "title": "Going Down the Hierarchy",
        "front": "Going Down the Hierarchy",
        "back": "1. **Decreasing cost per bit**\n2. Registers: Very expensive\n3. Cache: Expensive\n4. Main memory: Moderate cost\n5. Disk: Cheap\n6. **Increasing capacity**\n7. Registers: ~32-64 words\n8. Cache: KB to MB\n9. Main memory: GB\n10. Disk: TB\n11. **Increasing access time**\n12. Registers: 1 cycle (nanoseconds)\n13. Cache: 1-10 cycles (nanoseconds)\n14. Main memory: 50-100 cycles (nanoseconds)\n15. Disk: Millions of cycles (milliseconds)\n16. **Decreasing frequency of access**\n17. Most accesses: Registers\n18. Many accesses: Cache\n19. Some accesses: Main memory\n20. Few accesses: Disk",
        "type": "list",
        "section": "The Memory Hierarchy Concept",
        "subsection": "Hierarchy Characteristics"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Example-Typical-System",
        "title": "Typical System",
        "front": "Typical System",
        "back": "1. **L1 Cache:** 32 KB, 1 cycle access, $100/GB\n2. **L2 Cache:** 256 KB, 5 cycles access, $50/GB\n3. **L3 Cache:** 8 MB, 20 cycles access, $10/GB\n4. **Main Memory:** 16 GB, 100 cycles access, $1/GB\n5. **Disk:** 1 TB, 10,000,000 cycles access, $0.01/GB",
        "type": "list",
        "section": "The Memory Hierarchy Concept",
        "subsection": "Hierarchy Example"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Example-Access-Distribution",
        "title": "Access Distribution",
        "front": "Access Distribution",
        "back": "1. 95% from L1 cache\n2. 4.999% from L2 cache\n3. 0.001% from L3 cache\n4. 0.000005% from main memory\n5. Even fewer from disk",
        "type": "list",
        "section": "The Memory Hierarchy Concept",
        "subsection": "Hierarchy Example"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Example-Average-Access-Time-Calculation",
        "title": "Average Access Time Calculation",
        "front": "Average Access Time Calculation",
        "back": "AMAT = 0.95 × 1 + 0.04999 × 5 + 0.00001 × 20 + 0.00000005 × 100 = 0.95 + 0.25 + 0.0002 + 0.000005 ≈ 1.2 cycles",
        "type": "definition",
        "section": "The Memory Hierarchy Concept",
        "subsection": "Hierarchy Example"
      },
      {
        "id": "4-The-Memory-Hierarchy-Concept-Hierarchy-Example-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "Average access time is much closer to L1 access time (1 cycle) than main memory (100 cycles)!",
        "type": "definition",
        "section": "The Memory Hierarchy Concept",
        "subsection": "Hierarchy Example"
      },
      {
        "id": "4-Locality-of-Reference-What-is-Locality--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "During program execution, memory references tend to **cluster**.",
        "type": "definition",
        "section": "Locality of Reference",
        "subsection": "What is Locality?"
      },
      {
        "id": "4-Locality-of-Reference-What-is-Locality--Observation",
        "title": "Observation",
        "front": "Observation",
        "back": "Programs access a **small proportion** of their address space at any given time.",
        "type": "definition",
        "section": "Locality of Reference",
        "subsection": "What is Locality?"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-1--Temporal-Locality",
        "title": "1. Temporal Locality",
        "front": "1. Temporal Locality",
        "back": "",
        "type": "concept",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Items accessed **recently** are likely to be accessed again **soon**.",
        "type": "definition",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "If an item is referenced, it will tend to be referenced again soon.",
        "type": "definition",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **Loop instructions:** Same instructions executed repeatedly\n2. **Reused variables:** Variables accessed multiple times\n3. **Function calls:** Same functions called repeatedly",
        "type": "list",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-Example",
        "title": "Example",
        "front": "Example",
        "back": "for (i = 0; i < 1000; i++) { sum = sum + array[i]; // 'sum' accessed every iteration",
        "type": "definition",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-2--Spatial-Locality",
        "title": "2. Spatial Locality",
        "front": "2. Spatial Locality",
        "back": "",
        "type": "concept",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Items **near** those accessed recently are likely to be accessed soon.",
        "type": "definition",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "If an item is referenced, items whose addresses are close by will tend to be referenced soon.",
        "type": "definition",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **Sequential instruction access:** Instructions stored sequentially\n2. **Array data:** Array elements stored contiguously\n3. **Stack operations:** Stack grows/shrinks sequentially",
        "type": "list",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Two-Types-of-Locality-Example",
        "title": "Example",
        "front": "Example",
        "back": "for (i = 0; i < 1000; i++) { sum = sum + array[i]; // array[i], array[i+1], array[i+2] accessed sequentially",
        "type": "definition",
        "section": "Locality of Reference",
        "subsection": "Two Types of Locality"
      },
      {
        "id": "4-Locality-of-Reference-Exploiting-Locality-Memory-Hierarchy-Strategy",
        "title": "Memory Hierarchy Strategy",
        "front": "Memory Hierarchy Strategy",
        "back": "1. **Store everything on disk** (cheap, large, slow)\n2. **Copy recently accessed items to main memory:**\n3. Exploits temporal locality (recent items likely needed again)\n4. Main memory faster than disk\n5. **Copy more recently accessed items to cache:**\n6. Exploits temporal locality further\n7. Cache faster than main memory\n8. **Copy nearby items when accessing:**\n9. Exploits spatial locality\n10. When accessing one word, bring in entire block\n11. Adjacent words likely to be accessed soon",
        "type": "list",
        "section": "Locality of Reference",
        "subsection": "Exploiting Locality"
      },
      {
        "id": "4-Locality-of-Reference-Exploiting-Locality-Result",
        "title": "Result",
        "front": "Result",
        "back": "Most accesses satisfied by fast memory (cache), few require slow memory (disk).",
        "type": "definition",
        "section": "Locality of Reference",
        "subsection": "Exploiting Locality"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-What-is-Cache--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "A small amount of fast memory located between the processor and main memory.",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "What is Cache?"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-What-is-Cache--Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "1. Store recently accessed data and instructions\n2. Reduce average memory access time\n3. Bridge the speed gap between CPU and main memory",
        "type": "list",
        "section": "Cache Memory Fundamentals",
        "subsection": "What is Cache?"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-What-is-Cache--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Small:** Typically KB to MB\n2. **Fast:** 1-10 cycles access time\n3. **Expensive:** High cost per bit\n4. **On-chip:** Often located on CPU chip",
        "type": "list",
        "section": "Cache Memory Fundamentals",
        "subsection": "What is Cache?"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Cache-Operation-Overview-Read-Operation-",
        "title": "Read Operation:",
        "front": "Read Operation:",
        "back": "1. **CPU requests** contents of memory location\n2. **Check cache** for data\n3. **If present (Hit):**\n4. Get data from cache (fast)\n5. Deliver to CPU\n6. **If not present (Miss):**\n7. Read required **block** from main memory\n8. Load block into cache\n9. Deliver requested word to CPU",
        "type": "list",
        "section": "Cache Memory Fundamentals",
        "subsection": "Cache Operation Overview"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Cache-Operation-Overview-Write-Operation-",
        "title": "Write Operation:",
        "front": "Write Operation:",
        "back": "1. **CPU writes** data to memory location\n2. **Check cache** for location\n3. **If present (Hit):**\n4. Update cache\n5. May update main memory (depending on write policy)\n6. **If not present (Miss):**\n7. Load block into cache\n8. Update cache\n9. May update main memory",
        "type": "list",
        "section": "Cache Memory Fundamentals",
        "subsection": "Cache Operation Overview"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Block--Line-",
        "title": "Block (Line)",
        "front": "Block (Line)",
        "back": "",
        "type": "concept",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Unit of data transfer between cache and main memory.",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. May be multiple words\n2. Typically 16-128 bytes\n3. When one word is accessed, entire block is brought into cache\n4. Exploits spatial locality\n5. Reduces number of memory accesses\n6. More efficient than word-by-word transfer",
        "type": "list",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Hit",
        "title": "Hit",
        "front": "Hit",
        "back": "",
        "type": "concept",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Access satisfied by upper level (cache).",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Hit-Ratio",
        "title": "Hit Ratio",
        "front": "Hit Ratio",
        "back": "`hits / total_accesses`",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. 1000 memory accesses\n2. 950 satisfied by cache\n3. Hit ratio = 950/1000 = 0.95 = 95%",
        "type": "list",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Miss",
        "title": "Miss",
        "front": "Miss",
        "back": "",
        "type": "concept",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Block not present in cache, must be copied from lower level (main memory).",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Miss-Ratio",
        "title": "Miss Ratio",
        "front": "Miss Ratio",
        "back": "`misses / total_accesses = 1 - hit_ratio`",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. Hit ratio = 95%\n2. Miss ratio = 5%",
        "type": "list",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Miss-Penalty",
        "title": "Miss Penalty",
        "front": "Miss Penalty",
        "back": "",
        "type": "concept",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Time taken to handle a miss.",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Components",
        "title": "Components",
        "front": "Components",
        "back": "1. Time to access main memory\n2. Time to transfer block to cache\n3. Time to deliver data to CPU",
        "type": "list",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Key-Definitions-Typical",
        "title": "Typical",
        "front": "Typical",
        "back": "10-100+ cycles",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "Key Definitions"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Cache-Organization-Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "Cache Line: ┌──────┬──────┬──────────┐ │ Valid│ Tag │ Data │ │ Bit │ │ (Block) │ └──────┴──────┴──────────┘",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "Cache Organization"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Cache-Organization-Components",
        "title": "Components",
        "front": "Components",
        "back": "1. **Valid Bit:** Indicates if line contains valid data\n2. **Tag:** Identifies which memory block is stored\n3. **Data:** The actual data block",
        "type": "list",
        "section": "Cache Memory Fundamentals",
        "subsection": "Cache Organization"
      },
      {
        "id": "4-Cache-Memory-Fundamentals-Cache-Organization-Example",
        "title": "Example",
        "front": "Example",
        "back": "Line 0: [V=1] [Tag=0x1234] [Data: word0, word1, word2, word3] Line 1: [V=0] [Tag=----] [Data: ----] Line 2: [V=1] [Tag=0x5678] [Data: word0, word1, word2, word3]",
        "type": "definition",
        "section": "Cache Memory Fundamentals",
        "subsection": "Cache Organization"
      },
      {
        "id": "4-Cache-Mapping-Techniques-The-Mapping-Problem-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "There are fewer cache lines than main memory blocks.",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "The Mapping Problem"
      },
      {
        "id": "4-Cache-Mapping-Techniques-The-Mapping-Problem-Question",
        "title": "Question",
        "front": "Question",
        "back": "How do we map main memory blocks to cache lines?",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "The Mapping Problem"
      },
      {
        "id": "4-Cache-Mapping-Techniques-The-Mapping-Problem-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. Main memory: 1 million blocks\n2. Cache: 1,000 lines\n3. Each block must map to one or more possible cache lines",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "The Mapping Problem"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-1--Direct-Mapping",
        "title": "1. Direct Mapping",
        "front": "1. Direct Mapping",
        "back": "",
        "type": "concept",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Each block of main memory maps to **exactly one** cache line.",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Mapping-Formula",
        "title": "Mapping Formula",
        "front": "Mapping Formula",
        "back": "1. `i` = cache line number\n2. `j` = main memory block number\n3. `m` = number of lines in cache",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Address-Structure",
        "title": "Address Structure",
        "front": "Address Structure",
        "back": "┌──────────┬──────┬──────┐ │ Tag │ Line │ Word │ │ (s-r bits)│(r bits)│(w bits)│ └──────────┴──────┴──────┘",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Fields",
        "title": "Fields",
        "front": "Fields",
        "back": "1. **Tag:** High-order bits identifying which block\n2. **Line:** Cache line number (low-order bits of block address)\n3. **Word:** Word offset within block",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. Cache: 8 lines (3 bits for line number)\n2. Block size: 1 word (0 bits for word offset)\n3. Address: 22 (binary: 10110)",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Breaking-down-address-22",
        "title": "Breaking down address 22",
        "front": "Breaking down address 22",
        "back": "Binary: 1 0 1 1 0 │ │ └─► Line = 110 (binary) = 6 └─┴──────► Tag = 10 (binary) = 2",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "1. Extract line number from address\n2. Check if valid bit is set\n3. Compare tag in cache with tag from address\n4. If match: **Hit** (data in cache)\n5. If no match: **Miss** (load block from memory)",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Simple:** Easy to implement\n2. **Fast:** Direct lookup (no search needed)\n3. **Inexpensive:** Minimal hardware",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Fixed location:** Any given block can only be in one specific line\n2. **Thrashing:** If program accesses blocks that map to same line repeatedly, constant misses\n3. **Low flexibility:** No choice in placement",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Thrashing-Example",
        "title": "Thrashing Example",
        "front": "Thrashing Example",
        "back": "Blocks 0, 8, 16, 24 all map to line 0 (0 mod 8 = 0, 8 mod 8 = 0, etc.) Accessing: 0, 8, 0, 8, 0, 8... Result: Constant misses (each access evicts previous block)",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-2--Fully-Associative-Mapping",
        "title": "2. Fully Associative Mapping",
        "front": "2. Fully Associative Mapping",
        "back": "",
        "type": "concept",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "A main memory block can load into **any line** of cache.",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Address-Structure",
        "title": "Address Structure",
        "front": "Address Structure",
        "back": "┌──────────┬──────┐ │ Tag │ Word │ │ (s bits) │(w bits)│ └──────────┴──────┘",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Fields",
        "title": "Fields",
        "front": "Fields",
        "back": "1. **Tag:** Full block address (no line field needed)\n2. **Word:** Word offset within block",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "1. Extract tag from address\n2. **Search all cache lines** for matching tag\n3. If found: **Hit**\n4. If not found: **Miss** (load into any available line)",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Maximum flexibility:** Block can be placed anywhere\n2. **No thrashing:** No conflicts between blocks\n3. **Best hit ratio:** Optimal placement possible",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Expensive:** Requires comparators for all lines\n2. **Slow:** Must search all lines (parallel search needed for speed)\n3. **Complex:** More hardware complexity",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Hardware-Requirements",
        "title": "Hardware Requirements",
        "front": "Hardware Requirements",
        "back": "1. N comparators (one per cache line)\n2. Parallel tag comparison\n3. More expensive as cache size increases",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-3--Set-Associative-Mapping",
        "title": "3. Set-Associative Mapping",
        "front": "3. Set-Associative Mapping",
        "back": "",
        "type": "concept",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Compromise between direct and fully associative.",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Organization",
        "title": "Organization",
        "front": "Organization",
        "back": "1. Cache divided into **sets**\n2. Each set contains **k lines** (k-way set associative)\n3. Block maps to **one specific set**, but can be placed in **any line within that set**",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Mapping",
        "title": "Mapping",
        "front": "Mapping",
        "back": "1. Set number: `(Block number) mod (Number of sets)`\n2. Within set: Any of k lines",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Address-Structure",
        "title": "Address Structure",
        "front": "Address Structure",
        "back": "┌──────────┬──────┬──────┐ │ Tag │ Set │ Word │ │(s-d bits)│(d bits)│(w bits)│ └──────────┴──────┴──────┘",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Fields",
        "title": "Fields",
        "front": "Fields",
        "back": "1. **Tag:** Identifies block within set\n2. **Set:** Set number (determines which set)\n3. **Word:** Word offset within block",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Example---2-Way-Set-Associative",
        "title": "Example - 2-Way Set Associative",
        "front": "Example - 2-Way Set Associative",
        "back": "1. Cache: 8 lines total\n2. Sets: 4 sets (2 lines per set)\n3. Block 12: 12 mod 4 = 0 → Set 0, can be in either line of Set 0",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "1. Extract set number from address\n2. Search **only lines in that set** for matching tag\n3. If found: **Hit**\n4. If not found: **Miss** (load into any available line in set)",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Good flexibility:** Multiple choices per block\n2. **Reasonable cost:** Only k comparators needed (not all lines)\n3. **Better than direct:** Reduces thrashing\n4. **Better than fully associative:** Lower cost, faster",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **More complex than direct:** Requires set selection and search\n2. **More expensive than direct:** Needs k comparators\n3. **Less flexible than fully associative:** Limited to k choices",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Three-Mapping-Techniques-Common-Configurations",
        "title": "Common Configurations",
        "front": "Common Configurations",
        "back": "1. **2-way:** 2 lines per set (common, good balance)\n2. **4-way:** 4 lines per set (very common)\n3. **8-way:** 8 lines per set (high-end processors)",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Three Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Comparison-of-Mapping-Techniques-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "Most processors use **set-associative** (typically 2-8 way) for good balance.",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Comparison of Mapping Techniques"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Associativity-Spectrum-For-a-cache-with-8-entries",
        "title": "For a cache with 8 entries",
        "front": "For a cache with 8 entries",
        "back": "1. **Direct (1-way):** 8 sets, 1 line per set\n2. **2-way:** 4 sets, 2 lines per set\n3. **4-way:** 2 sets, 4 lines per set\n4. **8-way (Fully Associative):** 1 set, 8 lines per set",
        "type": "list",
        "section": "Cache Mapping Techniques",
        "subsection": "Associativity Spectrum"
      },
      {
        "id": "4-Cache-Mapping-Techniques-Associativity-Spectrum-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "Direct mapping and fully associative are special cases of set-associative!",
        "type": "definition",
        "section": "Cache Mapping Techniques",
        "subsection": "Associativity Spectrum"
      },
      {
        "id": "4-Cache-Replacement-Policies-When-Replacement-is-Needed-Situation",
        "title": "Situation",
        "front": "Situation",
        "back": "Cache is full, new block must be loaded.",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "When Replacement is Needed"
      },
      {
        "id": "4-Cache-Replacement-Policies-When-Replacement-is-Needed-Direct-Mapping",
        "title": "Direct Mapping",
        "front": "Direct Mapping",
        "back": "1. **No choice:** Only one possible line\n2. Replacement is automatic",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "When Replacement is Needed"
      },
      {
        "id": "4-Cache-Replacement-Policies-When-Replacement-is-Needed-Associative-Set-Associative",
        "title": "Associative/Set-Associative",
        "front": "Associative/Set-Associative",
        "back": "1. **Choice available:** Which line to replace?\n2. Need **replacement algorithm**",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "When Replacement is Needed"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-1--Least-Recently-Used--LRU-",
        "title": "1. Least Recently Used (LRU)",
        "front": "1. Least Recently Used (LRU)",
        "back": "",
        "type": "concept",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Replace the block that has been in cache **longest without reference**.",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Implementation",
        "title": "Implementation",
        "front": "Implementation",
        "back": "1. Track access order for each set\n2. Replace least recently accessed block",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Most effective:** Exploits temporal locality\n2. **Good hit ratio:** Keeps recently used blocks",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Complexity:** Requires tracking access history\n2. **Hardware cost:** Counters or state machines needed",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Example",
        "title": "Example",
        "front": "Example",
        "back": "Set with blocks: A, B, C Access order: A, B, A, C, B Next miss: Replace C (least recently used)",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-2--First-In-First-Out--FIFO-",
        "title": "2. First-In-First-Out (FIFO)",
        "front": "2. First-In-First-Out (FIFO)",
        "back": "",
        "type": "concept",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Replace the block that has been in cache **longest** (regardless of recent use).",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Implementation",
        "title": "Implementation",
        "front": "Implementation",
        "back": "1. Round-robin or circular buffer\n2. Replace oldest block",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Simple:** Easy to implement\n2. **Low cost:** Minimal hardware",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Less effective:** Doesn't consider recent usage\n2. **May evict frequently used blocks**",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Example",
        "title": "Example",
        "front": "Example",
        "back": "Blocks loaded: A, B, C (in that order) Next miss: Replace A (first in)",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-3--Least-Frequently-Used--LFU-",
        "title": "3. Least Frequently Used (LFU)",
        "front": "3. Least Frequently Used (LFU)",
        "back": "",
        "type": "concept",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Replace the block with **fewest references**.",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Implementation",
        "title": "Implementation",
        "front": "Implementation",
        "back": "1. Counter for each block\n2. Increment on access\n3. Replace block with lowest count",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Considers usage frequency:** Keeps frequently used blocks",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Complexity:** Counters needed\n2. **May keep old blocks:** Blocks accessed many times long ago",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Example",
        "title": "Example",
        "front": "Example",
        "back": "Block A: 10 accesses Block B: 5 accesses Block C: 2 accesses Next miss: Replace C (least frequently used)",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-4--Random",
        "title": "4. Random",
        "front": "4. Random",
        "back": "",
        "type": "concept",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Replace a **randomly selected** block.",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Implementation",
        "title": "Implementation",
        "front": "Implementation",
        "back": "1. Random number generator\n2. Select random line in set",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Very simple:** Minimal hardware\n2. **No tracking needed**",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Poor performance:** No locality consideration\n2. **Unpredictable:** May evict important blocks",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Replacement-Algorithms-Use",
        "title": "Use",
        "front": "Use",
        "back": "Rarely used, mainly for comparison",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "Replacement Algorithms"
      },
      {
        "id": "4-Cache-Replacement-Policies-Algorithm-Comparison-Effectiveness--Best-to-Worst-",
        "title": "Effectiveness (Best to Worst)",
        "front": "Effectiveness (Best to Worst)",
        "back": "1. LRU (most effective)\n2. LFU\n3. FIFO\n4. Random (least effective)",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Algorithm Comparison"
      },
      {
        "id": "4-Cache-Replacement-Policies-Algorithm-Comparison-Complexity--Simplest-to-Most-Complex-",
        "title": "Complexity (Simplest to Most Complex)",
        "front": "Complexity (Simplest to Most Complex)",
        "back": "1. Random (simplest)\n2. FIFO\n3. LRU\n4. LFU (most complex)",
        "type": "list",
        "section": "Cache Replacement Policies",
        "subsection": "Algorithm Comparison"
      },
      {
        "id": "4-Cache-Replacement-Policies-Algorithm-Comparison-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "**LRU** is most popular due to good effectiveness and reasonable implementation cost.",
        "type": "definition",
        "section": "Cache Replacement Policies",
        "subsection": "Algorithm Comparison"
      },
      {
        "id": "4-Write-Policies-The-Write-Problem-Issue",
        "title": "Issue",
        "front": "Issue",
        "back": "When CPU writes to cache, main memory must eventually be updated.",
        "type": "definition",
        "section": "Write Policies",
        "subsection": "The Write Problem"
      },
      {
        "id": "4-Write-Policies-The-Write-Problem-Questions",
        "title": "Questions",
        "front": "Questions",
        "back": "1. When should main memory be updated?\n2. What if cache block is replaced before being written to memory?\n3. What if multiple devices access main memory?",
        "type": "list",
        "section": "Write Policies",
        "subsection": "The Write Problem"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-1--Write-Through",
        "title": "1. Write Through",
        "front": "1. Write Through",
        "back": "",
        "type": "concept",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Every write to cache **also writes to main memory** immediately.",
        "type": "definition",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "CPU Write → Update Cache → Update Main Memory (simultaneously)",
        "type": "definition",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Simple:** Straightforward implementation\n2. **Consistency:** Cache and memory always consistent\n3. **I/O compatibility:** I/O devices can read directly from memory",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **High memory traffic:** Every write goes to memory\n2. **Slow writes:** Memory access is slow\n3. **Bottleneck:** Memory bus becomes bottleneck",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Performance-Impact",
        "title": "Performance Impact",
        "front": "Performance Impact",
        "back": "1. Hold data waiting to be written\n2. CPU continues immediately\n3. Only stalls if buffer is full\n4. Reduces performance penalty",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-2--Write-Back",
        "title": "2. Write Back",
        "front": "2. Write Back",
        "back": "",
        "type": "concept",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Write only to cache initially. Write to memory only when block is replaced.",
        "type": "definition",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "CPU Write → Update Cache (only) When block replaced → Write to memory (if dirty)",
        "type": "definition",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Dirty-Bit",
        "title": "Dirty Bit",
        "front": "Dirty Bit",
        "back": "1. Indicates if block has been modified\n2. Set when block is written\n3. Checked when block is replaced\n4. If dirty: Write to memory before replacement",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Minimizes memory writes:** Only dirty blocks written\n2. **Faster writes:** No memory access during write\n3. **Better performance:** Lower memory traffic",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Complexity:** Need dirty bit tracking\n2. **Inconsistency:** Cache and memory may differ\n3. **I/O issues:** I/O must go through cache or use cache coherency",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Two-Write-Policies-Performance-Impact",
        "title": "Performance Impact",
        "front": "Performance Impact",
        "back": "Base CPI = 1 10% of instructions are stores Only 20% of replaced blocks are dirty Memory write takes 100 cycles Miss rate = 2% Effective CPI = 1 + 0.02 × 0.2 × 100 = 1.4 (Much better than write through!)",
        "type": "definition",
        "section": "Write Policies",
        "subsection": "Two Write Policies"
      },
      {
        "id": "4-Write-Policies-Write-Allocation-Question",
        "title": "Question",
        "front": "Question",
        "back": "On write miss, should we load block into cache?",
        "type": "definition",
        "section": "Write Policies",
        "subsection": "Write Allocation"
      },
      {
        "id": "4-Write-Policies-Write-Allocation-Write-Allocate--Fetch-on-Write-Miss-",
        "title": "Write Allocate (Fetch on Write Miss)",
        "front": "Write Allocate (Fetch on Write Miss)",
        "back": "1. Load block into cache\n2. Update cache\n3. Use with write back",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Write Allocation"
      },
      {
        "id": "4-Write-Policies-Write-Allocation-No-Write-Allocate--Write-Around-",
        "title": "No Write Allocate (Write Around)",
        "front": "No Write Allocate (Write Around)",
        "back": "1. Write directly to memory\n2. Don't load into cache\n3. Use with write through",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Write Allocation"
      },
      {
        "id": "4-Write-Policies-Write-Allocation-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "1. **Write back + Write allocate:** Most common\n2. **Write through + No write allocate:** Less common",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Write Allocation"
      },
      {
        "id": "4-Write-Policies-Cache-Coherency-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "Multiple devices may access same memory.",
        "type": "definition",
        "section": "Write Policies",
        "subsection": "Cache Coherency"
      },
      {
        "id": "4-Write-Policies-Cache-Coherency-Scenarios",
        "title": "Scenarios",
        "front": "Scenarios",
        "back": "1. **I/O and CPU:** I/O writes to memory, cache has stale data\n2. **Multiple CPUs:** Each has own cache, one CPU writes, others have stale data",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Cache Coherency"
      },
      {
        "id": "4-Write-Policies-Cache-Coherency-Solutions",
        "title": "Solutions",
        "front": "Solutions",
        "back": "1. **Snooping:** Caches monitor bus for writes\n2. **Invalidation:** Mark cache lines as invalid when written by others\n3. **Update:** Update cache lines when written by others\n4. **Cache coherency protocols:** MESI (Modified, Exclusive, Shared, Invalid)",
        "type": "list",
        "section": "Write Policies",
        "subsection": "Cache Coherency"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Average-Memory-Access-Time--AMAT-",
        "title": "Average Memory Access Time (AMAT)",
        "front": "Average Memory Access Time (AMAT)",
        "back": "",
        "type": "concept",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Formula",
        "title": "Formula",
        "front": "Formula",
        "back": "AMAT = Hit Time + (Miss Rate × Miss Penalty)",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Components",
        "title": "Components",
        "front": "Components",
        "back": "1. **Hit Time:** Time to access cache (typically 1-10 cycles)\n2. **Miss Rate:** Fraction of accesses that miss (0.0 to 1.0)\n3. **Miss Penalty:** Time to handle miss (typically 10-100+ cycles)",
        "type": "list",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Example",
        "title": "Example",
        "front": "Example",
        "back": "Hit time = 1 cycle Miss rate = 5% = 0.05 Miss penalty = 100 cycles AMAT = 1 + 0.05 × 100 = 1 + 5 = 6 cycles",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "Even with 5% miss rate, average access time is 6x hit time!",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-CPU-Time",
        "title": "CPU Time",
        "front": "CPU Time",
        "back": "",
        "type": "concept",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Formula",
        "title": "Formula",
        "front": "Formula",
        "back": "CPU Time = (CPU execution cycles + Memory stall cycles) × Clock cycle time",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Memory-Stall-Cycles",
        "title": "Memory Stall Cycles",
        "front": "Memory Stall Cycles",
        "back": "Memory stall cycles = (Instruction miss cycles) + (Data miss cycles)",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Instruction-Miss-Cycles",
        "title": "Instruction Miss Cycles",
        "front": "Instruction Miss Cycles",
        "back": "Instruction miss cycles = (Instructions) × (I-cache miss rate) × (Miss penalty)",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Data-Miss-Cycles",
        "title": "Data Miss Cycles",
        "front": "Data Miss Cycles",
        "back": "Data miss cycles = (Instructions) × (Load/store fraction) × (D-cache miss rate) × (Miss penalty)",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Effective-CPI",
        "title": "Effective CPI",
        "front": "Effective CPI",
        "back": "",
        "type": "concept",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Formula",
        "title": "Formula",
        "front": "Formula",
        "back": "CPI_actual = CPI_base + (Memory stall cycles per instruction)",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Memory-Stall-Cycles-per-Instruction",
        "title": "Memory Stall Cycles per Instruction",
        "front": "Memory Stall Cycles per Instruction",
        "back": "Stall cycles = (I-cache miss rate × Miss penalty) + (Load/store fraction × D-cache miss rate × Miss penalty)",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Example",
        "title": "Example",
        "front": "Example",
        "back": "Base CPI = 3 I-cache miss rate = 4% = 0.04 D-cache miss rate = 8% = 0.08 Load/store fraction = 60% = 0.6 Miss penalty = 125 cycles CPI_actual = 3 + (0.04 × 125) + (0.6 × 0.08 × 125) = 3 + 5 + 6 = 14 cycles",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Performance-Metrics-Performance-Impact",
        "title": "Performance Impact",
        "front": "Performance Impact",
        "back": "Cache misses increase CPI from 3 to 14 (4.7x slower)!",
        "type": "definition",
        "section": "Cache Performance Analysis",
        "subsection": "Performance Metrics"
      },
      {
        "id": "4-Cache-Performance-Analysis-Improving-Cache-Performance-Strategies",
        "title": "Strategies",
        "front": "Strategies",
        "back": "1. **Reduce Miss Rate:**\n2. Larger cache\n3. Higher associativity\n4. Better replacement algorithm\n5. Larger block size (up to a point)\n6. **Reduce Miss Penalty:**\n7. Faster main memory\n8. Multi-level caches\n9. Write buffers\n10. **Reduce Hit Time:**\n11. Smaller cache\n12. Lower associativity\n13. On-chip cache",
        "type": "list",
        "section": "Cache Performance Analysis",
        "subsection": "Improving Cache Performance"
      },
      {
        "id": "4-Cache-Performance-Analysis-Improving-Cache-Performance-Trade-offs",
        "title": "Trade-offs",
        "front": "Trade-offs",
        "back": "1. Larger cache → Lower miss rate, but higher hit time\n2. Higher associativity → Lower miss rate, but higher hit time\n3. Larger blocks → Better spatial locality, but fewer blocks fit",
        "type": "list",
        "section": "Cache Performance Analysis",
        "subsection": "Improving Cache Performance"
      },
      {
        "id": "4-Multi-Level-Caches-Why-Multiple-Levels--Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "1. **Size:** Large enough for good hit rate\n2. **Speed:** Small enough for fast access",
        "type": "list",
        "section": "Multi-Level Caches",
        "subsection": "Why Multiple Levels?"
      },
      {
        "id": "4-Multi-Level-Caches-Why-Multiple-Levels--Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Use **multiple cache levels** with different characteristics.",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Why Multiple Levels?"
      },
      {
        "id": "4-Multi-Level-Caches-Two-Level-Cache-Organization-L1-Cache--Level-1-",
        "title": "L1 Cache (Level 1)",
        "front": "L1 Cache (Level 1)",
        "back": "1. **Location:** On CPU chip\n2. **Size:** Small (8-64 KB)\n3. **Speed:** Very fast (1-2 cycles)\n4. **Characteristics:**\n5. Split instruction and data caches\n6. Very close to processor\n7. Fastest access",
        "type": "list",
        "section": "Multi-Level Caches",
        "subsection": "Two-Level Cache Organization"
      },
      {
        "id": "4-Multi-Level-Caches-Two-Level-Cache-Organization-L2-Cache--Level-2-",
        "title": "L2 Cache (Level 2)",
        "front": "L2 Cache (Level 2)",
        "back": "1. **Location:** On CPU chip or off-chip\n2. **Size:** Medium (256 KB - 8 MB)\n3. **Speed:** Fast (5-20 cycles)\n4. **Characteristics:**\n5. Services misses from L1\n6. Larger than L1\n7. Slower than L1, but faster than main memory",
        "type": "list",
        "section": "Multi-Level Caches",
        "subsection": "Two-Level Cache Organization"
      },
      {
        "id": "4-Multi-Level-Caches-Two-Level-Cache-Organization-L3-Cache--Level-3-",
        "title": "L3 Cache (Level 3)",
        "front": "L3 Cache (Level 3)",
        "back": "1. **Location:** On CPU chip or off-chip\n2. **Size:** Large (8-64 MB)\n3. **Speed:** Moderate (20-50 cycles)\n4. **Characteristics:**\n5. Services misses from L2\n6. Shared among multiple cores\n7. Larger than L2",
        "type": "list",
        "section": "Multi-Level Caches",
        "subsection": "Two-Level Cache Organization"
      },
      {
        "id": "4-Multi-Level-Caches-Two-Level-Cache-Organization-Main-Memory",
        "title": "Main Memory",
        "front": "Main Memory",
        "back": "1. **Location:** Off-chip\n2. **Size:** Very large (GB)\n3. **Speed:** Slow (50-100+ cycles)\n4. **Characteristics:**\n5. Services misses from L3\n6. Largest capacity\n7. Slowest access",
        "type": "list",
        "section": "Multi-Level Caches",
        "subsection": "Two-Level Cache Organization"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Access-Flow",
        "title": "Access Flow",
        "front": "Access Flow",
        "back": "CPU Request Check L1 Cache Check L2 Cache Check L3 Cache Access Main Memory",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Cache Operation"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Hit-at-L1",
        "title": "Hit at L1",
        "front": "Hit at L1",
        "back": "Fastest (1-2 cycles)",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Cache Operation"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Hit-at-L2",
        "title": "Hit at L2",
        "front": "Hit at L2",
        "back": "Fast (5-20 cycles)",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Cache Operation"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Hit-at-L3",
        "title": "Hit at L3",
        "front": "Hit at L3",
        "back": "Moderate (20-50 cycles)",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Cache Operation"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Cache-Operation-Miss--Main-Memory-",
        "title": "Miss (Main Memory)",
        "front": "Miss (Main Memory)",
        "back": "Slow (50-100+ cycles)",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Cache Operation"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Performance-Example-Calculation",
        "title": "Example Calculation",
        "front": "Example Calculation",
        "back": "",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Performance"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Performance-Given",
        "title": "Given",
        "front": "Given",
        "back": "1. Base CPI = 1\n2. Clock rate = 4 GHz (0.25 ns per cycle)\n3. L1 miss rate = 2%\n4. L2 access time = 5 ns\n5. L2 global miss rate = 0.5%\n6. Main memory access time = 100 ns",
        "type": "list",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Performance"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Performance-Without-L2",
        "title": "Without L2",
        "front": "Without L2",
        "back": "Miss penalty = 100 ns / 0.25 ns = 400 cycles CPI = 1 + 0.02 × 400 = 9",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Performance"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Performance-With-L2",
        "title": "With L2",
        "front": "With L2",
        "back": "L1 miss, L2 hit penalty = 5 ns / 0.25 ns = 20 cycles L1 miss, L2 miss penalty = 100 ns / 0.25 ns = 400 cycles CPI = 1 + 0.02 × 20 + 0.005 × 400 = 1 + 0.4 + 2",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Performance"
      },
      {
        "id": "4-Multi-Level-Caches-Multi-Level-Performance-Performance-Improvement",
        "title": "Performance Improvement",
        "front": "Performance Improvement",
        "back": "9/3.4 = 2.6x faster!",
        "type": "definition",
        "section": "Multi-Level Caches",
        "subsection": "Multi-Level Performance"
      },
      {
        "id": "4-Multi-Level-Caches-Unified-vs--Split-Caches-Unified-Cache",
        "title": "Unified Cache",
        "front": "Unified Cache",
        "back": "1. Single cache for both instructions and data\n2. **Advantages:**\n3. Higher hit rate (balances load automatically)\n4. Simpler design\n5. **Disadvantages:**\n6. Contention between instruction fetch and data access\n7. Problematic for pipelining",
        "type": "list",
        "section": "Multi-Level Caches",
        "subsection": "Unified vs. Split Caches"
      },
      {
        "id": "4-Multi-Level-Caches-Unified-vs--Split-Caches-Split-Cache",
        "title": "Split Cache",
        "front": "Split Cache",
        "back": "1. Separate instruction cache (I-cache) and data cache (D-cache)\n2. **Advantages:**\n3. No contention\n4. Better for pipelining\n5. Can optimize each separately\n6. **Disadvantages:**\n7. Lower hit rate (fixed allocation)\n8. More complex",
        "type": "list",
        "section": "Multi-Level Caches",
        "subsection": "Unified vs. Split Caches"
      },
      {
        "id": "4-Multi-Level-Caches-Unified-vs--Split-Caches-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "1. **L1:** Split (I-cache and D-cache)\n2. **L2/L3:** Unified (shared)",
        "type": "list",
        "section": "Multi-Level Caches",
        "subsection": "Unified vs. Split Caches"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Semiconductor-Memory-Overview-Two-Main-Types",
        "title": "Two Main Types",
        "front": "Two Main Types",
        "back": "1. **RAM (Random Access Memory):**\n2. Read/Write\n3. Volatile\n4. Temporary storage\n5. Static (SRAM) or Dynamic (DRAM)\n6. **ROM (Read-Only Memory):**\n7. Read-only (mostly)\n8. Nonvolatile\n9. Permanent storage\n10. Various types (ROM, PROM, EPROM, EEPROM, Flash)",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Semiconductor Memory Overview"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "",
        "type": "concept",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Basic-Cell",
        "title": "Basic Cell",
        "front": "Basic Cell",
        "back": "1. **Capacitor:** Stores charge (1) or no charge (0)\n2. **Transistor:** Switch to access capacitor",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "1. **Write:** Apply voltage to bit line, activate address line, charge/discharge capacitor\n2. **Read:** Activate address line, sense charge on capacitor, restore charge",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "",
        "type": "concept",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Storage-Mechanism",
        "title": "Storage Mechanism",
        "front": "Storage Mechanism",
        "back": "1. Bits stored as **charge in capacitors**\n2. Presence/absence of charge = binary 1/0\n3. **Essentially analogue:** Level of charge determines value",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Key-Properties",
        "title": "Key Properties",
        "front": "Key Properties",
        "back": "1. **Charges leak:** Capacitors lose charge over time\n2. **Needs refreshing:** Periodic refresh to maintain data\n3. **Dynamic:** Stored charge leaks away even with power",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Refresh-Requirements",
        "title": "Refresh Requirements",
        "front": "Refresh Requirements",
        "back": "1. Must refresh every few milliseconds (typically 64 ms)\n2. Refresh circuit included on chip\n3. Refresh process:\n4. Disable chip\n5. Count through rows\n6. Read and write back each row\n7. Takes time, slows performance",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Simpler construction:** Fewer transistors per cell\n2. **Smaller per bit:** Higher density\n3. **Less expensive:** Lower cost\n4. **High capacity:** Good for main memory",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Needs refresh circuits:** Additional complexity\n2. **Slower:** Refresh overhead\n3. **More complex timing:** Refresh cycles",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Dynamic-RAM--DRAM--Use",
        "title": "Use",
        "front": "Use",
        "back": "**Main memory** (large capacity needed, cost-sensitive)",
        "type": "definition",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Dynamic RAM (DRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "",
        "type": "concept",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Static RAM (SRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Basic-Cell",
        "title": "Basic Cell",
        "front": "Basic Cell",
        "back": "1. **Flip-flop circuit:** Two cross-coupled inverters\n2. **Transistor arrangement:** Provides stable logic state\n3. **No capacitor:** State maintained by circuit",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Static RAM (SRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "1. **State 1:** C1 high, C2 low (T1, T4 off; T2, T3 on)\n2. **State 0:** C2 high, C1 low (T2, T3 off; T1, T4 on)\n3. **Write:** Apply value to bit lines\n4. **Read:** Sense value on bit line",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Static RAM (SRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "",
        "type": "concept",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Static RAM (SRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Storage-Mechanism",
        "title": "Storage Mechanism",
        "front": "Storage Mechanism",
        "back": "1. Bits stored as **on/off switches** (flip-flops)\n2. Digital: Clear 1 or 0 state\n3. **No charges to leak:** State maintained by circuit",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Static RAM (SRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Key-Properties",
        "title": "Key Properties",
        "front": "Key Properties",
        "back": "1. **No refresh needed:** Maintains state as long as powered\n2. **Faster:** No refresh overhead\n3. **More complex:** More transistors per cell",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Static RAM (SRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **No refresh needed:** Simpler operation\n2. **Faster:** Lower access time\n3. **Simpler timing:** No refresh cycles",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Static RAM (SRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **More complex construction:** More transistors\n2. **Larger per bit:** Lower density\n3. **More expensive:** Higher cost",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Static RAM (SRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-Static-RAM--SRAM--Use",
        "title": "Use",
        "front": "Use",
        "back": "**Cache memory** (speed critical, smaller capacity)",
        "type": "definition",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "Static RAM (SRAM)"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-SRAM-vs--DRAM-Comparison-Key-Insight",
        "title": "Key Insight",
        "front": "Key Insight",
        "back": "SRAM is faster but more expensive. DRAM is cheaper but slower. Use SRAM for small, fast cache; DRAM for large, cheap main memory.",
        "type": "definition",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "SRAM vs. DRAM Comparison"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-DRAM-Organization-Internal-Structure",
        "title": "Internal Structure",
        "front": "Internal Structure",
        "back": "1. Organized as **2D array** of cells\n2. **Row and column addressing:**\n3. Reduces number of address pins\n4. Multiplex row and column addresses\n5. Example: 2048 × 2048 × 4 bits = 16 Mbit chip\n6. Only 11 address pins needed (2^11 = 2048)",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "DRAM Organization"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-DRAM-Organization-Module-Organization",
        "title": "Module Organization",
        "front": "Module Organization",
        "back": "1. Multiple chips combined to form memory module\n2. Example: 256 KB module = 8 chips × 32 Kbit each\n3. Example: 1 MB module = 8 chips × 1 Mbit each",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "DRAM Organization"
      },
      {
        "id": "4-Internal-Memory--DRAM-and-SRAM-DRAM-Organization-Interleaved-Memory",
        "title": "Interleaved Memory",
        "front": "Interleaved Memory",
        "back": "1. Multiple memory banks\n2. Each bank can service requests independently\n3. Consecutive words stored in different banks\n4. **K banks** can service **K requests** simultaneously\n5. Increases memory bandwidth",
        "type": "list",
        "section": "Internal Memory: DRAM and SRAM",
        "subsection": "DRAM Organization"
      },
      {
        "id": "4-Error-Detection-and-Correction-Why-Error-Correction--Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "Memory can have errors.",
        "type": "definition",
        "section": "Error Detection and Correction",
        "subsection": "Why Error Correction?"
      },
      {
        "id": "4-Error-Detection-and-Correction-Why-Error-Correction--Types-of-Errors",
        "title": "Types of Errors",
        "front": "Types of Errors",
        "back": "1. **Hard Failure:**\n2. Permanent defect\n3. Manufacturing defect\n4. Physical damage\n5. **Soft Error:**\n6. Random, non-destructive\n7. Caused by:\n8. Alpha particles\n9. Cosmic rays\n10. Electrical noise\n11. No permanent damage\n12. Data corruption",
        "type": "list",
        "section": "Error Detection and Correction",
        "subsection": "Why Error Correction?"
      },
      {
        "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Detect and correct single-bit errors.",
        "type": "definition",
        "section": "Error Detection and Correction",
        "subsection": "Hamming Error Correcting Code"
      },
      {
        "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "1. Add **check bits** (redundancy) to data\n2. Check bits encode information about data bits\n3. Can detect and correct errors",
        "type": "list",
        "section": "Error Detection and Correction",
        "subsection": "Hamming Error Correcting Code"
      },
      {
        "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Hamming-Distance",
        "title": "Hamming Distance",
        "front": "Hamming Distance",
        "back": "1. Minimum number of bit positions in which two code words differ\n2. For single-bit error correction: Minimum distance = 3",
        "type": "list",
        "section": "Error Detection and Correction",
        "subsection": "Hamming Error Correcting Code"
      },
      {
        "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Implementation",
        "title": "Implementation",
        "front": "Implementation",
        "back": "1. Check bits placed at positions that are powers of 2 (1, 2, 4, 8, ...)\n2. Each check bit covers specific data bits\n3. Check bits calculated using XOR operations",
        "type": "list",
        "section": "Error Detection and Correction",
        "subsection": "Hamming Error Correcting Code"
      },
      {
        "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Example---8-bit-data",
        "title": "Example - 8-bit data",
        "front": "Example - 8-bit data",
        "back": "1. Need 4 check bits (positions 1, 2, 4, 8)\n2. Total: 12 bits (8 data + 4 check)",
        "type": "list",
        "section": "Error Detection and Correction",
        "subsection": "Hamming Error Correcting Code"
      },
      {
        "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Error-Detection",
        "title": "Error Detection",
        "front": "Error Detection",
        "back": "1. Recalculate check bits from data\n2. Compare with stored check bits\n3. If different: Error detected\n4. Pattern indicates which bit is wrong",
        "type": "list",
        "section": "Error Detection and Correction",
        "subsection": "Hamming Error Correcting Code"
      },
      {
        "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Error-Correction",
        "title": "Error Correction",
        "front": "Error Correction",
        "back": "1. Error pattern identifies bit position\n2. Flip that bit to correct error",
        "type": "list",
        "section": "Error Detection and Correction",
        "subsection": "Hamming Error Correcting Code"
      },
      {
        "id": "4-Error-Detection-and-Correction-Hamming-Error-Correcting-Code-Overhead",
        "title": "Overhead",
        "front": "Overhead",
        "back": "1. More bits needed (redundancy)\n2. Example: 8 data bits → 12 total bits (50% overhead)\n3. Larger data words: Lower overhead percentage",
        "type": "list",
        "section": "Error Detection and Correction",
        "subsection": "Hamming Error Correcting Code"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Traditional-DRAM-Limitations-Problems",
        "title": "Problems",
        "front": "Problems",
        "back": "1. **Internal architecture:** Slow access patterns\n2. **Interface:** Asynchronous, processor must wait\n3. **Bottleneck:** Memory interface limits performance",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Traditional DRAM Limitations"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Synchronous-DRAM--SDRAM--Key-Innovation",
        "title": "Key Innovation",
        "front": "Key Innovation",
        "back": "Access synchronized with external clock.",
        "type": "definition",
        "section": "Advanced DRAM Technologies",
        "subsection": "Synchronous DRAM (SDRAM)"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Synchronous-DRAM--SDRAM--Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "1. Address presented to RAM\n2. RAM finds data\n3. **CPU knows when data will be ready** (synchronized with clock)\n4. CPU doesn't have to wait (can do other work)",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Synchronous DRAM (SDRAM)"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Synchronous-DRAM--SDRAM--Burst-Mode",
        "title": "Burst Mode",
        "front": "Burst Mode",
        "back": "1. Set up stream of data\n2. Fire out data in block\n3. More efficient than single-word transfers",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Synchronous DRAM (SDRAM)"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Synchronous-DRAM--SDRAM--Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Predictable timing\n2. CPU can pipeline other operations\n3. Better bandwidth utilization",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Synchronous DRAM (SDRAM)"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--Key-Innovation",
        "title": "Key Innovation",
        "front": "Key Innovation",
        "back": "Sends data **twice per clock cycle**.",
        "type": "definition",
        "section": "Advanced DRAM Technologies",
        "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--How",
        "title": "How",
        "front": "How",
        "back": "1. Data transfer on **both rising and falling edge** of clock\n2. Doubles data rate compared to SDRAM",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--Achieves-Higher-Rates-Through",
        "title": "Achieves Higher Rates Through",
        "front": "Achieves Higher Rates Through",
        "back": "1. **Double clocking:** Data on both edges\n2. **Higher bus clock rate:** Faster interface\n3. **Buffering scheme:** Prefetch and buffer data",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--Generations",
        "title": "Generations",
        "front": "Generations",
        "back": "1. **DDR:** 2x SDRAM\n2. **DDR2:** 2x DDR (4x SDRAM)\n3. **DDR3:** 2x DDR2 (8x SDRAM)\n4. **DDR4:** 2x DDR3 (16x SDRAM)\n5. **DDR5:** 2x DDR4 (32x SDRAM)",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Double-Data-Rate-SDRAM--DDR-SDRAM--Each-Generation",
        "title": "Each Generation",
        "front": "Each Generation",
        "back": "1. Higher data rates\n2. Lower voltage (power efficiency)\n3. Better signal integrity\n4. More features",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Double Data Rate SDRAM (DDR SDRAM)"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Other-Advanced-Technologies-DDR-Variations",
        "title": "DDR Variations",
        "front": "DDR Variations",
        "back": "1. **GDDR:** Graphics DDR (for GPUs)\n2. **LPDDR:** Low Power DDR (for mobile devices)",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Other Advanced Technologies"
      },
      {
        "id": "4-Advanced-DRAM-Technologies-Other-Advanced-Technologies-Future-Technologies",
        "title": "Future Technologies",
        "front": "Future Technologies",
        "back": "1. **HBM (High Bandwidth Memory):** 3D stacked memory\n2. **HMC (Hybrid Memory Cube):** Advanced 3D memory",
        "type": "list",
        "section": "Advanced DRAM Technologies",
        "subsection": "Other Advanced Technologies"
      },
      {
        "id": "4-Key-Concepts-Summary-Memory-Hierarchy-Principles-Memory-Hierarchy-Principles",
        "title": "Memory Hierarchy Principles",
        "front": "Memory Hierarchy Principles",
        "back": "1. **Trade-offs:** Speed, capacity, cost cannot all be optimized simultaneously\n2. **Hierarchy Solution:** Use multiple levels with different characteristics\n3. **Locality:** Temporal and spatial locality enable hierarchy to work\n4. **Performance:** Average access time much closer to fast memory than slow memory",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Memory Hierarchy Principles"
      },
      {
        "id": "4-Key-Concepts-Summary-Cache-Fundamentals-Cache-Fundamentals",
        "title": "Cache Fundamentals",
        "front": "Cache Fundamentals",
        "back": "1. **Purpose:** Bridge speed gap between CPU and main memory\n2. **Operation:** Store recently accessed blocks\n3. **Metrics:** Hit rate, miss rate, miss penalty\n4. **Performance:** AMAT = Hit time + (Miss rate × Miss penalty)",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Cache Fundamentals"
      },
      {
        "id": "4-Key-Concepts-Summary-Cache-Design-Cache-Design",
        "title": "Cache Design",
        "front": "Cache Design",
        "back": "1. **Mapping:** Direct, associative, set-associative (trade-offs)\n2. **Replacement:** LRU most effective, but more complex\n3. **Write Policy:** Write back better performance, write through simpler\n4. **Size:** Larger = better hit rate, but slower hit time",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Cache Design"
      },
      {
        "id": "4-Key-Concepts-Summary-Memory-Technologies-Memory-Technologies",
        "title": "Memory Technologies",
        "front": "Memory Technologies",
        "back": "1. **DRAM:** Cheap, dense, needs refresh, used for main memory\n2. **SRAM:** Fast, expensive, no refresh, used for cache\n3. **Error Correction:** Hamming codes detect and correct errors\n4. **Advanced DRAM:** SDRAM, DDR improve performance",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Memory Technologies"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-1--Cache-Address-Breakdown-Question",
        "title": "Question",
        "front": "Question",
        "back": "A direct-mapped cache has 32 lines, block size 8 bytes. Main memory is 16 MB. How is a 24-bit address divided?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Cache Address Breakdown"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-1--Cache-Address-Breakdown-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Cache lines: 32 = 2^5 → 5 bits for line\n2. Block size: 8 bytes = 2^3 → 3 bits for word offset\n3. Tag: 24 - 5 - 3 = 16 bits",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Cache Address Breakdown"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-1--Cache-Address-Breakdown-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. Tag: 16 bits\n2. Line: 5 bits\n3. Word: 3 bits",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Cache Address Breakdown"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-2--AMAT-Calculation-Question",
        "title": "Question",
        "front": "Question",
        "back": "Cache has hit time 2 ns, miss rate 3%, miss penalty 50 ns. What is AMAT?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: AMAT Calculation"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-2--AMAT-Calculation-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "AMAT = Hit time + (Miss rate × Miss penalty) = 2 + (0.03 × 50)",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: AMAT Calculation"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-2--AMAT-Calculation-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "3.5 ns",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: AMAT Calculation"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-3--CPI-with-Cache-Question",
        "title": "Question",
        "front": "Question",
        "back": "Base CPI = 2, I-cache miss rate = 2%, D-cache miss rate = 5%, 40% loads/stores, miss penalty = 100 cycles. What is actual CPI?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: CPI with Cache"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-3--CPI-with-Cache-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Instruction miss cycles = 0.02 × 100 = 2 Data miss cycles = 0.4 × 0.05 × 100 = 2 CPI_actual = 2 + 2 + 2 = 6",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: CPI with Cache"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-3--CPI-with-Cache-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "CPI = 6",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: CPI with Cache"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-4--Set-Associative-Mapping-Question",
        "title": "Question",
        "front": "Question",
        "back": "4-way set associative cache, 64 lines total. How many sets? Block 100 maps to which set?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Set-Associative Mapping"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-4--Set-Associative-Mapping-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Total lines: 64\n2. Ways per set: 4\n3. Number of sets: 64 / 4 = 16 sets\n4. Set bits: log2(16) = 4 bits\n5. Block 100: 100 mod 16 = 4 → Set 4",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Set-Associative Mapping"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-4--Set-Associative-Mapping-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "16 sets, Block 100 → Set 4",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Set-Associative Mapping"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-5--Multi-Level-Cache-Question",
        "title": "Question",
        "front": "Question",
        "back": "L1 hit time = 1 cycle, miss rate = 5%, L2 hit time = 10 cycles, global miss rate = 1%, main memory = 100 cycles. What is AMAT?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Multi-Level Cache"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-5--Multi-Level-Cache-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "L1 hit: 0.95 × 1 = 0.95 cycles L1 miss, L2 hit: 0.05 × 0.8 × 10 = 0.4 cycles (80% of L1 misses hit in L2) L1 miss, L2 miss: 0.05 × 0.2 × 100 = 1.0 cycles (20% of L1 misses miss in L2) AMAT = 0.95 + 0.4 + 1.0 = 2.35 cycles",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Multi-Level Cache"
      },
      {
        "id": "4-Practice-Problems-and-Examples-Problem-5--Multi-Level-Cache-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **Understand Trade-offs:**\n2. Every design decision has pros and cons\n3. Larger cache vs. faster cache\n4. Higher associativity vs. lower cost\n5. **Master Calculations:**\n6. AMAT formula\n7. CPI with cache misses\n8. Address breakdown for different mappings\n9. **Visualize Cache Organization:**\n10. Draw cache structures\n11. Understand tag, line, word fields\n12. Trace cache operations\n13. **Compare Techniques:**\n14. Direct vs. associative vs. set-associative\n15. Write through vs. write back\n16. Replacement algorithms\n17. **Understand Locality:**\n18. Why hierarchy works\n19. How to exploit locality\n20. Impact on performance\n21. **Memory hierarchy** solves the speed/capacity/cost trade-off\n22. **Locality of reference** makes hierarchy effective\n23. **Cache memory** bridges the CPU-memory speed gap\n24. **Mapping techniques** balance flexibility and cost\n25. **Multi-level caches** further improve performance\n26. **DRAM and SRAM** serve different roles in the hierarchy\n27. Memory is often the performance bottleneck\n28. Cache design significantly impacts performance\n29. Memory hierarchy is fundamental to computer architecture",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Multi-Level Cache"
      }
    ]
  },
  "5": {
    "group": 5,
    "totalCards": 212,
    "sections": [
      {
        "section": "Detailed Study Guide",
        "subsections": [
          {
            "subsection": "General",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Detailed-Study-Guide--Detailed-Study-Guide",
                "title": "Detailed Study Guide",
                "front": "Detailed Study Guide",
                "back": "1. [Introduction to External Memory](#introduction-to-external-memory)\n2. [Magnetic Disk Fundamentals](#magnetic-disk-fundamentals)\n3. [Disk Organization and Formatting](#disk-organization-and-formatting)\n4. [Disk Performance Parameters](#disk-performance-parameters)\n5. [RAID Systems](#raid-systems)\n6. [Solid State Drives (SSDs)](#solid-state-drives-ssds)\n7. [Optical Storage](#optical-storage)\n8. [Magnetic Tape](#magnetic-tape)\n9. [Storage System Comparison](#storage-system-comparison)\n10. [Key Concepts Summary](#key-concepts-summary)\n11. [Practice Problems and Examples](#practice-problems-and-examples)",
                "type": "list",
                "section": "Detailed Study Guide",
                "subsection": ""
              }
            ]
          }
        ]
      },
      {
        "section": "Introduction to External Memory",
        "subsections": [
          {
            "subsection": "Purpose of External Memory",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Introduction-to-External-Memory-Purpose-of-External-Memory-Primary-Functions",
                "title": "Primary Functions",
                "front": "Primary Functions",
                "back": "1. **File Storage:**\n2. Programs\n3. Data files\n4. System settings\n5. User documents\n6. **Virtual Memory:**\n7. Extension of main memory\n8. Swap space for processes\n9. Allows larger programs than physical RAM\n10. **Backup and Archive:**\n11. Long-term data preservation\n12. Disaster recovery\n13. Historical data storage",
                "type": "list",
                "section": "Introduction to External Memory",
                "subsection": "Purpose of External Memory"
              }
            ]
          },
          {
            "subsection": "Storage System Characteristics",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Introduction-to-External-Memory-Storage-System-Characteristics-Performance-Metrics",
                "title": "Performance Metrics",
                "front": "Performance Metrics",
                "back": "1. **Throughput:**\n2. Data transfer rate (MB/s, GB/s)\n3. Improving, but **not as quickly as processor speed**\n4. Often the system bottleneck\n5. **Latency:**\n6. Access time (time to first byte)\n7. Improving but **very slowly**\n8. Critical for random access performance",
                "type": "list",
                "section": "Introduction to External Memory",
                "subsection": "Storage System Characteristics"
              },
              {
                "id": "5-Introduction-to-External-Memory-Storage-System-Characteristics-Reliability",
                "title": "Reliability",
                "front": "Reliability",
                "back": "1. Data integrity\n2. Error rates\n3. Mean time between failures (MTBF)\n4. Data recovery capabilities",
                "type": "list",
                "section": "Introduction to External Memory",
                "subsection": "Storage System Characteristics"
              },
              {
                "id": "5-Introduction-to-External-Memory-Storage-System-Characteristics-Diversity",
                "title": "Diversity",
                "front": "Diversity",
                "back": "1. **Magnetic disks:** Hard disk drives (HDDs)\n2. **Optical disks:** CD, DVD, Blu-ray\n3. **Magnetic tape:** Backup and archive\n4. **Solid state drives (SSDs):** Flash-based storage",
                "type": "list",
                "section": "Introduction to External Memory",
                "subsection": "Storage System Characteristics"
              }
            ]
          },
          {
            "subsection": "Storage Hierarchy Context",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-Introduction-to-External-Memory-Storage-Hierarchy-Context-External-Memory-in-the-Hierarchy",
                "title": "External Memory in the Hierarchy",
                "front": "External Memory in the Hierarchy",
                "back": "CPU Registers (fastest, smallest) Cache Memory Main Memory (DRAM) External Memory (HDD, SSD, Optical, Tape) ← We are here",
                "type": "definition",
                "section": "Introduction to External Memory",
                "subsection": "Storage Hierarchy Context"
              },
              {
                "id": "5-Introduction-to-External-Memory-Storage-Hierarchy-Context-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Largest capacity:** Terabytes to petabytes\n2. **Slowest access:** Milliseconds to seconds\n3. **Cheapest per bit:** Very low cost\n4. **Non-volatile:** Data persists without power",
                "type": "list",
                "section": "Introduction to External Memory",
                "subsection": "Storage Hierarchy Context"
              }
            ]
          }
        ]
      },
      {
        "section": "Magnetic Disk Fundamentals",
        "subsections": [
          {
            "subsection": "What is a Magnetic Disk?",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-Magnetic-Disk-Fundamentals-What-is-a-Magnetic-Disk--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Storage device using magnetic recording on rotating platters.",
                "type": "definition",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "What is a Magnetic Disk?"
              },
              {
                "id": "5-Magnetic-Disk-Fundamentals-What-is-a-Magnetic-Disk--Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **Hard disk drive (HDD):** Primary storage in computers\n2. **Floppy disk:** Historical, now obsolete",
                "type": "list",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "What is a Magnetic Disk?"
              }
            ]
          },
          {
            "subsection": "Physical Structure",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Magnetic-Disk-Fundamentals-Physical-Structure-Components",
                "title": "Components",
                "front": "Components",
                "back": "1. **Platter:**\n2. Circular disk\n3. Constructed of **nonmagnetic material** (substrate)\n4. Coated with **magnetizable material**\n5. **Substrate Material:**\n6. **Historical:** Aluminium\n7. **Modern:** Glass\n8. **Why glass?**\n9. Better uniformity of magnetic film surface\n10. Fewer surface defects (reduces read-write errors)\n11. Better stiffness (reduces disk dynamics)\n12. Greater shock resistance\n13. **Read/Write Head:**\n14. Conductive coil called a **head**\n15. May be single read/write head or separate ones\n16. During operation: **Head is stationary, platter rotates**",
                "type": "list",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Physical Structure"
              }
            ]
          },
          {
            "subsection": "Magnetic Read and Write Mechanisms",
            "cardCount": 7,
            "cards": [
              {
                "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Write-Operation",
                "title": "Write Operation",
                "front": "Write Operation",
                "back": "",
                "type": "concept",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Magnetic Read and Write Mechanisms"
              },
              {
                "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Process",
                "title": "Process",
                "front": "Process",
                "back": "1. Current flows through coil\n2. Produces magnetic field\n3. Pulses sent to head\n4. Magnetic pattern recorded on surface below head",
                "type": "list",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Magnetic Read and Write Mechanisms"
              },
              {
                "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Electrical current → Magnetic field → Magnetic pattern on disk",
                "type": "definition",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Magnetic Read and Write Mechanisms"
              },
              {
                "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Read-Operation",
                "title": "Read Operation",
                "front": "Read Operation",
                "back": "",
                "type": "concept",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Magnetic Read and Write Mechanisms"
              },
              {
                "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Traditional-Method",
                "title": "Traditional Method",
                "front": "Traditional Method",
                "back": "1. Magnetic field moving relative to coil produces current\n2. Same coil used for read and write\n3. Inductive reading",
                "type": "list",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Magnetic Read and Write Mechanisms"
              },
              {
                "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Contemporary-Method--MR---Magneto-Resistive-",
                "title": "Contemporary Method (MR - Magneto Resistive)",
                "front": "Contemporary Method (MR - Magneto Resistive)",
                "back": "1. **Separate read head** (close to write head)\n2. **Partially shielded magneto resistive (MR) sensor**\n3. **Electrical resistance depends on direction of magnetic field**\n4. **High frequency operation**\n5. More sensitive, better performance",
                "type": "list",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Magnetic Read and Write Mechanisms"
              },
              {
                "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Principle",
                "title": "Principle",
                "front": "Principle",
                "back": "Magnetic pattern → Electrical signal → Data read",
                "type": "definition",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Magnetic Read and Write Mechanisms"
              }
            ]
          },
          {
            "subsection": "Disk Geometry",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-Magnetic-Disk-Fundamentals-Disk-Geometry-Basic-Structure",
                "title": "Basic Structure",
                "front": "Basic Structure",
                "back": "1. **Tracks:** Concentric rings on platter surface\n2. **Sectors:** Divisions of tracks\n3. **Cylinders:** Same track position across all platters\n4. **Blocks:** Minimum unit of data transfer (typically one sector)",
                "type": "list",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Disk Geometry"
              },
              {
                "id": "5-Magnetic-Disk-Fundamentals-Disk-Geometry-Key-Points",
                "title": "Key Points",
                "front": "Key Points",
                "back": "1. Tracks are **concentric circles** (not spiral)\n2. Gaps between tracks prevent interference\n3. Same number of bits per track (variable packing density)\n4. Minimum block size = one sector",
                "type": "list",
                "section": "Magnetic Disk Fundamentals",
                "subsection": "Disk Geometry"
              }
            ]
          }
        ]
      },
      {
        "section": "Disk Organization and Formatting",
        "subsections": [
          {
            "subsection": "Track Organization",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-Disk-Organization-and-Formatting-Track-Organization-Tracks",
                "title": "Tracks",
                "front": "Tracks",
                "back": "1. **Concentric rings** on disk surface\n2. **Gaps between tracks:**\n3. Prevent errors from head misalignment\n4. Prevent interference between magnetic fields\n5. Can reduce gap to increase capacity (but increases error risk)",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Track Organization"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Track-Organization-Variable-Packing-Density",
                "title": "Variable Packing Density",
                "front": "Variable Packing Density",
                "back": "1. Same number of bits per track\n2. Outer tracks: Bits more spread out (lower density)\n3. Inner tracks: Bits closer together (higher density)",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Track Organization"
              }
            ]
          },
          {
            "subsection": "Sector Organization",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-Disk-Organization-and-Formatting-Sector-Organization-Sectors",
                "title": "Sectors",
                "front": "Sectors",
                "back": "1. Tracks divided into **sectors**\n2. **Minimum block size** = one sector\n3. Typical sector sizes: 512 bytes, 4 KB",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Sector Organization"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Sector-Organization-Sector-Addressing",
                "title": "Sector Addressing",
                "front": "Sector Addressing",
                "back": "1. Each sector has unique address\n2. Format: (Cylinder, Head, Sector) or logical block addressing (LBA)",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Sector Organization"
              }
            ]
          },
          {
            "subsection": "Disk Velocity and Data Density",
            "cardCount": 13,
            "cards": [
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-The-Problem",
                "title": "The Problem",
                "front": "The Problem",
                "back": "",
                "type": "concept",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Physical-Reality",
                "title": "Physical Reality",
                "front": "Physical Reality",
                "back": "1. Disk rotates at **constant angular velocity**\n2. **Outer tracks:** Longer circumference → bits pass head faster\n3. **Inner tracks:** Shorter circumference → bits pass head slower",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Challenge",
                "title": "Challenge",
                "front": "Challenge",
                "back": "Read all data bits at the same rate despite varying linear speed",
                "type": "definition",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Solutions",
                "title": "Solutions",
                "front": "Solutions",
                "back": "**1. Constant Angular Velocity (CAV)**",
                "type": "concept",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Method",
                "title": "Method",
                "front": "Method",
                "back": "1. Rotate disk at constant angular velocity\n2. **Pie-shaped sectors** and concentric tracks\n3. Individual tracks and sectors addressable\n4. Move head to track, wait for sector",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Waste of space on outer tracks:**\n2. Outer tracks have more physical space\n3. But store same number of bits as inner tracks\n4. Lower data density on outer tracks",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Simple addressing\n2. Easy to implement\n3. Predictable access",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. Inefficient use of disk space\n2. Lower overall capacity",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Method",
                "title": "Method",
                "front": "Method",
                "back": "1. Surface divided into **concentric zones**\n2. Each zone contains contiguous tracks\n3. **Within a zone:** Number of bits per track is constant\n4. **Between zones:** Outer zones have more bits per track",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Zones farther from center contain **more bits** (more sectors)\n2. Example:\n3. Innermost zones: 2 tracks, 9 sectors each\n4. Middle zones: 3 tracks, 12 sectors each\n5. Outermost zones: 4 tracks, 16 sectors each",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Better capacity utilization**\n2. Higher data density\n3. More efficient use of disk space",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **More complex circuitry**\n2. Variable sectors per track\n3. More complex addressing",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "Most modern disks use **zoned bit recording** for better capacity.",
                "type": "definition",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Velocity and Data Density"
              }
            ]
          },
          {
            "subsection": "Disk Formatting",
            "cardCount": 4,
            "cards": [
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Formatting-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Prepare disk for use by marking tracks and sectors.",
                "type": "definition",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Formatting"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Formatting-Format-Information",
                "title": "Format Information",
                "front": "Format Information",
                "back": "1. Additional information not available to user\n2. Marks start of tracks and sectors\n3. Includes:\n4. **Gap:** Space between sectors\n5. **Sync field:** Synchronization information\n6. **Address field:** Sector address\n7. **Data field:** Actual data\n8. **Error detection:** CRC or checksum",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Formatting"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Formatting-Low-Level-Formatting",
                "title": "Low-Level Formatting",
                "front": "Low-Level Formatting",
                "back": "1. Physical formatting of disk\n2. Creates track and sector structure\n3. Done at factory",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Formatting"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Disk-Formatting-High-Level-Formatting",
                "title": "High-Level Formatting",
                "front": "High-Level Formatting",
                "back": "1. Logical formatting\n2. Creates file system\n3. Done by operating system",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Disk Formatting"
              }
            ]
          },
          {
            "subsection": "Physical Characteristics",
            "cardCount": 11,
            "cards": [
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Head-Configuration",
                "title": "Head Configuration",
                "front": "Head Configuration",
                "back": "",
                "type": "concept",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-1--Fixed-Head-Disk",
                "title": "1. Fixed-Head Disk",
                "front": "1. Fixed-Head Disk",
                "back": "1. **One read-write head per track**\n2. Heads mounted on fixed rigid arm\n3. Arm extends across all tracks\n4. **No seek time** (head always at correct track)\n5. **Expensive** (many heads needed)\n6. **Fast access** (no head movement)",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-2--Moveable-Head-Disk",
                "title": "2. Moveable-Head Disk",
                "front": "2. Moveable-Head Disk",
                "back": "1. **One read-write head per side**\n2. Mounted on **movable arm**\n3. Arm can be extended or retracted\n4. **Seek time required** (head must move to track)\n5. **Cheaper** (fewer heads)\n6. **Slower access** (head movement needed)",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "Almost all disks use **moveable-head** configuration.",
                "type": "definition",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Removability",
                "title": "Removability",
                "front": "Removability",
                "back": "",
                "type": "concept",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-1--Non-Removable-Disk",
                "title": "1. Non-Removable Disk",
                "front": "1. Non-Removable Disk",
                "back": "1. Permanently mounted in disk drive\n2. Example: Hard disk in personal computer\n3. **Advantages:**\n4. Better performance (no mechanical connection issues)\n5. More reliable\n6. Higher capacity",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-2--Removable-Disk",
                "title": "2. Removable Disk",
                "front": "2. Removable Disk",
                "back": "1. Can be removed and replaced\n2. Example: Floppy disks (historical)\n3. **Advantages:**\n4. Unlimited storage capacity (by swapping disks)\n5. Easy data transfer between systems\n6. Portability",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "Most disks are **non-removable** for better performance and reliability.",
                "type": "definition",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Sidedness",
                "title": "Sidedness",
                "front": "Sidedness",
                "back": "",
                "type": "concept",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Double-Sided-Disk",
                "title": "Double-Sided Disk",
                "front": "Double-Sided Disk",
                "back": "1. Magnetizable coating on **both sides** of platter\n2. Two surfaces per platter\n3. Doubles capacity per platter",
                "type": "list",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              },
              {
                "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "All modern disks are **double-sided**.",
                "type": "definition",
                "section": "Disk Organization and Formatting",
                "subsection": "Physical Characteristics"
              }
            ]
          }
        ]
      },
      {
        "section": "Disk Performance Parameters",
        "subsections": [
          {
            "subsection": "Access Time Components",
            "cardCount": 17,
            "cards": [
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-To-read-or-write",
                "title": "To read or write",
                "front": "To read or write",
                "back": "1. Head must be positioned at desired **track**\n2. Head must wait for desired **sector** to rotate under it",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-1--Seek-Time",
                "title": "1. Seek Time",
                "front": "1. Seek Time",
                "back": "",
                "type": "concept",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Time to move head to correct track.",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Factors",
                "title": "Factors",
                "front": "Factors",
                "back": "1. **Distance:** How far head must travel\n2. **Speed:** How fast head moves\n3. **Acceleration/Deceleration:** Head must accelerate, then decelerate",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Typical-Values",
                "title": "Typical Values",
                "front": "Typical Values",
                "back": "1. **Average seek time:** 3-15 ms\n2. **Track-to-track:** 0.5-2 ms\n3. **Full stroke:** 10-25 ms",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Calculation",
                "title": "Calculation",
                "front": "Calculation",
                "back": "1. **Average seek time:** Time to move from random track to random track\n2. Typically: 1/3 of full stroke time",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-2--Rotational-Latency--Rotational-Delay-",
                "title": "2. Rotational Latency (Rotational Delay)",
                "front": "2. Rotational Latency (Rotational Delay)",
                "back": "",
                "type": "concept",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Time waiting for desired sector to rotate under head.",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Factors",
                "title": "Factors",
                "front": "Factors",
                "back": "1. **Disk rotation speed:** RPM (revolutions per minute)\n2. **Sector position:** Where sector is relative to head",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Calculation",
                "title": "Calculation",
                "front": "Calculation",
                "back": "1. **Average rotational latency:** Time for half rotation\n2. Formula: `Average latency = (1/2) × (60 seconds / RPM) × 1000 ms`",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Typical-Values",
                "title": "Typical Values",
                "front": "Typical Values",
                "back": "1. 5400 RPM: 5.56 ms average\n2. 7200 RPM: 4.17 ms average\n3. 10000 RPM: 3.00 ms average\n4. 15000 RPM: 2.00 ms average",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Example",
                "title": "Example",
                "front": "Example",
                "back": "7200 RPM disk: Time per revolution = 60/7200 = 0.00833 seconds = 8.33 ms Average latency = 8.33 / 2 = 4.17 ms",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-3--Access-Time",
                "title": "3. Access Time",
                "front": "3. Access Time",
                "back": "",
                "type": "concept",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Formula",
                "title": "Formula",
                "front": "Formula",
                "back": "Access Time = Seek Time + Rotational Latency",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Time to get into position to read or write.",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Does-NOT-include",
                "title": "Does NOT include",
                "front": "Does NOT include",
                "back": "Actual data transfer time.",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              },
              {
                "id": "5-Disk-Performance-Parameters-Access-Time-Components-Typical-Values",
                "title": "Typical Values",
                "front": "Typical Values",
                "back": "1. Average: 5-20 ms\n2. Depends on disk speed and seek characteristics",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Access Time Components"
              }
            ]
          },
          {
            "subsection": "Transfer Time",
            "cardCount": 5,
            "cards": [
              {
                "id": "5-Disk-Performance-Parameters-Transfer-Time-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Time to actually transfer data.",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Transfer Time"
              },
              {
                "id": "5-Disk-Performance-Parameters-Transfer-Time-Factors",
                "title": "Factors",
                "front": "Factors",
                "back": "1. **Disk rotation speed:** How fast data passes under head\n2. **Sectors per track:** How much data per track\n3. **Amount of data:** How many sectors to transfer",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Transfer Time"
              },
              {
                "id": "5-Disk-Performance-Parameters-Transfer-Time-Calculation",
                "title": "Calculation",
                "front": "Calculation",
                "back": "Transfer Time = (Number of sectors to transfer) / (Sectors per track × RPM / 60)",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Transfer Time"
              },
              {
                "id": "5-Disk-Performance-Parameters-Transfer-Time-Or",
                "title": "Or",
                "front": "Or",
                "back": "Transfer Time = (Data size) / (Transfer rate)",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Transfer Time"
              },
              {
                "id": "5-Disk-Performance-Parameters-Transfer-Time-Typical-Transfer-Rates",
                "title": "Typical Transfer Rates",
                "front": "Typical Transfer Rates",
                "back": "1. Sequential: 100-200 MB/s (modern HDDs)\n2. Random: Much lower (1-10 MB/s)",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Transfer Time"
              }
            ]
          },
          {
            "subsection": "Complete I/O Time",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-Disk-Performance-Parameters-Complete-I-O-Time-Total-Time-for-Disk-I-O",
                "title": "Total Time for Disk I/O",
                "front": "Total Time for Disk I/O",
                "back": "Total Time = Seek Time + Rotational Latency + Transfer Time",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Complete I/O Time"
              },
              {
                "id": "5-Disk-Performance-Parameters-Complete-I-O-Time-Example",
                "title": "Example",
                "front": "Example",
                "back": "Seek time: 8 ms Rotational latency: 4 ms Transfer time: 2 ms (for 1 sector) Total: 14 ms",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Complete I/O Time"
              }
            ]
          },
          {
            "subsection": "Performance Example",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Disk-Performance-Parameters-Performance-Example-Given",
                "title": "Given",
                "front": "Given",
                "back": "1. 1000 cylinders\n2. 10 sectors per track\n3. Head assembly at cylinder 0 initially\n4. Head moves at 10 μs/cylinder\n5. Disk rotates 100 times/second",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Performance Example"
              },
              {
                "id": "5-Disk-Performance-Parameters-Performance-Example-Calculate-average-time-to-read-a-randomly-chosen-byte",
                "title": "Calculate average time to read a randomly chosen byte",
                "front": "Calculate average time to read a randomly chosen byte",
                "back": "1. Average distance: 1000/3 = 333 cylinders\n2. Seek time: 333 × 10 μs = 3.33 ms\n3. Time per revolution: 1/100 = 0.01 seconds = 10 ms\n4. Average latency: 10/2 = 5 ms\n5. One sector: 1/10 of track\n6. Time per track: 10 ms\n7. Transfer time: 10/10 = 1 ms",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Performance Example"
              },
              {
                "id": "5-Disk-Performance-Parameters-Performance-Example-Total",
                "title": "Total",
                "front": "Total",
                "back": "Total = 3.33 + 5 + 1 = 9.33 ms",
                "type": "definition",
                "section": "Disk Performance Parameters",
                "subsection": "Performance Example"
              }
            ]
          },
          {
            "subsection": "Improving Disk Performance",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Disk-Performance-Parameters-Improving-Disk-Performance-Strategies",
                "title": "Strategies",
                "front": "Strategies",
                "back": "1. **Faster Rotation:**\n2. Reduces rotational latency\n3. Increases transfer rate\n4. More expensive, more power\n5. **Higher Data Density:**\n6. More data per track\n7. Higher transfer rates\n8. Better capacity\n9. **Multiple Platters:**\n10. More surfaces\n11. More capacity\n12. Can access multiple surfaces in parallel\n13. **Cache:**\n14. Buffer frequently accessed data\n15. Reduces access time for cached data\n16. **Disk Scheduling:**\n17. Optimize order of requests\n18. Minimize seek time\n19. Examples: FCFS, SSTF, SCAN, C-SCAN",
                "type": "list",
                "section": "Disk Performance Parameters",
                "subsection": "Improving Disk Performance"
              }
            ]
          }
        ]
      },
      {
        "section": "RAID Systems",
        "subsections": [
          {
            "subsection": "What is RAID?",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-RAID-Systems-What-is-RAID--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "**Redundant Array of Independent Disks**",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "What is RAID?"
              },
              {
                "id": "5-RAID-Systems-What-is-RAID--Key-Concepts",
                "title": "Key Concepts",
                "front": "Key Concepts",
                "back": "1. **Not a hierarchy:** All disks at same level\n2. **Logical drive:** Set of physical disks viewed as single logical drive by OS\n3. **Data distribution:** Data distributed across physical drives\n4. **Redundancy:** Can use redundant capacity for parity information",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "What is RAID?"
              },
              {
                "id": "5-RAID-Systems-What-is-RAID--Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "1. **Performance:** Increase speed through parallel access\n2. **Reliability:** Provide fault tolerance through redundancy\n3. **Capacity:** Combine multiple disks into larger volume",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "What is RAID?"
              }
            ]
          },
          {
            "subsection": "RAID Levels Overview",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-RAID-Systems-RAID-Levels-Overview-Seven-RAID-Levels",
                "title": "Seven RAID Levels",
                "front": "Seven RAID Levels",
                "back": "1. **RAID 0:** Striping (no redundancy)\n2. **RAID 1:** Mirroring\n3. **RAID 2:** Bit-level striping with Hamming code\n4. **RAID 3:** Byte-level striping with dedicated parity\n5. **RAID 4:** Block-level striping with dedicated parity\n6. **RAID 5:** Block-level striping with distributed parity\n7. **RAID 6:** Block-level striping with dual distributed parity",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID Levels Overview"
              },
              {
                "id": "5-RAID-Systems-RAID-Levels-Overview-Common-Levels",
                "title": "Common Levels",
                "front": "Common Levels",
                "back": "RAID 0, 1, 5, 6 (most commonly used)",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID Levels Overview"
              }
            ]
          },
          {
            "subsection": "RAID 0: Striping (No Redundancy)",
            "cardCount": 7,
            "cards": [
              {
                "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Data **striped** across all disks.",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 0: Striping (No Redundancy)"
              },
              {
                "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Organization",
                "title": "Organization",
                "front": "Organization",
                "back": "1. **Round-robin striping:**\n2. Stripe 0 → Disk 0\n3. Stripe 1 → Disk 1\n4. Stripe 2 → Disk 2\n5. Stripe 3 → Disk 0 (wraps around)\n6. And so on...",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 0: Striping (No Redundancy)"
              },
              {
                "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **No redundancy:** No fault tolerance\n2. **No parity:** No error correction\n3. **Performance improvement:**\n4. Multiple data requests probably not on same disk\n5. Disks seek in parallel\n6. Set of data likely striped across multiple disks",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 0: Striping (No Redundancy)"
              },
              {
                "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **High performance:** Parallel access\n2. **Full capacity:** No space lost to redundancy\n3. **Simple:** Easy to implement",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 0: Striping (No Redundancy)"
              },
              {
                "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **No fault tolerance:** One disk failure = data loss\n2. **No reliability improvement:** Actually worse (more failure points)",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 0: Striping (No Redundancy)"
              },
              {
                "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. Performance-critical applications\n2. Where data can be easily recreated\n3. Temporary data",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 0: Striping (No Redundancy)"
              },
              {
                "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Capacity",
                "title": "Capacity",
                "front": "Capacity",
                "back": "N disks → N × disk capacity (no overhead)",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 0: Striping (No Redundancy)"
              }
            ]
          },
          {
            "subsection": "RAID 1: Mirroring",
            "cardCount": 9,
            "cards": [
              {
                "id": "5-RAID-Systems-RAID-1--Mirroring-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "**Mirrored disks** - two copies of each stripe on separate disks.",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 1: Mirroring"
              },
              {
                "id": "5-RAID-Systems-RAID-1--Mirroring-Organization",
                "title": "Organization",
                "front": "Organization",
                "back": "1. Data striped across disks\n2. **2 copies** of each stripe on separate disks\n3. Example: Stripe 0 on Disk 0 and Disk 1 (mirrored)",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 1: Mirroring"
              },
              {
                "id": "5-RAID-Systems-RAID-1--Mirroring-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Full redundancy:** Complete copy of data\n2. **Simple recovery:** Swap faulty disk and re-mirror\n3. **No downtime:** Can continue operating with one disk failed",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 1: Mirroring"
              },
              {
                "id": "5-RAID-Systems-RAID-1--Mirroring-Read-Performance",
                "title": "Read Performance",
                "front": "Read Performance",
                "back": "1. **Read from either disk:**\n2. Can balance read load\n3. Can read from faster disk\n4. Potentially 2x read performance",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 1: Mirroring"
              },
              {
                "id": "5-RAID-Systems-RAID-1--Mirroring-Write-Performance",
                "title": "Write Performance",
                "front": "Write Performance",
                "back": "1. **Write to both disks:**\n2. Must wait for both writes\n3. No write performance improvement\n4. May be slightly slower",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 1: Mirroring"
              },
              {
                "id": "5-RAID-Systems-RAID-1--Mirroring-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **High reliability:** Can survive one disk failure\n2. **Fast recovery:** Simple mirror rebuild\n3. **Good read performance:** Can read from either disk",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 1: Mirroring"
              },
              {
                "id": "5-RAID-Systems-RAID-1--Mirroring-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Expensive:** 50% capacity overhead (2 disks for 1 disk capacity)\n2. **No write performance improvement:** Must write to both",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 1: Mirroring"
              },
              {
                "id": "5-RAID-Systems-RAID-1--Mirroring-Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. Critical data\n2. Applications requiring high availability\n3. Small arrays (2 disks)",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 1: Mirroring"
              },
              {
                "id": "5-RAID-Systems-RAID-1--Mirroring-Capacity",
                "title": "Capacity",
                "front": "Capacity",
                "back": "N disks → (N/2) × disk capacity (50% overhead)",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 1: Mirroring"
              }
            ]
          },
          {
            "subsection": "RAID 2: Bit-Level Striping with Hamming Code",
            "cardCount": 5,
            "cards": [
              {
                "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Very small strips (often single byte/word) with Hamming error correction.",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
              },
              {
                "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Organization",
                "title": "Organization",
                "front": "Organization",
                "back": "1. **Bit-level striping:** Data split at bit level\n2. **Error correction:** Hamming code calculated across corresponding bits\n3. **Multiple parity disks:** Store Hamming code error correction",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
              },
              {
                "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Lots of redundancy:** Many parity disks needed\n2. **Expensive:** High overhead\n3. **Not used:** Rarely implemented",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
              },
              {
                "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Why-Not-Used",
                "title": "Why Not Used",
                "front": "Why Not Used",
                "back": "1. Modern disks have built-in error correction\n2. Overhead too high\n3. Complexity not justified",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
              },
              {
                "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Capacity",
                "title": "Capacity",
                "front": "Capacity",
                "back": "High overhead (many parity disks)",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
              }
            ]
          },
          {
            "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity",
            "cardCount": 7,
            "cards": [
              {
                "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Similar to RAID 2, but **only one redundant disk** (parity disk).",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Organization",
                "title": "Organization",
                "front": "Organization",
                "back": "1. **Byte-level striping:** Data split at byte level\n2. **Single parity disk:** Stores parity for each set of corresponding bytes\n3. **Simple parity:** XOR of corresponding bytes",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **One parity disk:** No matter how large the array\n2. **Data reconstruction:** Failed drive data can be reconstructed from surviving data and parity\n3. **Synchronous access:** All disks must be accessed together",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Low overhead:** Only one disk for parity\n2. **Good for large sequential transfers**",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Parity disk bottleneck:** All writes must update parity disk\n2. **Synchronous access:** Less flexible than independent disk access",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. Large sequential data transfers\n2. Applications with synchronized access patterns",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Capacity",
                "title": "Capacity",
                "front": "Capacity",
                "back": "N disks → (N-1) × disk capacity (1 disk overhead)",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
              }
            ]
          },
          {
            "subsection": "RAID 4: Block-Level Striping with Dedicated Parity",
            "cardCount": 7,
            "cards": [
              {
                "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "**Large stripes** (blocks) with **dedicated parity disk**.",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Organization",
                "title": "Organization",
                "front": "Organization",
                "back": "1. **Block-level striping:** Data split at block level\n2. **Independent disk operation:** Each disk operates independently\n3. **Dedicated parity disk:** All parity stored on one disk\n4. **Bit-by-bit parity:** Parity calculated across stripes on each disk",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Good for high I/O request rate:**\n2. Separate I/O requests can be satisfied in parallel\n3. Independent disk access\n4. **Large stripes:** Better for random access",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Independent access:** Disks can operate independently\n2. **Good random I/O:** Multiple requests in parallel\n3. **Low overhead:** Only one parity disk",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Parity disk bottleneck:**\n2. Every write must update parity disk\n3. Parity disk becomes bottleneck\n4. Limits write performance",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. High I/O rate applications\n2. Random access patterns\n3. Read-heavy workloads",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Capacity",
                "title": "Capacity",
                "front": "Capacity",
                "back": "N disks → (N-1) × disk capacity (1 disk overhead)",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
              }
            ]
          },
          {
            "subsection": "RAID 5: Block-Level Striping with Distributed Parity",
            "cardCount": 8,
            "cards": [
              {
                "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Like RAID 4, but **parity striped across all disks**.",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Organization",
                "title": "Organization",
                "front": "Organization",
                "back": "1. **Block-level striping:** Data split at block level\n2. **Distributed parity:** Parity striped across all disks\n3. **Round-robin allocation:** Parity stripe rotates among disks",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Avoids RAID 4 bottleneck:**\n2. Parity distributed, not on single disk\n3. Better write performance\n4. Better load balancing",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **No parity disk bottleneck:** Parity distributed\n2. **Good performance:** Both read and write\n3. **Good reliability:** Can survive one disk failure\n4. **Commonly used:** Very popular",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Write penalty:** Must read old data and parity, calculate new parity, write both\n2. **Complexity:** More complex than RAID 1",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. **Network servers:** Very common\n2. General-purpose storage\n3. Balanced read/write workloads",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Capacity",
                "title": "Capacity",
                "front": "Capacity",
                "back": "N disks → (N-1) × disk capacity (1 disk overhead)",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Example",
                "title": "Example",
                "front": "Example",
                "back": "4 disks, parity distribution: Disk 0: Data, Data, Parity, Data Disk 1: Data, Parity, Data, Data Disk 2: Parity, Data, Data, Data Disk 3: Data, Data, Data, Parity",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
              }
            ]
          },
          {
            "subsection": "RAID 6: Dual Distributed Parity",
            "cardCount": 7,
            "cards": [
              {
                "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "**Two parity calculations** stored in separate blocks on different disks.",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 6: Dual Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Organization",
                "title": "Organization",
                "front": "Organization",
                "back": "1. **Block-level striping:** Data split at block level\n2. **Dual parity:** Two independent parity calculations\n3. **Distributed:** Both parities distributed across disks",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 6: Dual Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **High data availability:**\n2. Can survive **two disk failures**\n3. Three disks must fail for data loss\n4. **Significant write penalty:**\n5. Must calculate and write two parities\n6. More complex than RAID 5",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 6: Dual Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Very high reliability:** Can survive two failures\n2. **Good for critical data:** Maximum fault tolerance",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 6: Dual Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **High write penalty:** Two parities to calculate/write\n2. **Higher overhead:** Two disks for parity\n3. **More complex:** More calculations needed",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 6: Dual Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. Critical data requiring maximum reliability\n2. Large arrays (where two failures more likely)\n3. Long-term archival storage",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID 6: Dual Distributed Parity"
              },
              {
                "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Capacity",
                "title": "Capacity",
                "front": "Capacity",
                "back": "N disks → (N-2) × disk capacity (2 disks overhead)",
                "type": "definition",
                "section": "RAID Systems",
                "subsection": "RAID 6: Dual Distributed Parity"
              }
            ]
          },
          {
            "subsection": "RAID Comparison Summary",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-RAID-Systems-RAID-Comparison-Summary-Key-Trade-offs",
                "title": "Key Trade-offs",
                "front": "Key Trade-offs",
                "back": "1. **Performance vs. Reliability:** RAID 0 fast but no redundancy; RAID 1/5/6 slower but reliable\n2. **Capacity vs. Reliability:** More redundancy = less usable capacity\n3. **Write Performance:** Parity calculations slow writes (RAID 5/6)",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID Comparison Summary"
              },
              {
                "id": "5-RAID-Systems-RAID-Comparison-Summary-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "1. **RAID 0:** Performance-critical, non-critical data\n2. **RAID 1:** Small arrays, critical data\n3. **RAID 5:** Most common for general-purpose storage\n4. **RAID 6:** Large arrays, maximum reliability",
                "type": "list",
                "section": "RAID Systems",
                "subsection": "RAID Comparison Summary"
              }
            ]
          }
        ]
      },
      {
        "section": "Solid State Drives (SSDs)",
        "subsections": [
          {
            "subsection": "What is an SSD?",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Solid-State-Drives--SSDs--What-is-an-SSD--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "**Solid State Drive** - storage device using **electronic circuitry** (semiconductors) instead of mechanical components.",
                "type": "definition",
                "section": "Solid State Drives (SSDs)",
                "subsection": "What is an SSD?"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--What-is-an-SSD--Technology",
                "title": "Technology",
                "front": "Technology",
                "back": "Uses **NAND flash memory** (same as USB drives, memory cards).",
                "type": "definition",
                "section": "Solid State Drives (SSDs)",
                "subsection": "What is an SSD?"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--What-is-an-SSD--Significance",
                "title": "Significance",
                "front": "Significance",
                "back": "1. Most significant development to complement or replace HDDs\n2. Used for both internal and external memory\n3. Increasingly competitive with HDDs as cost drops and performance increases",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "What is an SSD?"
              }
            ]
          },
          {
            "subsection": "SSD Advantages over HDD",
            "cardCount": 6,
            "cards": [
              {
                "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-1--High-IOPS--Input-Output-Operations-Per-Second-",
                "title": "1. High IOPS (Input/Output Operations Per Second)",
                "front": "1. High IOPS (Input/Output Operations Per Second)",
                "back": "1. Much higher random I/O performance\n2. Can handle many small requests efficiently",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "SSD Advantages over HDD"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-2--Durability",
                "title": "2. Durability",
                "front": "2. Durability",
                "back": "1. **Less susceptible to physical shock and vibration:**\n2. No moving parts\n3. Can withstand drops and impacts\n4. Better for mobile devices",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "SSD Advantages over HDD"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-3--Longer-Lifespan",
                "title": "3. Longer Lifespan",
                "front": "3. Longer Lifespan",
                "back": "1. **Not susceptible to mechanical wear:**\n2. No moving parts to wear out\n3. No head crashes\n4. No bearing failures",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "SSD Advantages over HDD"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-4--Lower-Power-Consumption",
                "title": "4. Lower Power Consumption",
                "front": "4. Lower Power Consumption",
                "back": "1. **Considerably less power** than comparable HDDs\n2. Important for laptops, mobile devices\n3. Lower energy costs",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "SSD Advantages over HDD"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-5--Quieter-and-Cooler",
                "title": "5. Quieter and Cooler",
                "front": "5. Quieter and Cooler",
                "back": "1. **No moving parts:** Silent operation\n2. **Less heat:** Lower power = less heat\n3. **Less space required:** Smaller form factors",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "SSD Advantages over HDD"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-6--Lower-Access-Times-and-Latency",
                "title": "6. Lower Access Times and Latency",
                "front": "6. Lower Access Times and Latency",
                "back": "1. **Over 10 times faster** than spinning disks\n2. **No seek time:** No head movement\n3. **No rotational latency:** No waiting for rotation\n4. **Random access:** Much faster than HDDs",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "SSD Advantages over HDD"
              }
            ]
          },
          {
            "subsection": "SSD Architecture",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Solid-State-Drives--SSDs--SSD-Architecture-Components",
                "title": "Components",
                "front": "Components",
                "back": "1. **Interface to Host System:**\n2. SATA, PCIe, NVMe\n3. Connects SSD to computer\n4. **Controller:**\n5. Manages flash memory\n6. Handles wear leveling\n7. Error correction\n8. Address translation\n9. **Addressing:**\n10. Logical to physical address mapping\n11. Handles bad block management\n12. **Data Buffer/Cache:**\n13. RAM buffer for temporary storage\n14. Improves performance\n15. **Error Correction:**\n16. Detects and corrects errors\n17. Critical for flash memory reliability\n18. **Flash Memory Components:**\n19. NAND flash chips\n20. Organized in pages and blocks",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "SSD Architecture"
              }
            ]
          },
          {
            "subsection": "Practical Issues with SSDs",
            "cardCount": 12,
            "cards": [
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-1--Write-Endurance",
                "title": "1. Write Endurance",
                "front": "1. Write Endurance",
                "back": "",
                "type": "concept",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "1. **Flash memory becomes unusable after certain number of writes**\n2. Each cell can only be written finite number of times\n3. Typical: 1,000 to 100,000 write cycles per cell",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Impact",
                "title": "Impact",
                "front": "Impact",
                "back": "1. SSD performance may slow down as device is used\n2. Cells wear out over time\n3. Eventually, SSD may fail",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-2--Write-Amplification",
                "title": "2. Write Amplification",
                "front": "2. Write Amplification",
                "back": "",
                "type": "concept",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "1. **To write a page onto flash memory:**\n2. Entire **block** must be read from flash\n3. Placed in RAM buffer\n4. Entire block of flash memory must be **erased**\n5. Entire block from buffer written back to flash",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Result",
                "title": "Result",
                "front": "Result",
                "back": "1. Writing small amount of data requires rewriting entire block\n2. **Write amplification:** More data written than requested\n3. Reduces performance and increases wear",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-3--Solutions-and-Techniques",
                "title": "3. Solutions and Techniques",
                "front": "3. Solutions and Techniques",
                "back": "",
                "type": "concept",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Wear-Leveling",
                "title": "Wear Leveling",
                "front": "Wear Leveling",
                "back": "1. **Distribute writes evenly** across all blocks\n2. Prevents some blocks from wearing out faster\n3. Extends SSD lifespan",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Caching",
                "title": "Caching",
                "front": "Caching",
                "back": "1. **Front-end flash with cache** (RAM buffer)\n2. **Delay and group write operations**\n3. Reduces number of erase operations\n4. Improves performance",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Over-Provisioning",
                "title": "Over-Provisioning",
                "front": "Over-Provisioning",
                "back": "1. More flash memory than advertised capacity\n2. Provides spare blocks for wear leveling\n3. Handles bad blocks",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-TRIM-Command",
                "title": "TRIM Command",
                "front": "TRIM Command",
                "back": "1. OS tells SSD which blocks are no longer needed\n2. Allows SSD to erase blocks in advance\n3. Improves write performance",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Lifetime-Estimation",
                "title": "Lifetime Estimation",
                "front": "Lifetime Estimation",
                "back": "1. **Most flash devices estimate remaining lifetime**\n2. Systems can anticipate failure\n3. Take preemptive action (backup, replace)",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Practical Issues with SSDs"
              }
            ]
          },
          {
            "subsection": "Hybrid Magnetic-Flash Systems",
            "cardCount": 6,
            "cards": [
              {
                "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Combine HDD and SSD for best of both worlds.",
                "type": "definition",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Hybrid Magnetic-Flash Systems"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Magnetic-Disk-Characteristics",
                "title": "Magnetic Disk Characteristics",
                "front": "Magnetic Disk Characteristics",
                "back": "1. **Low $/GB:** Very cheap per gigabyte\n2. **Huge capacity:** Terabytes available\n3. **Power hungry:** High power consumption\n4. **Slow:** Mechanical movement (seek, rotation)\n5. **Sensitive to impacts:** Head crashes possible",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Hybrid Magnetic-Flash Systems"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Flash-Characteristics",
                "title": "Flash Characteristics",
                "front": "Flash Characteristics",
                "back": "1. **Fast:** No mechanical delays\n2. **Power efficient:** Low power consumption\n3. **No moving parts:** Robust\n4. **Expensive:** Higher $/GB",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Hybrid Magnetic-Flash Systems"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Hybrid-Solution",
                "title": "Hybrid Solution",
                "front": "Hybrid Solution",
                "back": "1. **Use flash as cache for disk**\n2. **Most data on disk:** Cheap, large capacity\n3. **Frequently accessed data on flash:** Fast access\n4. **Automatic management:** System moves hot data to flash",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Hybrid Magnetic-Flash Systems"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Benefits",
                "title": "Benefits",
                "front": "Benefits",
                "back": "1. **Best of both:** Speed of SSD, capacity of HDD\n2. **Cost-effective:** Smaller flash cache, large HDD\n3. **Transparent:** Works automatically",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Hybrid Magnetic-Flash Systems"
              },
              {
                "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Example",
                "title": "Example",
                "front": "Example",
                "back": "1. 1 TB HDD + 32 GB flash cache\n2. Frequently accessed files cached in flash\n3. Rest of data on HDD",
                "type": "list",
                "section": "Solid State Drives (SSDs)",
                "subsection": "Hybrid Magnetic-Flash Systems"
              }
            ]
          }
        ]
      },
      {
        "section": "Optical Storage",
        "subsections": [
          {
            "subsection": "Optical Disk Products",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-Optical-Storage-Optical-Disk-Products-Types",
                "title": "Types",
                "front": "Types",
                "back": "1. **CD (Compact Disc):** 700 MB\n2. **DVD (Digital Versatile Disc):** 4.7-17 GB\n3. **Blu-ray:** 25-50 GB\n4. **HD DVD:** (discontinued)",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "Optical Disk Products"
              },
              {
                "id": "5-Optical-Storage-Optical-Disk-Products-Categories",
                "title": "Categories",
                "front": "Categories",
                "back": "1. **Read-only:** CD-ROM, DVD-ROM, BD-ROM\n2. **Write-once:** CD-R, DVD-R, BD-R\n3. **Rewritable:** CD-RW, DVD-RW, BD-RE",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "Optical Disk Products"
              }
            ]
          },
          {
            "subsection": "CD-ROM (Compact Disk Read Only Memory)",
            "cardCount": 8,
            "cards": [
              {
                "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--History",
                "title": "History",
                "front": "History",
                "back": "1. Originally developed for audio\n2. Adapted for computer data storage",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "CD-ROM (Compact Disk Read Only Memory)"
              },
              {
                "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Physical-Structure",
                "title": "Physical Structure",
                "front": "Physical Structure",
                "back": "1. **Polycarbonate disk** coated with highly reflective coat (usually aluminium)\n2. **Data read by reflecting laser:**\n3. Pits and lands on surface\n4. Laser reflects differently from pits vs. lands\n5. Reflection pattern encodes data",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "CD-ROM (Compact Disk Read Only Memory)"
              },
              {
                "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Track-Organization",
                "title": "Track Organization",
                "front": "Track Organization",
                "back": "1. **Single spiral track:**\n2. Begins near center\n3. Spirals out to outer edge\n4. Different from magnetic disk (concentric tracks)",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "CD-ROM (Compact Disk Read Only Memory)"
              },
              {
                "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Capacity",
                "title": "Capacity",
                "front": "Capacity",
                "back": "1. **About 680 MB** (74 minutes of audio)\n2. Standard format",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "CD-ROM (Compact Disk Read Only Memory)"
              },
              {
                "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "1. Laser shines on disk surface\n2. Reflection detected by photodetector\n3. Pits and lands create different reflection patterns\n4. Patterns decoded to data",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "CD-ROM (Compact Disk Read Only Memory)"
              },
              {
                "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Cheap:** Very low cost per disk\n2. **Portable:** Easy to distribute\n3. **Durable:** Resistant to magnetic fields\n4. **Standardized:** Universal format",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "CD-ROM (Compact Disk Read Only Memory)"
              },
              {
                "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Slow:** Sequential access, slow transfer rates\n2. **Low capacity:** Compared to modern storage\n3. **Read-only (for ROM):** Cannot modify",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "CD-ROM (Compact Disk Read Only Memory)"
              },
              {
                "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. Software distribution\n2. Music distribution (historical)\n3. Data backup and archive\n4. Multimedia content",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "CD-ROM (Compact Disk Read Only Memory)"
              }
            ]
          },
          {
            "subsection": "DVD and Blu-ray",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Optical-Storage-DVD-and-Blu-ray-DVD",
                "title": "DVD",
                "front": "DVD",
                "back": "1. **Higher capacity:** 4.7-17 GB\n2. **Shorter wavelength laser:** Red laser (vs. infrared for CD)\n3. **Smaller pits:** Higher density\n4. **Multiple layers:** Can have 2 layers per side",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "DVD and Blu-ray"
              },
              {
                "id": "5-Optical-Storage-DVD-and-Blu-ray-Blu-ray",
                "title": "Blu-ray",
                "front": "Blu-ray",
                "back": "1. **Even higher capacity:** 25-50 GB\n2. **Blue laser:** Shorter wavelength than red\n3. **Even smaller pits:** Highest density\n4. **Multiple layers:** Up to 4 layers",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "DVD and Blu-ray"
              },
              {
                "id": "5-Optical-Storage-DVD-and-Blu-ray-Evolution",
                "title": "Evolution",
                "front": "Evolution",
                "back": "1. CD → DVD → Blu-ray\n2. Each generation: Higher capacity, shorter wavelength laser",
                "type": "list",
                "section": "Optical Storage",
                "subsection": "DVD and Blu-ray"
              }
            ]
          }
        ]
      },
      {
        "section": "Magnetic Tape",
        "subsections": [
          {
            "subsection": "What is Magnetic Tape?",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-Magnetic-Tape-What-is-Magnetic-Tape--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Sequential access storage medium using magnetic recording on tape.",
                "type": "definition",
                "section": "Magnetic Tape",
                "subsection": "What is Magnetic Tape?"
              },
              {
                "id": "5-Magnetic-Tape-What-is-Magnetic-Tape--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Backup and archive:** Secondary storage\n2. **Large capacity:** Terabytes per tape\n3. **Replaceable:** Can swap tapes\n4. **Slow:** Sequential access only\n5. **Sequential access:** Must read from beginning",
                "type": "list",
                "section": "Magnetic Tape",
                "subsection": "What is Magnetic Tape?"
              }
            ]
          },
          {
            "subsection": "Tape Characteristics",
            "cardCount": 2,
            "cards": [
              {
                "id": "5-Magnetic-Tape-Tape-Characteristics-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Very large capacity:** Terabytes per tape\n2. **Very low cost per GB:** Cheapest storage\n3. **Portable:** Easy to transport\n4. **Durable:** Long-term storage (decades)\n5. **Reliable:** Good for archival",
                "type": "list",
                "section": "Magnetic Tape",
                "subsection": "Tape Characteristics"
              },
              {
                "id": "5-Magnetic-Tape-Tape-Characteristics-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Very slow:** Sequential access only\n2. **Random access:** Impractical (must rewind)\n3. **Dying out:** Low production volume\n4. **Cost not dropping:** As rapidly as disks\n5. **Cheaper alternatives:** USB drives, cloud storage",
                "type": "list",
                "section": "Magnetic Tape",
                "subsection": "Tape Characteristics"
              }
            ]
          },
          {
            "subsection": "Tape vs. Disk",
            "cardCount": 4,
            "cards": [
              {
                "id": "5-Magnetic-Tape-Tape-vs--Disk-When-to-Use-Tape",
                "title": "When to Use Tape",
                "front": "When to Use Tape",
                "back": "1. **Sequential access:** Reading entire files from start to end\n2. **Large files:** Terabyte-sized files\n3. **Archive:** Long-term storage\n4. **Backup:** Regular backups",
                "type": "list",
                "section": "Magnetic Tape",
                "subsection": "Tape vs. Disk"
              },
              {
                "id": "5-Magnetic-Tape-Tape-vs--Disk-When-to-Use-Disk",
                "title": "When to Use Disk",
                "front": "When to Use Disk",
                "back": "1. **Random access:** Reading specific parts of files\n2. **Frequent access:** Regularly accessed data\n3. **Small files:** Many small files\n4. **Interactive use:** User applications",
                "type": "list",
                "section": "Magnetic Tape",
                "subsection": "Tape vs. Disk"
              },
              {
                "id": "5-Magnetic-Tape-Tape-vs--Disk-Example-Scenarios",
                "title": "Example Scenarios",
                "front": "Example Scenarios",
                "back": "1. **Read 1 GB file from start to end:**\n2. **Tape:** Good (sequential access)\n3. **Disk:** Also good, but more expensive\n4. **Read just first and last byte of 1 GB file:**\n5. **Disk:** Fast (random access)\n6. **Tape:** Very slow (must read entire file)\n7. **Make a cat happy:**\n8. **Tape:** Perfect! (cats love playing with tape)\n9. **Disk:** Not as fun",
                "type": "list",
                "section": "Magnetic Tape",
                "subsection": "Tape vs. Disk"
              },
              {
                "id": "5-Magnetic-Tape-Tape-vs--Disk-Modern-Status",
                "title": "Modern Status",
                "front": "Modern Status",
                "back": "1. **Declining:** Being replaced by:\n2. USB drives (cheap, portable)\n3. Cloud storage (convenient, accessible)\n4. Large HDDs (cheap, fast enough)\n5. **Still used:** Enterprise backup systems, archival storage",
                "type": "list",
                "section": "Magnetic Tape",
                "subsection": "Tape vs. Disk"
              }
            ]
          }
        ]
      },
      {
        "section": "Storage System Comparison",
        "subsections": [
          {
            "subsection": "Use Case Recommendations",
            "cardCount": 4,
            "cards": [
              {
                "id": "5-Storage-System-Comparison-Use-Case-Recommendations-HDD",
                "title": "HDD",
                "front": "HDD",
                "back": "1. Large capacity needs\n2. Cost-sensitive applications\n3. Archive storage\n4. Desktop computers",
                "type": "list",
                "section": "Storage System Comparison",
                "subsection": "Use Case Recommendations"
              },
              {
                "id": "5-Storage-System-Comparison-Use-Case-Recommendations-SSD",
                "title": "SSD",
                "front": "SSD",
                "back": "1. Performance-critical applications\n2. Operating system and programs\n3. Mobile devices\n4. High-performance workstations",
                "type": "list",
                "section": "Storage System Comparison",
                "subsection": "Use Case Recommendations"
              },
              {
                "id": "5-Storage-System-Comparison-Use-Case-Recommendations-Optical",
                "title": "Optical",
                "front": "Optical",
                "back": "1. Software distribution\n2. Music/movie distribution\n3. Long-term archive\n4. Backup (for small amounts)",
                "type": "list",
                "section": "Storage System Comparison",
                "subsection": "Use Case Recommendations"
              },
              {
                "id": "5-Storage-System-Comparison-Use-Case-Recommendations-Tape",
                "title": "Tape",
                "front": "Tape",
                "back": "1. Enterprise backup\n2. Long-term archive\n3. Very large sequential files\n4. Disaster recovery",
                "type": "list",
                "section": "Storage System Comparison",
                "subsection": "Use Case Recommendations"
              }
            ]
          }
        ]
      },
      {
        "section": "Key Concepts Summary",
        "subsections": [
          {
            "subsection": "External Memory Principles",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Key-Concepts-Summary-External-Memory-Principles-External-Memory-Principles",
                "title": "External Memory Principles",
                "front": "External Memory Principles",
                "back": "1. **Diversity:** Many storage technologies for different needs\n2. **Trade-offs:** Speed, capacity, cost cannot all be optimized\n3. **Hierarchy:** External memory is slowest but largest and cheapest\n4. **Performance:** Throughput and latency are key metrics",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "External Memory Principles"
              }
            ]
          },
          {
            "subsection": "Magnetic Disk Fundamentals",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Key-Concepts-Summary-Magnetic-Disk-Fundamentals-Magnetic-Disk-Fundamentals",
                "title": "Magnetic Disk Fundamentals",
                "front": "Magnetic Disk Fundamentals",
                "back": "1. **Mechanical:** Rotating platters with magnetic recording\n2. **Performance:** Seek time + rotational latency + transfer time\n3. **Organization:** Tracks, sectors, cylinders\n4. **Optimization:** Zoned bit recording improves capacity",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Magnetic Disk Fundamentals"
              }
            ]
          },
          {
            "subsection": "RAID Systems",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Key-Concepts-Summary-RAID-Systems-RAID-Systems",
                "title": "RAID Systems",
                "front": "RAID Systems",
                "back": "1. **Purpose:** Performance and/or reliability\n2. **Trade-offs:** Performance vs. reliability vs. capacity\n3. **Common Levels:** RAID 0 (performance), 1 (mirroring), 5 (distributed parity), 6 (dual parity)\n4. **Parity:** Enables data reconstruction after failure",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "RAID Systems"
              }
            ]
          },
          {
            "subsection": "Solid State Drives",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Key-Concepts-Summary-Solid-State-Drives-Solid-State-Drives",
                "title": "Solid State Drives",
                "front": "Solid State Drives",
                "back": "1. **Advantages:** Fast, durable, low power, no moving parts\n2. **Limitations:** Write endurance, write amplification\n3. **Solutions:** Wear leveling, caching, over-provisioning\n4. **Hybrid:** Combine with HDD for best of both",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Solid State Drives"
              }
            ]
          },
          {
            "subsection": "Storage Selection",
            "cardCount": 1,
            "cards": [
              {
                "id": "5-Key-Concepts-Summary-Storage-Selection-Storage-Selection",
                "title": "Storage Selection",
                "front": "Storage Selection",
                "back": "1. **HDD:** Large capacity, low cost, moderate speed\n2. **SSD:** High speed, moderate capacity, higher cost\n3. **Optical:** Distribution, archive, low cost\n4. **Tape:** Sequential access, very large capacity, very low cost",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Storage Selection"
              }
            ]
          }
        ]
      },
      {
        "section": "Practice Problems and Examples",
        "subsections": [
          {
            "subsection": "Problem 1: Disk Access Time",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Practice-Problems-and-Examples-Problem-1--Disk-Access-Time-Question",
                "title": "Question",
                "front": "Question",
                "back": "Disk has average seek time of 8 ms, rotates at 7200 RPM, and has 100 sectors per track. What is average access time to read one sector?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Disk Access Time"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-1--Disk-Access-Time-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Average seek time = 8 ms Rotational latency: Time per revolution = 60/7200 = 0.00833 s = 8.33 ms Average latency = 8.33/2 = 4.17 ms Transfer time: Time per track = 8.33 ms Time per sector = 8.33/100 = 0.0833 ms Total access time = 8 + 4.17 + 0.0833 = 12.25 ms",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Disk Access Time"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-1--Disk-Access-Time-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "12.25 ms",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: Disk Access Time"
              }
            ]
          },
          {
            "subsection": "Problem 2: RAID Capacity",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Practice-Problems-and-Examples-Problem-2--RAID-Capacity-Question",
                "title": "Question",
                "front": "Question",
                "back": "RAID 5 array with 5 disks, each 1 TB. What is usable capacity?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: RAID Capacity"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-2--RAID-Capacity-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "RAID 5: (N-1) × disk capacity N = 5 disks Usable capacity = (5-1) × 1 TB = 4 TB",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: RAID Capacity"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-2--RAID-Capacity-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "4 TB usable capacity",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: RAID Capacity"
              }
            ]
          },
          {
            "subsection": "Problem 3: RAID 1 Capacity",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Practice-Problems-and-Examples-Problem-3--RAID-1-Capacity-Question",
                "title": "Question",
                "front": "Question",
                "back": "RAID 1 array with 4 disks, each 500 GB. What is usable capacity?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: RAID 1 Capacity"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-3--RAID-1-Capacity-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "RAID 1: (N/2) × disk capacity (mirroring) N = 4 disks Usable capacity = (4/2) × 500 GB = 2 × 500 GB = 1 TB",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: RAID 1 Capacity"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-3--RAID-1-Capacity-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1 TB usable capacity",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: RAID 1 Capacity"
              }
            ]
          },
          {
            "subsection": "Problem 4: Transfer Rate",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Practice-Problems-and-Examples-Problem-4--Transfer-Rate-Question",
                "title": "Question",
                "front": "Question",
                "back": "Disk rotates at 10,000 RPM, has 200 sectors per track, sector size 4 KB. What is sequential transfer rate?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Transfer Rate"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-4--Transfer-Rate-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Time per revolution = 60/10000 = 0.006 s = 6 ms Sectors per track = 200 Data per track = 200 × 4 KB = 800 KB Transfer rate = 800 KB / 0.006 s = 133,333 KB/s = 133.3 MB/s",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Transfer Rate"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-4--Transfer-Rate-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "133.3 MB/s",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Transfer Rate"
              }
            ]
          },
          {
            "subsection": "Problem 5: Hybrid Storage Performance",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Practice-Problems-and-Examples-Problem-5--Hybrid-Storage-Performance-Question",
                "title": "Question",
                "front": "Question",
                "back": "System has 1 TB HDD (100 MB/s sequential, 1 MB/s random) and 32 GB SSD cache (1000 MB/s). 90% of requests hit cache. What is effective transfer rate for random access?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Hybrid Storage Performance"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-5--Hybrid-Storage-Performance-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Cache hit rate = 90% Cache miss rate = 10% Cache hit: 1000 MB/s Cache miss (HDD random): 1 MB/s Effective rate = 0.9 × 1000 + 0.1 × 1 = 900 + 0.1 = 900.1 MB/s",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Hybrid Storage Performance"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-5--Hybrid-Storage-Performance-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "900.1 MB/s effective rate",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Hybrid Storage Performance"
              }
            ]
          },
          {
            "subsection": "Problem 6: RAID Performance",
            "cardCount": 3,
            "cards": [
              {
                "id": "5-Practice-Problems-and-Examples-Problem-6--RAID-Performance-Question",
                "title": "Question",
                "front": "Question",
                "back": "RAID 0 array with 4 disks, each capable of 150 MB/s. What is maximum sequential transfer rate?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 6: RAID Performance"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-6--RAID-Performance-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "RAID 0: Data striped across all disks All disks can transfer in parallel Maximum rate = 4 × 150 MB/s = 600 MB/s",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 6: RAID Performance"
              },
              {
                "id": "5-Practice-Problems-and-Examples-Problem-6--RAID-Performance-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **Understand Mechanical Components:**\n2. How disks physically work\n3. Seek time vs. rotational latency\n4. Why SSDs are faster (no mechanics)\n5. **Master RAID Levels:**\n6. Know differences between levels\n7. Understand parity concept\n8. Calculate capacity overhead\n9. **Compare Technologies:**\n10. HDD vs. SSD trade-offs\n11. When to use each technology\n12. Cost vs. performance\n13. **Performance Calculations:**\n14. Access time components\n15. Transfer rate calculations\n16. RAID performance\n17. **Real-World Context:**\n18. Why different technologies exist\n19. How they're used in practice\n20. Evolution of storage technology\n21. **Magnetic disks** provide large capacity at low cost\n22. **RAID systems** improve performance and reliability\n23. **SSDs** offer high speed with no moving parts\n24. **Optical storage** provides portable, cheap distribution\n25. **Magnetic tape** offers very large capacity for archive\n26. It's the largest level of the memory hierarchy\n27. It's often the performance bottleneck\n28. Different technologies serve different needs\n29. Storage system design impacts overall system performance",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 6: RAID Performance"
              }
            ]
          }
        ]
      }
    ],
    "allCards": [
      {
        "id": "5-Detailed-Study-Guide--Detailed-Study-Guide",
        "title": "Detailed Study Guide",
        "front": "Detailed Study Guide",
        "back": "1. [Introduction to External Memory](#introduction-to-external-memory)\n2. [Magnetic Disk Fundamentals](#magnetic-disk-fundamentals)\n3. [Disk Organization and Formatting](#disk-organization-and-formatting)\n4. [Disk Performance Parameters](#disk-performance-parameters)\n5. [RAID Systems](#raid-systems)\n6. [Solid State Drives (SSDs)](#solid-state-drives-ssds)\n7. [Optical Storage](#optical-storage)\n8. [Magnetic Tape](#magnetic-tape)\n9. [Storage System Comparison](#storage-system-comparison)\n10. [Key Concepts Summary](#key-concepts-summary)\n11. [Practice Problems and Examples](#practice-problems-and-examples)",
        "type": "list",
        "section": "Detailed Study Guide",
        "subsection": ""
      },
      {
        "id": "5-Introduction-to-External-Memory-Purpose-of-External-Memory-Primary-Functions",
        "title": "Primary Functions",
        "front": "Primary Functions",
        "back": "1. **File Storage:**\n2. Programs\n3. Data files\n4. System settings\n5. User documents\n6. **Virtual Memory:**\n7. Extension of main memory\n8. Swap space for processes\n9. Allows larger programs than physical RAM\n10. **Backup and Archive:**\n11. Long-term data preservation\n12. Disaster recovery\n13. Historical data storage",
        "type": "list",
        "section": "Introduction to External Memory",
        "subsection": "Purpose of External Memory"
      },
      {
        "id": "5-Introduction-to-External-Memory-Storage-System-Characteristics-Performance-Metrics",
        "title": "Performance Metrics",
        "front": "Performance Metrics",
        "back": "1. **Throughput:**\n2. Data transfer rate (MB/s, GB/s)\n3. Improving, but **not as quickly as processor speed**\n4. Often the system bottleneck\n5. **Latency:**\n6. Access time (time to first byte)\n7. Improving but **very slowly**\n8. Critical for random access performance",
        "type": "list",
        "section": "Introduction to External Memory",
        "subsection": "Storage System Characteristics"
      },
      {
        "id": "5-Introduction-to-External-Memory-Storage-System-Characteristics-Reliability",
        "title": "Reliability",
        "front": "Reliability",
        "back": "1. Data integrity\n2. Error rates\n3. Mean time between failures (MTBF)\n4. Data recovery capabilities",
        "type": "list",
        "section": "Introduction to External Memory",
        "subsection": "Storage System Characteristics"
      },
      {
        "id": "5-Introduction-to-External-Memory-Storage-System-Characteristics-Diversity",
        "title": "Diversity",
        "front": "Diversity",
        "back": "1. **Magnetic disks:** Hard disk drives (HDDs)\n2. **Optical disks:** CD, DVD, Blu-ray\n3. **Magnetic tape:** Backup and archive\n4. **Solid state drives (SSDs):** Flash-based storage",
        "type": "list",
        "section": "Introduction to External Memory",
        "subsection": "Storage System Characteristics"
      },
      {
        "id": "5-Introduction-to-External-Memory-Storage-Hierarchy-Context-External-Memory-in-the-Hierarchy",
        "title": "External Memory in the Hierarchy",
        "front": "External Memory in the Hierarchy",
        "back": "CPU Registers (fastest, smallest) Cache Memory Main Memory (DRAM) External Memory (HDD, SSD, Optical, Tape) ← We are here",
        "type": "definition",
        "section": "Introduction to External Memory",
        "subsection": "Storage Hierarchy Context"
      },
      {
        "id": "5-Introduction-to-External-Memory-Storage-Hierarchy-Context-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Largest capacity:** Terabytes to petabytes\n2. **Slowest access:** Milliseconds to seconds\n3. **Cheapest per bit:** Very low cost\n4. **Non-volatile:** Data persists without power",
        "type": "list",
        "section": "Introduction to External Memory",
        "subsection": "Storage Hierarchy Context"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-What-is-a-Magnetic-Disk--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Storage device using magnetic recording on rotating platters.",
        "type": "definition",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "What is a Magnetic Disk?"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-What-is-a-Magnetic-Disk--Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **Hard disk drive (HDD):** Primary storage in computers\n2. **Floppy disk:** Historical, now obsolete",
        "type": "list",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "What is a Magnetic Disk?"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Physical-Structure-Components",
        "title": "Components",
        "front": "Components",
        "back": "1. **Platter:**\n2. Circular disk\n3. Constructed of **nonmagnetic material** (substrate)\n4. Coated with **magnetizable material**\n5. **Substrate Material:**\n6. **Historical:** Aluminium\n7. **Modern:** Glass\n8. **Why glass?**\n9. Better uniformity of magnetic film surface\n10. Fewer surface defects (reduces read-write errors)\n11. Better stiffness (reduces disk dynamics)\n12. Greater shock resistance\n13. **Read/Write Head:**\n14. Conductive coil called a **head**\n15. May be single read/write head or separate ones\n16. During operation: **Head is stationary, platter rotates**",
        "type": "list",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Physical Structure"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Write-Operation",
        "title": "Write Operation",
        "front": "Write Operation",
        "back": "",
        "type": "concept",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Magnetic Read and Write Mechanisms"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Process",
        "title": "Process",
        "front": "Process",
        "back": "1. Current flows through coil\n2. Produces magnetic field\n3. Pulses sent to head\n4. Magnetic pattern recorded on surface below head",
        "type": "list",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Magnetic Read and Write Mechanisms"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Electrical current → Magnetic field → Magnetic pattern on disk",
        "type": "definition",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Magnetic Read and Write Mechanisms"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Read-Operation",
        "title": "Read Operation",
        "front": "Read Operation",
        "back": "",
        "type": "concept",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Magnetic Read and Write Mechanisms"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Traditional-Method",
        "title": "Traditional Method",
        "front": "Traditional Method",
        "back": "1. Magnetic field moving relative to coil produces current\n2. Same coil used for read and write\n3. Inductive reading",
        "type": "list",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Magnetic Read and Write Mechanisms"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Contemporary-Method--MR---Magneto-Resistive-",
        "title": "Contemporary Method (MR - Magneto Resistive)",
        "front": "Contemporary Method (MR - Magneto Resistive)",
        "back": "1. **Separate read head** (close to write head)\n2. **Partially shielded magneto resistive (MR) sensor**\n3. **Electrical resistance depends on direction of magnetic field**\n4. **High frequency operation**\n5. More sensitive, better performance",
        "type": "list",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Magnetic Read and Write Mechanisms"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Magnetic-Read-and-Write-Mechanisms-Principle",
        "title": "Principle",
        "front": "Principle",
        "back": "Magnetic pattern → Electrical signal → Data read",
        "type": "definition",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Magnetic Read and Write Mechanisms"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Disk-Geometry-Basic-Structure",
        "title": "Basic Structure",
        "front": "Basic Structure",
        "back": "1. **Tracks:** Concentric rings on platter surface\n2. **Sectors:** Divisions of tracks\n3. **Cylinders:** Same track position across all platters\n4. **Blocks:** Minimum unit of data transfer (typically one sector)",
        "type": "list",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Disk Geometry"
      },
      {
        "id": "5-Magnetic-Disk-Fundamentals-Disk-Geometry-Key-Points",
        "title": "Key Points",
        "front": "Key Points",
        "back": "1. Tracks are **concentric circles** (not spiral)\n2. Gaps between tracks prevent interference\n3. Same number of bits per track (variable packing density)\n4. Minimum block size = one sector",
        "type": "list",
        "section": "Magnetic Disk Fundamentals",
        "subsection": "Disk Geometry"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Track-Organization-Tracks",
        "title": "Tracks",
        "front": "Tracks",
        "back": "1. **Concentric rings** on disk surface\n2. **Gaps between tracks:**\n3. Prevent errors from head misalignment\n4. Prevent interference between magnetic fields\n5. Can reduce gap to increase capacity (but increases error risk)",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Track Organization"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Track-Organization-Variable-Packing-Density",
        "title": "Variable Packing Density",
        "front": "Variable Packing Density",
        "back": "1. Same number of bits per track\n2. Outer tracks: Bits more spread out (lower density)\n3. Inner tracks: Bits closer together (higher density)",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Track Organization"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Sector-Organization-Sectors",
        "title": "Sectors",
        "front": "Sectors",
        "back": "1. Tracks divided into **sectors**\n2. **Minimum block size** = one sector\n3. Typical sector sizes: 512 bytes, 4 KB",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Sector Organization"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Sector-Organization-Sector-Addressing",
        "title": "Sector Addressing",
        "front": "Sector Addressing",
        "back": "1. Each sector has unique address\n2. Format: (Cylinder, Head, Sector) or logical block addressing (LBA)",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Sector Organization"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-The-Problem",
        "title": "The Problem",
        "front": "The Problem",
        "back": "",
        "type": "concept",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Physical-Reality",
        "title": "Physical Reality",
        "front": "Physical Reality",
        "back": "1. Disk rotates at **constant angular velocity**\n2. **Outer tracks:** Longer circumference → bits pass head faster\n3. **Inner tracks:** Shorter circumference → bits pass head slower",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Challenge",
        "title": "Challenge",
        "front": "Challenge",
        "back": "Read all data bits at the same rate despite varying linear speed",
        "type": "definition",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Solutions",
        "title": "Solutions",
        "front": "Solutions",
        "back": "**1. Constant Angular Velocity (CAV)**",
        "type": "concept",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Method",
        "title": "Method",
        "front": "Method",
        "back": "1. Rotate disk at constant angular velocity\n2. **Pie-shaped sectors** and concentric tracks\n3. Individual tracks and sectors addressable\n4. Move head to track, wait for sector",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Waste of space on outer tracks:**\n2. Outer tracks have more physical space\n3. But store same number of bits as inner tracks\n4. Lower data density on outer tracks",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Simple addressing\n2. Easy to implement\n3. Predictable access",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. Inefficient use of disk space\n2. Lower overall capacity",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Method",
        "title": "Method",
        "front": "Method",
        "back": "1. Surface divided into **concentric zones**\n2. Each zone contains contiguous tracks\n3. **Within a zone:** Number of bits per track is constant\n4. **Between zones:** Outer zones have more bits per track",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Zones farther from center contain **more bits** (more sectors)\n2. Example:\n3. Innermost zones: 2 tracks, 9 sectors each\n4. Middle zones: 3 tracks, 12 sectors each\n5. Outermost zones: 4 tracks, 16 sectors each",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Better capacity utilization**\n2. Higher data density\n3. More efficient use of disk space",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **More complex circuitry**\n2. Variable sectors per track\n3. More complex addressing",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Velocity-and-Data-Density-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "Most modern disks use **zoned bit recording** for better capacity.",
        "type": "definition",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Velocity and Data Density"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Formatting-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Prepare disk for use by marking tracks and sectors.",
        "type": "definition",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Formatting"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Formatting-Format-Information",
        "title": "Format Information",
        "front": "Format Information",
        "back": "1. Additional information not available to user\n2. Marks start of tracks and sectors\n3. Includes:\n4. **Gap:** Space between sectors\n5. **Sync field:** Synchronization information\n6. **Address field:** Sector address\n7. **Data field:** Actual data\n8. **Error detection:** CRC or checksum",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Formatting"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Formatting-Low-Level-Formatting",
        "title": "Low-Level Formatting",
        "front": "Low-Level Formatting",
        "back": "1. Physical formatting of disk\n2. Creates track and sector structure\n3. Done at factory",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Formatting"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Disk-Formatting-High-Level-Formatting",
        "title": "High-Level Formatting",
        "front": "High-Level Formatting",
        "back": "1. Logical formatting\n2. Creates file system\n3. Done by operating system",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Disk Formatting"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Head-Configuration",
        "title": "Head Configuration",
        "front": "Head Configuration",
        "back": "",
        "type": "concept",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-1--Fixed-Head-Disk",
        "title": "1. Fixed-Head Disk",
        "front": "1. Fixed-Head Disk",
        "back": "1. **One read-write head per track**\n2. Heads mounted on fixed rigid arm\n3. Arm extends across all tracks\n4. **No seek time** (head always at correct track)\n5. **Expensive** (many heads needed)\n6. **Fast access** (no head movement)",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-2--Moveable-Head-Disk",
        "title": "2. Moveable-Head Disk",
        "front": "2. Moveable-Head Disk",
        "back": "1. **One read-write head per side**\n2. Mounted on **movable arm**\n3. Arm can be extended or retracted\n4. **Seek time required** (head must move to track)\n5. **Cheaper** (fewer heads)\n6. **Slower access** (head movement needed)",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "Almost all disks use **moveable-head** configuration.",
        "type": "definition",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Removability",
        "title": "Removability",
        "front": "Removability",
        "back": "",
        "type": "concept",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-1--Non-Removable-Disk",
        "title": "1. Non-Removable Disk",
        "front": "1. Non-Removable Disk",
        "back": "1. Permanently mounted in disk drive\n2. Example: Hard disk in personal computer\n3. **Advantages:**\n4. Better performance (no mechanical connection issues)\n5. More reliable\n6. Higher capacity",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-2--Removable-Disk",
        "title": "2. Removable Disk",
        "front": "2. Removable Disk",
        "back": "1. Can be removed and replaced\n2. Example: Floppy disks (historical)\n3. **Advantages:**\n4. Unlimited storage capacity (by swapping disks)\n5. Easy data transfer between systems\n6. Portability",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "Most disks are **non-removable** for better performance and reliability.",
        "type": "definition",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Sidedness",
        "title": "Sidedness",
        "front": "Sidedness",
        "back": "",
        "type": "concept",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Double-Sided-Disk",
        "title": "Double-Sided Disk",
        "front": "Double-Sided Disk",
        "back": "1. Magnetizable coating on **both sides** of platter\n2. Two surfaces per platter\n3. Doubles capacity per platter",
        "type": "list",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Organization-and-Formatting-Physical-Characteristics-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "All modern disks are **double-sided**.",
        "type": "definition",
        "section": "Disk Organization and Formatting",
        "subsection": "Physical Characteristics"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-To-read-or-write",
        "title": "To read or write",
        "front": "To read or write",
        "back": "1. Head must be positioned at desired **track**\n2. Head must wait for desired **sector** to rotate under it",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-1--Seek-Time",
        "title": "1. Seek Time",
        "front": "1. Seek Time",
        "back": "",
        "type": "concept",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Time to move head to correct track.",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Factors",
        "title": "Factors",
        "front": "Factors",
        "back": "1. **Distance:** How far head must travel\n2. **Speed:** How fast head moves\n3. **Acceleration/Deceleration:** Head must accelerate, then decelerate",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Typical-Values",
        "title": "Typical Values",
        "front": "Typical Values",
        "back": "1. **Average seek time:** 3-15 ms\n2. **Track-to-track:** 0.5-2 ms\n3. **Full stroke:** 10-25 ms",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Calculation",
        "title": "Calculation",
        "front": "Calculation",
        "back": "1. **Average seek time:** Time to move from random track to random track\n2. Typically: 1/3 of full stroke time",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-2--Rotational-Latency--Rotational-Delay-",
        "title": "2. Rotational Latency (Rotational Delay)",
        "front": "2. Rotational Latency (Rotational Delay)",
        "back": "",
        "type": "concept",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Time waiting for desired sector to rotate under head.",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Factors",
        "title": "Factors",
        "front": "Factors",
        "back": "1. **Disk rotation speed:** RPM (revolutions per minute)\n2. **Sector position:** Where sector is relative to head",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Calculation",
        "title": "Calculation",
        "front": "Calculation",
        "back": "1. **Average rotational latency:** Time for half rotation\n2. Formula: `Average latency = (1/2) × (60 seconds / RPM) × 1000 ms`",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Typical-Values",
        "title": "Typical Values",
        "front": "Typical Values",
        "back": "1. 5400 RPM: 5.56 ms average\n2. 7200 RPM: 4.17 ms average\n3. 10000 RPM: 3.00 ms average\n4. 15000 RPM: 2.00 ms average",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Example",
        "title": "Example",
        "front": "Example",
        "back": "7200 RPM disk: Time per revolution = 60/7200 = 0.00833 seconds = 8.33 ms Average latency = 8.33 / 2 = 4.17 ms",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-3--Access-Time",
        "title": "3. Access Time",
        "front": "3. Access Time",
        "back": "",
        "type": "concept",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Formula",
        "title": "Formula",
        "front": "Formula",
        "back": "Access Time = Seek Time + Rotational Latency",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Time to get into position to read or write.",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Does-NOT-include",
        "title": "Does NOT include",
        "front": "Does NOT include",
        "back": "Actual data transfer time.",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Access-Time-Components-Typical-Values",
        "title": "Typical Values",
        "front": "Typical Values",
        "back": "1. Average: 5-20 ms\n2. Depends on disk speed and seek characteristics",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Access Time Components"
      },
      {
        "id": "5-Disk-Performance-Parameters-Transfer-Time-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Time to actually transfer data.",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Transfer Time"
      },
      {
        "id": "5-Disk-Performance-Parameters-Transfer-Time-Factors",
        "title": "Factors",
        "front": "Factors",
        "back": "1. **Disk rotation speed:** How fast data passes under head\n2. **Sectors per track:** How much data per track\n3. **Amount of data:** How many sectors to transfer",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Transfer Time"
      },
      {
        "id": "5-Disk-Performance-Parameters-Transfer-Time-Calculation",
        "title": "Calculation",
        "front": "Calculation",
        "back": "Transfer Time = (Number of sectors to transfer) / (Sectors per track × RPM / 60)",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Transfer Time"
      },
      {
        "id": "5-Disk-Performance-Parameters-Transfer-Time-Or",
        "title": "Or",
        "front": "Or",
        "back": "Transfer Time = (Data size) / (Transfer rate)",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Transfer Time"
      },
      {
        "id": "5-Disk-Performance-Parameters-Transfer-Time-Typical-Transfer-Rates",
        "title": "Typical Transfer Rates",
        "front": "Typical Transfer Rates",
        "back": "1. Sequential: 100-200 MB/s (modern HDDs)\n2. Random: Much lower (1-10 MB/s)",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Transfer Time"
      },
      {
        "id": "5-Disk-Performance-Parameters-Complete-I-O-Time-Total-Time-for-Disk-I-O",
        "title": "Total Time for Disk I/O",
        "front": "Total Time for Disk I/O",
        "back": "Total Time = Seek Time + Rotational Latency + Transfer Time",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Complete I/O Time"
      },
      {
        "id": "5-Disk-Performance-Parameters-Complete-I-O-Time-Example",
        "title": "Example",
        "front": "Example",
        "back": "Seek time: 8 ms Rotational latency: 4 ms Transfer time: 2 ms (for 1 sector) Total: 14 ms",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Complete I/O Time"
      },
      {
        "id": "5-Disk-Performance-Parameters-Performance-Example-Given",
        "title": "Given",
        "front": "Given",
        "back": "1. 1000 cylinders\n2. 10 sectors per track\n3. Head assembly at cylinder 0 initially\n4. Head moves at 10 μs/cylinder\n5. Disk rotates 100 times/second",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Performance Example"
      },
      {
        "id": "5-Disk-Performance-Parameters-Performance-Example-Calculate-average-time-to-read-a-randomly-chosen-byte",
        "title": "Calculate average time to read a randomly chosen byte",
        "front": "Calculate average time to read a randomly chosen byte",
        "back": "1. Average distance: 1000/3 = 333 cylinders\n2. Seek time: 333 × 10 μs = 3.33 ms\n3. Time per revolution: 1/100 = 0.01 seconds = 10 ms\n4. Average latency: 10/2 = 5 ms\n5. One sector: 1/10 of track\n6. Time per track: 10 ms\n7. Transfer time: 10/10 = 1 ms",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Performance Example"
      },
      {
        "id": "5-Disk-Performance-Parameters-Performance-Example-Total",
        "title": "Total",
        "front": "Total",
        "back": "Total = 3.33 + 5 + 1 = 9.33 ms",
        "type": "definition",
        "section": "Disk Performance Parameters",
        "subsection": "Performance Example"
      },
      {
        "id": "5-Disk-Performance-Parameters-Improving-Disk-Performance-Strategies",
        "title": "Strategies",
        "front": "Strategies",
        "back": "1. **Faster Rotation:**\n2. Reduces rotational latency\n3. Increases transfer rate\n4. More expensive, more power\n5. **Higher Data Density:**\n6. More data per track\n7. Higher transfer rates\n8. Better capacity\n9. **Multiple Platters:**\n10. More surfaces\n11. More capacity\n12. Can access multiple surfaces in parallel\n13. **Cache:**\n14. Buffer frequently accessed data\n15. Reduces access time for cached data\n16. **Disk Scheduling:**\n17. Optimize order of requests\n18. Minimize seek time\n19. Examples: FCFS, SSTF, SCAN, C-SCAN",
        "type": "list",
        "section": "Disk Performance Parameters",
        "subsection": "Improving Disk Performance"
      },
      {
        "id": "5-RAID-Systems-What-is-RAID--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "**Redundant Array of Independent Disks**",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "What is RAID?"
      },
      {
        "id": "5-RAID-Systems-What-is-RAID--Key-Concepts",
        "title": "Key Concepts",
        "front": "Key Concepts",
        "back": "1. **Not a hierarchy:** All disks at same level\n2. **Logical drive:** Set of physical disks viewed as single logical drive by OS\n3. **Data distribution:** Data distributed across physical drives\n4. **Redundancy:** Can use redundant capacity for parity information",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "What is RAID?"
      },
      {
        "id": "5-RAID-Systems-What-is-RAID--Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "1. **Performance:** Increase speed through parallel access\n2. **Reliability:** Provide fault tolerance through redundancy\n3. **Capacity:** Combine multiple disks into larger volume",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "What is RAID?"
      },
      {
        "id": "5-RAID-Systems-RAID-Levels-Overview-Seven-RAID-Levels",
        "title": "Seven RAID Levels",
        "front": "Seven RAID Levels",
        "back": "1. **RAID 0:** Striping (no redundancy)\n2. **RAID 1:** Mirroring\n3. **RAID 2:** Bit-level striping with Hamming code\n4. **RAID 3:** Byte-level striping with dedicated parity\n5. **RAID 4:** Block-level striping with dedicated parity\n6. **RAID 5:** Block-level striping with distributed parity\n7. **RAID 6:** Block-level striping with dual distributed parity",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID Levels Overview"
      },
      {
        "id": "5-RAID-Systems-RAID-Levels-Overview-Common-Levels",
        "title": "Common Levels",
        "front": "Common Levels",
        "back": "RAID 0, 1, 5, 6 (most commonly used)",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID Levels Overview"
      },
      {
        "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Data **striped** across all disks.",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 0: Striping (No Redundancy)"
      },
      {
        "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Organization",
        "title": "Organization",
        "front": "Organization",
        "back": "1. **Round-robin striping:**\n2. Stripe 0 → Disk 0\n3. Stripe 1 → Disk 1\n4. Stripe 2 → Disk 2\n5. Stripe 3 → Disk 0 (wraps around)\n6. And so on...",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 0: Striping (No Redundancy)"
      },
      {
        "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **No redundancy:** No fault tolerance\n2. **No parity:** No error correction\n3. **Performance improvement:**\n4. Multiple data requests probably not on same disk\n5. Disks seek in parallel\n6. Set of data likely striped across multiple disks",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 0: Striping (No Redundancy)"
      },
      {
        "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **High performance:** Parallel access\n2. **Full capacity:** No space lost to redundancy\n3. **Simple:** Easy to implement",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 0: Striping (No Redundancy)"
      },
      {
        "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **No fault tolerance:** One disk failure = data loss\n2. **No reliability improvement:** Actually worse (more failure points)",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 0: Striping (No Redundancy)"
      },
      {
        "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. Performance-critical applications\n2. Where data can be easily recreated\n3. Temporary data",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 0: Striping (No Redundancy)"
      },
      {
        "id": "5-RAID-Systems-RAID-0--Striping--No-Redundancy--Capacity",
        "title": "Capacity",
        "front": "Capacity",
        "back": "N disks → N × disk capacity (no overhead)",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 0: Striping (No Redundancy)"
      },
      {
        "id": "5-RAID-Systems-RAID-1--Mirroring-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "**Mirrored disks** - two copies of each stripe on separate disks.",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 1: Mirroring"
      },
      {
        "id": "5-RAID-Systems-RAID-1--Mirroring-Organization",
        "title": "Organization",
        "front": "Organization",
        "back": "1. Data striped across disks\n2. **2 copies** of each stripe on separate disks\n3. Example: Stripe 0 on Disk 0 and Disk 1 (mirrored)",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 1: Mirroring"
      },
      {
        "id": "5-RAID-Systems-RAID-1--Mirroring-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Full redundancy:** Complete copy of data\n2. **Simple recovery:** Swap faulty disk and re-mirror\n3. **No downtime:** Can continue operating with one disk failed",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 1: Mirroring"
      },
      {
        "id": "5-RAID-Systems-RAID-1--Mirroring-Read-Performance",
        "title": "Read Performance",
        "front": "Read Performance",
        "back": "1. **Read from either disk:**\n2. Can balance read load\n3. Can read from faster disk\n4. Potentially 2x read performance",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 1: Mirroring"
      },
      {
        "id": "5-RAID-Systems-RAID-1--Mirroring-Write-Performance",
        "title": "Write Performance",
        "front": "Write Performance",
        "back": "1. **Write to both disks:**\n2. Must wait for both writes\n3. No write performance improvement\n4. May be slightly slower",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 1: Mirroring"
      },
      {
        "id": "5-RAID-Systems-RAID-1--Mirroring-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **High reliability:** Can survive one disk failure\n2. **Fast recovery:** Simple mirror rebuild\n3. **Good read performance:** Can read from either disk",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 1: Mirroring"
      },
      {
        "id": "5-RAID-Systems-RAID-1--Mirroring-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Expensive:** 50% capacity overhead (2 disks for 1 disk capacity)\n2. **No write performance improvement:** Must write to both",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 1: Mirroring"
      },
      {
        "id": "5-RAID-Systems-RAID-1--Mirroring-Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. Critical data\n2. Applications requiring high availability\n3. Small arrays (2 disks)",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 1: Mirroring"
      },
      {
        "id": "5-RAID-Systems-RAID-1--Mirroring-Capacity",
        "title": "Capacity",
        "front": "Capacity",
        "back": "N disks → (N/2) × disk capacity (50% overhead)",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 1: Mirroring"
      },
      {
        "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Very small strips (often single byte/word) with Hamming error correction.",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
      },
      {
        "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Organization",
        "title": "Organization",
        "front": "Organization",
        "back": "1. **Bit-level striping:** Data split at bit level\n2. **Error correction:** Hamming code calculated across corresponding bits\n3. **Multiple parity disks:** Store Hamming code error correction",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
      },
      {
        "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Lots of redundancy:** Many parity disks needed\n2. **Expensive:** High overhead\n3. **Not used:** Rarely implemented",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
      },
      {
        "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Why-Not-Used",
        "title": "Why Not Used",
        "front": "Why Not Used",
        "back": "1. Modern disks have built-in error correction\n2. Overhead too high\n3. Complexity not justified",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
      },
      {
        "id": "5-RAID-Systems-RAID-2--Bit-Level-Striping-with-Hamming-Code-Capacity",
        "title": "Capacity",
        "front": "Capacity",
        "back": "High overhead (many parity disks)",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 2: Bit-Level Striping with Hamming Code"
      },
      {
        "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Similar to RAID 2, but **only one redundant disk** (parity disk).",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Organization",
        "title": "Organization",
        "front": "Organization",
        "back": "1. **Byte-level striping:** Data split at byte level\n2. **Single parity disk:** Stores parity for each set of corresponding bytes\n3. **Simple parity:** XOR of corresponding bytes",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **One parity disk:** No matter how large the array\n2. **Data reconstruction:** Failed drive data can be reconstructed from surviving data and parity\n3. **Synchronous access:** All disks must be accessed together",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Low overhead:** Only one disk for parity\n2. **Good for large sequential transfers**",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Parity disk bottleneck:** All writes must update parity disk\n2. **Synchronous access:** Less flexible than independent disk access",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. Large sequential data transfers\n2. Applications with synchronized access patterns",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-3--Byte-Level-Striping-with-Dedicated-Parity-Capacity",
        "title": "Capacity",
        "front": "Capacity",
        "back": "N disks → (N-1) × disk capacity (1 disk overhead)",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 3: Byte-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "**Large stripes** (blocks) with **dedicated parity disk**.",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Organization",
        "title": "Organization",
        "front": "Organization",
        "back": "1. **Block-level striping:** Data split at block level\n2. **Independent disk operation:** Each disk operates independently\n3. **Dedicated parity disk:** All parity stored on one disk\n4. **Bit-by-bit parity:** Parity calculated across stripes on each disk",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Good for high I/O request rate:**\n2. Separate I/O requests can be satisfied in parallel\n3. Independent disk access\n4. **Large stripes:** Better for random access",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Independent access:** Disks can operate independently\n2. **Good random I/O:** Multiple requests in parallel\n3. **Low overhead:** Only one parity disk",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Parity disk bottleneck:**\n2. Every write must update parity disk\n3. Parity disk becomes bottleneck\n4. Limits write performance",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. High I/O rate applications\n2. Random access patterns\n3. Read-heavy workloads",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-4--Block-Level-Striping-with-Dedicated-Parity-Capacity",
        "title": "Capacity",
        "front": "Capacity",
        "back": "N disks → (N-1) × disk capacity (1 disk overhead)",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 4: Block-Level Striping with Dedicated Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Like RAID 4, but **parity striped across all disks**.",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Organization",
        "title": "Organization",
        "front": "Organization",
        "back": "1. **Block-level striping:** Data split at block level\n2. **Distributed parity:** Parity striped across all disks\n3. **Round-robin allocation:** Parity stripe rotates among disks",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Avoids RAID 4 bottleneck:**\n2. Parity distributed, not on single disk\n3. Better write performance\n4. Better load balancing",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **No parity disk bottleneck:** Parity distributed\n2. **Good performance:** Both read and write\n3. **Good reliability:** Can survive one disk failure\n4. **Commonly used:** Very popular",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Write penalty:** Must read old data and parity, calculate new parity, write both\n2. **Complexity:** More complex than RAID 1",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. **Network servers:** Very common\n2. General-purpose storage\n3. Balanced read/write workloads",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Capacity",
        "title": "Capacity",
        "front": "Capacity",
        "back": "N disks → (N-1) × disk capacity (1 disk overhead)",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-5--Block-Level-Striping-with-Distributed-Parity-Example",
        "title": "Example",
        "front": "Example",
        "back": "4 disks, parity distribution: Disk 0: Data, Data, Parity, Data Disk 1: Data, Parity, Data, Data Disk 2: Parity, Data, Data, Data Disk 3: Data, Data, Data, Parity",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 5: Block-Level Striping with Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "**Two parity calculations** stored in separate blocks on different disks.",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 6: Dual Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Organization",
        "title": "Organization",
        "front": "Organization",
        "back": "1. **Block-level striping:** Data split at block level\n2. **Dual parity:** Two independent parity calculations\n3. **Distributed:** Both parities distributed across disks",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 6: Dual Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **High data availability:**\n2. Can survive **two disk failures**\n3. Three disks must fail for data loss\n4. **Significant write penalty:**\n5. Must calculate and write two parities\n6. More complex than RAID 5",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 6: Dual Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Very high reliability:** Can survive two failures\n2. **Good for critical data:** Maximum fault tolerance",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 6: Dual Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **High write penalty:** Two parities to calculate/write\n2. **Higher overhead:** Two disks for parity\n3. **More complex:** More calculations needed",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 6: Dual Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. Critical data requiring maximum reliability\n2. Large arrays (where two failures more likely)\n3. Long-term archival storage",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID 6: Dual Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-6--Dual-Distributed-Parity-Capacity",
        "title": "Capacity",
        "front": "Capacity",
        "back": "N disks → (N-2) × disk capacity (2 disks overhead)",
        "type": "definition",
        "section": "RAID Systems",
        "subsection": "RAID 6: Dual Distributed Parity"
      },
      {
        "id": "5-RAID-Systems-RAID-Comparison-Summary-Key-Trade-offs",
        "title": "Key Trade-offs",
        "front": "Key Trade-offs",
        "back": "1. **Performance vs. Reliability:** RAID 0 fast but no redundancy; RAID 1/5/6 slower but reliable\n2. **Capacity vs. Reliability:** More redundancy = less usable capacity\n3. **Write Performance:** Parity calculations slow writes (RAID 5/6)",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID Comparison Summary"
      },
      {
        "id": "5-RAID-Systems-RAID-Comparison-Summary-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "1. **RAID 0:** Performance-critical, non-critical data\n2. **RAID 1:** Small arrays, critical data\n3. **RAID 5:** Most common for general-purpose storage\n4. **RAID 6:** Large arrays, maximum reliability",
        "type": "list",
        "section": "RAID Systems",
        "subsection": "RAID Comparison Summary"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--What-is-an-SSD--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "**Solid State Drive** - storage device using **electronic circuitry** (semiconductors) instead of mechanical components.",
        "type": "definition",
        "section": "Solid State Drives (SSDs)",
        "subsection": "What is an SSD?"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--What-is-an-SSD--Technology",
        "title": "Technology",
        "front": "Technology",
        "back": "Uses **NAND flash memory** (same as USB drives, memory cards).",
        "type": "definition",
        "section": "Solid State Drives (SSDs)",
        "subsection": "What is an SSD?"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--What-is-an-SSD--Significance",
        "title": "Significance",
        "front": "Significance",
        "back": "1. Most significant development to complement or replace HDDs\n2. Used for both internal and external memory\n3. Increasingly competitive with HDDs as cost drops and performance increases",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "What is an SSD?"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-1--High-IOPS--Input-Output-Operations-Per-Second-",
        "title": "1. High IOPS (Input/Output Operations Per Second)",
        "front": "1. High IOPS (Input/Output Operations Per Second)",
        "back": "1. Much higher random I/O performance\n2. Can handle many small requests efficiently",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "SSD Advantages over HDD"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-2--Durability",
        "title": "2. Durability",
        "front": "2. Durability",
        "back": "1. **Less susceptible to physical shock and vibration:**\n2. No moving parts\n3. Can withstand drops and impacts\n4. Better for mobile devices",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "SSD Advantages over HDD"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-3--Longer-Lifespan",
        "title": "3. Longer Lifespan",
        "front": "3. Longer Lifespan",
        "back": "1. **Not susceptible to mechanical wear:**\n2. No moving parts to wear out\n3. No head crashes\n4. No bearing failures",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "SSD Advantages over HDD"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-4--Lower-Power-Consumption",
        "title": "4. Lower Power Consumption",
        "front": "4. Lower Power Consumption",
        "back": "1. **Considerably less power** than comparable HDDs\n2. Important for laptops, mobile devices\n3. Lower energy costs",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "SSD Advantages over HDD"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-5--Quieter-and-Cooler",
        "title": "5. Quieter and Cooler",
        "front": "5. Quieter and Cooler",
        "back": "1. **No moving parts:** Silent operation\n2. **Less heat:** Lower power = less heat\n3. **Less space required:** Smaller form factors",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "SSD Advantages over HDD"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--SSD-Advantages-over-HDD-6--Lower-Access-Times-and-Latency",
        "title": "6. Lower Access Times and Latency",
        "front": "6. Lower Access Times and Latency",
        "back": "1. **Over 10 times faster** than spinning disks\n2. **No seek time:** No head movement\n3. **No rotational latency:** No waiting for rotation\n4. **Random access:** Much faster than HDDs",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "SSD Advantages over HDD"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--SSD-Architecture-Components",
        "title": "Components",
        "front": "Components",
        "back": "1. **Interface to Host System:**\n2. SATA, PCIe, NVMe\n3. Connects SSD to computer\n4. **Controller:**\n5. Manages flash memory\n6. Handles wear leveling\n7. Error correction\n8. Address translation\n9. **Addressing:**\n10. Logical to physical address mapping\n11. Handles bad block management\n12. **Data Buffer/Cache:**\n13. RAM buffer for temporary storage\n14. Improves performance\n15. **Error Correction:**\n16. Detects and corrects errors\n17. Critical for flash memory reliability\n18. **Flash Memory Components:**\n19. NAND flash chips\n20. Organized in pages and blocks",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "SSD Architecture"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-1--Write-Endurance",
        "title": "1. Write Endurance",
        "front": "1. Write Endurance",
        "back": "",
        "type": "concept",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "1. **Flash memory becomes unusable after certain number of writes**\n2. Each cell can only be written finite number of times\n3. Typical: 1,000 to 100,000 write cycles per cell",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Impact",
        "title": "Impact",
        "front": "Impact",
        "back": "1. SSD performance may slow down as device is used\n2. Cells wear out over time\n3. Eventually, SSD may fail",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-2--Write-Amplification",
        "title": "2. Write Amplification",
        "front": "2. Write Amplification",
        "back": "",
        "type": "concept",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "1. **To write a page onto flash memory:**\n2. Entire **block** must be read from flash\n3. Placed in RAM buffer\n4. Entire block of flash memory must be **erased**\n5. Entire block from buffer written back to flash",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Result",
        "title": "Result",
        "front": "Result",
        "back": "1. Writing small amount of data requires rewriting entire block\n2. **Write amplification:** More data written than requested\n3. Reduces performance and increases wear",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-3--Solutions-and-Techniques",
        "title": "3. Solutions and Techniques",
        "front": "3. Solutions and Techniques",
        "back": "",
        "type": "concept",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Wear-Leveling",
        "title": "Wear Leveling",
        "front": "Wear Leveling",
        "back": "1. **Distribute writes evenly** across all blocks\n2. Prevents some blocks from wearing out faster\n3. Extends SSD lifespan",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Caching",
        "title": "Caching",
        "front": "Caching",
        "back": "1. **Front-end flash with cache** (RAM buffer)\n2. **Delay and group write operations**\n3. Reduces number of erase operations\n4. Improves performance",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Over-Provisioning",
        "title": "Over-Provisioning",
        "front": "Over-Provisioning",
        "back": "1. More flash memory than advertised capacity\n2. Provides spare blocks for wear leveling\n3. Handles bad blocks",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-TRIM-Command",
        "title": "TRIM Command",
        "front": "TRIM Command",
        "back": "1. OS tells SSD which blocks are no longer needed\n2. Allows SSD to erase blocks in advance\n3. Improves write performance",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Practical-Issues-with-SSDs-Lifetime-Estimation",
        "title": "Lifetime Estimation",
        "front": "Lifetime Estimation",
        "back": "1. **Most flash devices estimate remaining lifetime**\n2. Systems can anticipate failure\n3. Take preemptive action (backup, replace)",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Practical Issues with SSDs"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Combine HDD and SSD for best of both worlds.",
        "type": "definition",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Hybrid Magnetic-Flash Systems"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Magnetic-Disk-Characteristics",
        "title": "Magnetic Disk Characteristics",
        "front": "Magnetic Disk Characteristics",
        "back": "1. **Low $/GB:** Very cheap per gigabyte\n2. **Huge capacity:** Terabytes available\n3. **Power hungry:** High power consumption\n4. **Slow:** Mechanical movement (seek, rotation)\n5. **Sensitive to impacts:** Head crashes possible",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Hybrid Magnetic-Flash Systems"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Flash-Characteristics",
        "title": "Flash Characteristics",
        "front": "Flash Characteristics",
        "back": "1. **Fast:** No mechanical delays\n2. **Power efficient:** Low power consumption\n3. **No moving parts:** Robust\n4. **Expensive:** Higher $/GB",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Hybrid Magnetic-Flash Systems"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Hybrid-Solution",
        "title": "Hybrid Solution",
        "front": "Hybrid Solution",
        "back": "1. **Use flash as cache for disk**\n2. **Most data on disk:** Cheap, large capacity\n3. **Frequently accessed data on flash:** Fast access\n4. **Automatic management:** System moves hot data to flash",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Hybrid Magnetic-Flash Systems"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Benefits",
        "title": "Benefits",
        "front": "Benefits",
        "back": "1. **Best of both:** Speed of SSD, capacity of HDD\n2. **Cost-effective:** Smaller flash cache, large HDD\n3. **Transparent:** Works automatically",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Hybrid Magnetic-Flash Systems"
      },
      {
        "id": "5-Solid-State-Drives--SSDs--Hybrid-Magnetic-Flash-Systems-Example",
        "title": "Example",
        "front": "Example",
        "back": "1. 1 TB HDD + 32 GB flash cache\n2. Frequently accessed files cached in flash\n3. Rest of data on HDD",
        "type": "list",
        "section": "Solid State Drives (SSDs)",
        "subsection": "Hybrid Magnetic-Flash Systems"
      },
      {
        "id": "5-Optical-Storage-Optical-Disk-Products-Types",
        "title": "Types",
        "front": "Types",
        "back": "1. **CD (Compact Disc):** 700 MB\n2. **DVD (Digital Versatile Disc):** 4.7-17 GB\n3. **Blu-ray:** 25-50 GB\n4. **HD DVD:** (discontinued)",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "Optical Disk Products"
      },
      {
        "id": "5-Optical-Storage-Optical-Disk-Products-Categories",
        "title": "Categories",
        "front": "Categories",
        "back": "1. **Read-only:** CD-ROM, DVD-ROM, BD-ROM\n2. **Write-once:** CD-R, DVD-R, BD-R\n3. **Rewritable:** CD-RW, DVD-RW, BD-RE",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "Optical Disk Products"
      },
      {
        "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--History",
        "title": "History",
        "front": "History",
        "back": "1. Originally developed for audio\n2. Adapted for computer data storage",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "CD-ROM (Compact Disk Read Only Memory)"
      },
      {
        "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Physical-Structure",
        "title": "Physical Structure",
        "front": "Physical Structure",
        "back": "1. **Polycarbonate disk** coated with highly reflective coat (usually aluminium)\n2. **Data read by reflecting laser:**\n3. Pits and lands on surface\n4. Laser reflects differently from pits vs. lands\n5. Reflection pattern encodes data",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "CD-ROM (Compact Disk Read Only Memory)"
      },
      {
        "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Track-Organization",
        "title": "Track Organization",
        "front": "Track Organization",
        "back": "1. **Single spiral track:**\n2. Begins near center\n3. Spirals out to outer edge\n4. Different from magnetic disk (concentric tracks)",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "CD-ROM (Compact Disk Read Only Memory)"
      },
      {
        "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Capacity",
        "title": "Capacity",
        "front": "Capacity",
        "back": "1. **About 680 MB** (74 minutes of audio)\n2. Standard format",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "CD-ROM (Compact Disk Read Only Memory)"
      },
      {
        "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "1. Laser shines on disk surface\n2. Reflection detected by photodetector\n3. Pits and lands create different reflection patterns\n4. Patterns decoded to data",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "CD-ROM (Compact Disk Read Only Memory)"
      },
      {
        "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Cheap:** Very low cost per disk\n2. **Portable:** Easy to distribute\n3. **Durable:** Resistant to magnetic fields\n4. **Standardized:** Universal format",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "CD-ROM (Compact Disk Read Only Memory)"
      },
      {
        "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Slow:** Sequential access, slow transfer rates\n2. **Low capacity:** Compared to modern storage\n3. **Read-only (for ROM):** Cannot modify",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "CD-ROM (Compact Disk Read Only Memory)"
      },
      {
        "id": "5-Optical-Storage-CD-ROM--Compact-Disk-Read-Only-Memory--Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. Software distribution\n2. Music distribution (historical)\n3. Data backup and archive\n4. Multimedia content",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "CD-ROM (Compact Disk Read Only Memory)"
      },
      {
        "id": "5-Optical-Storage-DVD-and-Blu-ray-DVD",
        "title": "DVD",
        "front": "DVD",
        "back": "1. **Higher capacity:** 4.7-17 GB\n2. **Shorter wavelength laser:** Red laser (vs. infrared for CD)\n3. **Smaller pits:** Higher density\n4. **Multiple layers:** Can have 2 layers per side",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "DVD and Blu-ray"
      },
      {
        "id": "5-Optical-Storage-DVD-and-Blu-ray-Blu-ray",
        "title": "Blu-ray",
        "front": "Blu-ray",
        "back": "1. **Even higher capacity:** 25-50 GB\n2. **Blue laser:** Shorter wavelength than red\n3. **Even smaller pits:** Highest density\n4. **Multiple layers:** Up to 4 layers",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "DVD and Blu-ray"
      },
      {
        "id": "5-Optical-Storage-DVD-and-Blu-ray-Evolution",
        "title": "Evolution",
        "front": "Evolution",
        "back": "1. CD → DVD → Blu-ray\n2. Each generation: Higher capacity, shorter wavelength laser",
        "type": "list",
        "section": "Optical Storage",
        "subsection": "DVD and Blu-ray"
      },
      {
        "id": "5-Magnetic-Tape-What-is-Magnetic-Tape--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Sequential access storage medium using magnetic recording on tape.",
        "type": "definition",
        "section": "Magnetic Tape",
        "subsection": "What is Magnetic Tape?"
      },
      {
        "id": "5-Magnetic-Tape-What-is-Magnetic-Tape--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Backup and archive:** Secondary storage\n2. **Large capacity:** Terabytes per tape\n3. **Replaceable:** Can swap tapes\n4. **Slow:** Sequential access only\n5. **Sequential access:** Must read from beginning",
        "type": "list",
        "section": "Magnetic Tape",
        "subsection": "What is Magnetic Tape?"
      },
      {
        "id": "5-Magnetic-Tape-Tape-Characteristics-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Very large capacity:** Terabytes per tape\n2. **Very low cost per GB:** Cheapest storage\n3. **Portable:** Easy to transport\n4. **Durable:** Long-term storage (decades)\n5. **Reliable:** Good for archival",
        "type": "list",
        "section": "Magnetic Tape",
        "subsection": "Tape Characteristics"
      },
      {
        "id": "5-Magnetic-Tape-Tape-Characteristics-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Very slow:** Sequential access only\n2. **Random access:** Impractical (must rewind)\n3. **Dying out:** Low production volume\n4. **Cost not dropping:** As rapidly as disks\n5. **Cheaper alternatives:** USB drives, cloud storage",
        "type": "list",
        "section": "Magnetic Tape",
        "subsection": "Tape Characteristics"
      },
      {
        "id": "5-Magnetic-Tape-Tape-vs--Disk-When-to-Use-Tape",
        "title": "When to Use Tape",
        "front": "When to Use Tape",
        "back": "1. **Sequential access:** Reading entire files from start to end\n2. **Large files:** Terabyte-sized files\n3. **Archive:** Long-term storage\n4. **Backup:** Regular backups",
        "type": "list",
        "section": "Magnetic Tape",
        "subsection": "Tape vs. Disk"
      },
      {
        "id": "5-Magnetic-Tape-Tape-vs--Disk-When-to-Use-Disk",
        "title": "When to Use Disk",
        "front": "When to Use Disk",
        "back": "1. **Random access:** Reading specific parts of files\n2. **Frequent access:** Regularly accessed data\n3. **Small files:** Many small files\n4. **Interactive use:** User applications",
        "type": "list",
        "section": "Magnetic Tape",
        "subsection": "Tape vs. Disk"
      },
      {
        "id": "5-Magnetic-Tape-Tape-vs--Disk-Example-Scenarios",
        "title": "Example Scenarios",
        "front": "Example Scenarios",
        "back": "1. **Read 1 GB file from start to end:**\n2. **Tape:** Good (sequential access)\n3. **Disk:** Also good, but more expensive\n4. **Read just first and last byte of 1 GB file:**\n5. **Disk:** Fast (random access)\n6. **Tape:** Very slow (must read entire file)\n7. **Make a cat happy:**\n8. **Tape:** Perfect! (cats love playing with tape)\n9. **Disk:** Not as fun",
        "type": "list",
        "section": "Magnetic Tape",
        "subsection": "Tape vs. Disk"
      },
      {
        "id": "5-Magnetic-Tape-Tape-vs--Disk-Modern-Status",
        "title": "Modern Status",
        "front": "Modern Status",
        "back": "1. **Declining:** Being replaced by:\n2. USB drives (cheap, portable)\n3. Cloud storage (convenient, accessible)\n4. Large HDDs (cheap, fast enough)\n5. **Still used:** Enterprise backup systems, archival storage",
        "type": "list",
        "section": "Magnetic Tape",
        "subsection": "Tape vs. Disk"
      },
      {
        "id": "5-Storage-System-Comparison-Use-Case-Recommendations-HDD",
        "title": "HDD",
        "front": "HDD",
        "back": "1. Large capacity needs\n2. Cost-sensitive applications\n3. Archive storage\n4. Desktop computers",
        "type": "list",
        "section": "Storage System Comparison",
        "subsection": "Use Case Recommendations"
      },
      {
        "id": "5-Storage-System-Comparison-Use-Case-Recommendations-SSD",
        "title": "SSD",
        "front": "SSD",
        "back": "1. Performance-critical applications\n2. Operating system and programs\n3. Mobile devices\n4. High-performance workstations",
        "type": "list",
        "section": "Storage System Comparison",
        "subsection": "Use Case Recommendations"
      },
      {
        "id": "5-Storage-System-Comparison-Use-Case-Recommendations-Optical",
        "title": "Optical",
        "front": "Optical",
        "back": "1. Software distribution\n2. Music/movie distribution\n3. Long-term archive\n4. Backup (for small amounts)",
        "type": "list",
        "section": "Storage System Comparison",
        "subsection": "Use Case Recommendations"
      },
      {
        "id": "5-Storage-System-Comparison-Use-Case-Recommendations-Tape",
        "title": "Tape",
        "front": "Tape",
        "back": "1. Enterprise backup\n2. Long-term archive\n3. Very large sequential files\n4. Disaster recovery",
        "type": "list",
        "section": "Storage System Comparison",
        "subsection": "Use Case Recommendations"
      },
      {
        "id": "5-Key-Concepts-Summary-External-Memory-Principles-External-Memory-Principles",
        "title": "External Memory Principles",
        "front": "External Memory Principles",
        "back": "1. **Diversity:** Many storage technologies for different needs\n2. **Trade-offs:** Speed, capacity, cost cannot all be optimized\n3. **Hierarchy:** External memory is slowest but largest and cheapest\n4. **Performance:** Throughput and latency are key metrics",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "External Memory Principles"
      },
      {
        "id": "5-Key-Concepts-Summary-Magnetic-Disk-Fundamentals-Magnetic-Disk-Fundamentals",
        "title": "Magnetic Disk Fundamentals",
        "front": "Magnetic Disk Fundamentals",
        "back": "1. **Mechanical:** Rotating platters with magnetic recording\n2. **Performance:** Seek time + rotational latency + transfer time\n3. **Organization:** Tracks, sectors, cylinders\n4. **Optimization:** Zoned bit recording improves capacity",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Magnetic Disk Fundamentals"
      },
      {
        "id": "5-Key-Concepts-Summary-RAID-Systems-RAID-Systems",
        "title": "RAID Systems",
        "front": "RAID Systems",
        "back": "1. **Purpose:** Performance and/or reliability\n2. **Trade-offs:** Performance vs. reliability vs. capacity\n3. **Common Levels:** RAID 0 (performance), 1 (mirroring), 5 (distributed parity), 6 (dual parity)\n4. **Parity:** Enables data reconstruction after failure",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "RAID Systems"
      },
      {
        "id": "5-Key-Concepts-Summary-Solid-State-Drives-Solid-State-Drives",
        "title": "Solid State Drives",
        "front": "Solid State Drives",
        "back": "1. **Advantages:** Fast, durable, low power, no moving parts\n2. **Limitations:** Write endurance, write amplification\n3. **Solutions:** Wear leveling, caching, over-provisioning\n4. **Hybrid:** Combine with HDD for best of both",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Solid State Drives"
      },
      {
        "id": "5-Key-Concepts-Summary-Storage-Selection-Storage-Selection",
        "title": "Storage Selection",
        "front": "Storage Selection",
        "back": "1. **HDD:** Large capacity, low cost, moderate speed\n2. **SSD:** High speed, moderate capacity, higher cost\n3. **Optical:** Distribution, archive, low cost\n4. **Tape:** Sequential access, very large capacity, very low cost",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Storage Selection"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-1--Disk-Access-Time-Question",
        "title": "Question",
        "front": "Question",
        "back": "Disk has average seek time of 8 ms, rotates at 7200 RPM, and has 100 sectors per track. What is average access time to read one sector?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Disk Access Time"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-1--Disk-Access-Time-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Average seek time = 8 ms Rotational latency: Time per revolution = 60/7200 = 0.00833 s = 8.33 ms Average latency = 8.33/2 = 4.17 ms Transfer time: Time per track = 8.33 ms Time per sector = 8.33/100 = 0.0833 ms Total access time = 8 + 4.17 + 0.0833 = 12.25 ms",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Disk Access Time"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-1--Disk-Access-Time-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "12.25 ms",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: Disk Access Time"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-2--RAID-Capacity-Question",
        "title": "Question",
        "front": "Question",
        "back": "RAID 5 array with 5 disks, each 1 TB. What is usable capacity?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: RAID Capacity"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-2--RAID-Capacity-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "RAID 5: (N-1) × disk capacity N = 5 disks Usable capacity = (5-1) × 1 TB = 4 TB",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: RAID Capacity"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-2--RAID-Capacity-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "4 TB usable capacity",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: RAID Capacity"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-3--RAID-1-Capacity-Question",
        "title": "Question",
        "front": "Question",
        "back": "RAID 1 array with 4 disks, each 500 GB. What is usable capacity?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: RAID 1 Capacity"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-3--RAID-1-Capacity-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "RAID 1: (N/2) × disk capacity (mirroring) N = 4 disks Usable capacity = (4/2) × 500 GB = 2 × 500 GB = 1 TB",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: RAID 1 Capacity"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-3--RAID-1-Capacity-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1 TB usable capacity",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: RAID 1 Capacity"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-4--Transfer-Rate-Question",
        "title": "Question",
        "front": "Question",
        "back": "Disk rotates at 10,000 RPM, has 200 sectors per track, sector size 4 KB. What is sequential transfer rate?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Transfer Rate"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-4--Transfer-Rate-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Time per revolution = 60/10000 = 0.006 s = 6 ms Sectors per track = 200 Data per track = 200 × 4 KB = 800 KB Transfer rate = 800 KB / 0.006 s = 133,333 KB/s = 133.3 MB/s",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Transfer Rate"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-4--Transfer-Rate-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "133.3 MB/s",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Transfer Rate"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-5--Hybrid-Storage-Performance-Question",
        "title": "Question",
        "front": "Question",
        "back": "System has 1 TB HDD (100 MB/s sequential, 1 MB/s random) and 32 GB SSD cache (1000 MB/s). 90% of requests hit cache. What is effective transfer rate for random access?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Hybrid Storage Performance"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-5--Hybrid-Storage-Performance-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Cache hit rate = 90% Cache miss rate = 10% Cache hit: 1000 MB/s Cache miss (HDD random): 1 MB/s Effective rate = 0.9 × 1000 + 0.1 × 1 = 900 + 0.1 = 900.1 MB/s",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Hybrid Storage Performance"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-5--Hybrid-Storage-Performance-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "900.1 MB/s effective rate",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Hybrid Storage Performance"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-6--RAID-Performance-Question",
        "title": "Question",
        "front": "Question",
        "back": "RAID 0 array with 4 disks, each capable of 150 MB/s. What is maximum sequential transfer rate?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 6: RAID Performance"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-6--RAID-Performance-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "RAID 0: Data striped across all disks All disks can transfer in parallel Maximum rate = 4 × 150 MB/s = 600 MB/s",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 6: RAID Performance"
      },
      {
        "id": "5-Practice-Problems-and-Examples-Problem-6--RAID-Performance-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **Understand Mechanical Components:**\n2. How disks physically work\n3. Seek time vs. rotational latency\n4. Why SSDs are faster (no mechanics)\n5. **Master RAID Levels:**\n6. Know differences between levels\n7. Understand parity concept\n8. Calculate capacity overhead\n9. **Compare Technologies:**\n10. HDD vs. SSD trade-offs\n11. When to use each technology\n12. Cost vs. performance\n13. **Performance Calculations:**\n14. Access time components\n15. Transfer rate calculations\n16. RAID performance\n17. **Real-World Context:**\n18. Why different technologies exist\n19. How they're used in practice\n20. Evolution of storage technology\n21. **Magnetic disks** provide large capacity at low cost\n22. **RAID systems** improve performance and reliability\n23. **SSDs** offer high speed with no moving parts\n24. **Optical storage** provides portable, cheap distribution\n25. **Magnetic tape** offers very large capacity for archive\n26. It's the largest level of the memory hierarchy\n27. It's often the performance bottleneck\n28. Different technologies serve different needs\n29. Storage system design impacts overall system performance",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 6: RAID Performance"
      }
    ]
  },
  "6": {
    "group": 6,
    "totalCards": 231,
    "sections": [
      {
        "section": "Detailed Study Guide",
        "subsections": [
          {
            "subsection": "General",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-Detailed-Study-Guide--Detailed-Study-Guide",
                "title": "Detailed Study Guide",
                "front": "Detailed Study Guide",
                "back": "1. [Introduction to I/O Systems](#introduction-to-io-systems)\n2. [I/O Module Structure and Functions](#io-module-structure-and-functions)\n3. [External Devices](#external-devices)\n4. [I/O Techniques](#io-techniques)\n5. [I/O Mapping and Addressing](#io-mapping-and-addressing)\n6. [Interrupt-Driven I/O](#interrupt-driven-io)\n7. [Direct Memory Access (DMA)](#direct-memory-access-dma)\n8. [I/O Controllers and Interfaces](#io-controllers-and-interfaces)\n9. [External Interconnection Standards](#external-interconnection-standards)\n10. [Evolution of I/O Function](#evolution-of-io-function)\n11. [Key Concepts Summary](#key-concepts-summary)\n12. [Practice Problems and Examples](#practice-problems-and-examples)",
                "type": "list",
                "section": "Detailed Study Guide",
                "subsection": ""
              }
            ]
          }
        ]
      },
      {
        "section": "Introduction to I/O Systems",
        "subsections": [
          {
            "subsection": "Why I/O Modules are Needed",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-Introduction-to-I-O-Systems-Why-I-O-Modules-are-Needed-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "Why not connect peripherals directly to system bus?",
                "type": "definition",
                "section": "Introduction to I/O Systems",
                "subsection": "Why I/O Modules are Needed"
              },
              {
                "id": "6-Introduction-to-I-O-Systems-Why-I-O-Modules-are-Needed-Reasons",
                "title": "Reasons",
                "front": "Reasons",
                "back": "1. **Wide Variety of Peripherals:**\n2. Different methods of operation\n3. Different data formats\n4. Different speeds\n5. **Impractical** to incorporate control logic within processor\n6. **Speed Mismatch:**\n7. **Peripherals often slower** than memory/processor\n8. Impractical to use high-speed system bus directly\n9. Would waste bus bandwidth\n10. **Some Peripherals Faster:**\n11. Some devices faster than memory/processor\n12. Mismatch leads to inefficiencies if not managed\n13. **Data Format Differences:**\n14. Peripherals use different data formats\n15. Different word lengths\n16. Need conversion/translation",
                "type": "list",
                "section": "Introduction to I/O Systems",
                "subsection": "Why I/O Modules are Needed"
              },
              {
                "id": "6-Introduction-to-I-O-Systems-Why-I-O-Modules-are-Needed-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "**I/O Module** required to interface between processor/memory and peripherals.",
                "type": "definition",
                "section": "Introduction to I/O Systems",
                "subsection": "Why I/O Modules are Needed"
              }
            ]
          },
          {
            "subsection": "I/O Module Purpose",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-Introduction-to-I-O-Systems-I-O-Module-Purpose-Two-Major-Functions",
                "title": "Two Major Functions",
                "front": "Two Major Functions",
                "back": "1. **Interface to Processor and Memory:**\n2. Via system bus or central switch\n3. Handles communication with CPU\n4. Manages data transfer to/from memory\n5. **Interface to Peripheral Devices:**\n6. Via data links\n7. Handles device-specific protocols\n8. Manages device control and status",
                "type": "list",
                "section": "Introduction to I/O Systems",
                "subsection": "I/O Module Purpose"
              },
              {
                "id": "6-Introduction-to-I-O-Systems-I-O-Module-Purpose-Result",
                "title": "Result",
                "front": "Result",
                "back": "I/O module acts as **translator** and **buffer** between system and peripherals.",
                "type": "definition",
                "section": "Introduction to I/O Systems",
                "subsection": "I/O Module Purpose"
              }
            ]
          }
        ]
      },
      {
        "section": "I/O Module Structure and Functions",
        "subsections": [
          {
            "subsection": "Generic I/O Module Model",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-I-O-Module-Structure-and-Functions-Generic-I-O-Module-Model-Components",
                "title": "Components",
                "front": "Components",
                "back": "1. **Address Lines:** Identify I/O module and device\n2. **Data Lines:** Transfer data\n3. **Control Lines:** Control and timing signals\n4. **Links to Peripheral Devices:** Device-specific interfaces",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Generic I/O Module Model"
              }
            ]
          },
          {
            "subsection": "Major Functions of I/O Module",
            "cardCount": 32,
            "cards": [
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-1--Control-and-Timing",
                "title": "1. Control and Timing",
                "front": "1. Control and Timing",
                "back": "",
                "type": "concept",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Coordinate flow of traffic between internal resources and external devices.",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Responsibilities",
                "title": "Responsibilities",
                "front": "Responsibilities",
                "back": "1. Coordinate processor and I/O module interactions\n2. Manage shared resources (bus, memory)\n3. Handle timing of operations",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Example-Sequence",
                "title": "Example Sequence",
                "front": "Example Sequence",
                "back": "1. Processor interrogates I/O module (check device status)\n2. I/O module returns device status\n3. If device ready, processor requests data transfer\n4. I/O module obtains data from external device\n5. Data transferred from I/O module to processor",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Bus-Arbitration",
                "title": "Bus Arbitration",
                "front": "Bus Arbitration",
                "back": "1. Each interaction may involve bus arbitration\n2. Multiple devices competing for bus access\n3. I/O module must coordinate with bus controller",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-2--Processor-Communication",
                "title": "2. Processor Communication",
                "front": "2. Processor Communication",
                "back": "",
                "type": "concept",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Enable communication between processor and I/O module.",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Components",
                "title": "Components",
                "front": "Components",
                "back": "",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Command-Decoding",
                "title": "Command Decoding",
                "front": "Command Decoding",
                "back": "1. I/O module accepts commands from processor\n2. Commands sent as signals on control bus\n3. Example: Disk drive commands (READ SECTOR, WRITE SECTOR, SEEK)",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Data-Exchange",
                "title": "Data Exchange",
                "front": "Data Exchange",
                "back": "1. Data exchanged over data bus\n2. Bidirectional communication\n3. Handles data format conversion",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Status-Reporting",
                "title": "Status Reporting",
                "front": "Status Reporting",
                "back": "1. **Critical:** Peripherals are slow\n2. I/O module reports status to processor\n3. Common status signals:\n4. **BUSY:** Module working on previous command\n5. **READY:** Module ready for new command\n6. Processor can check status before proceeding",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Address-Recognition",
                "title": "Address Recognition",
                "front": "Address Recognition",
                "back": "1. Each I/O device has unique address\n2. I/O module recognizes address for its peripherals\n3. Similar to memory addressing",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-3--Device-Communication",
                "title": "3. Device Communication",
                "front": "3. Device Communication",
                "back": "",
                "type": "concept",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Enable communication between I/O module and external device.",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Components",
                "title": "Components",
                "front": "Components",
                "back": "1. **Commands:** I/O module sends commands to device\n2. **Status Information:** Device reports status to I/O module\n3. **Data:** Actual data transfer",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Device-Specific",
                "title": "Device-Specific",
                "front": "Device-Specific",
                "back": "1. Each device type has different protocol\n2. I/O module handles device-specific communication\n3. Abstracts device details from processor",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-4--Data-Buffering",
                "title": "4. Data Buffering",
                "front": "4. Data Buffering",
                "back": "",
                "type": "concept",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Balance speed differences between device and memory.",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "1. **Memory/Processor:** Very high transfer rates\n2. **Peripherals:** Often much slower (orders of magnitude)",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Solution---Buffering",
                "title": "Solution - Buffering",
                "front": "Solution - Buffering",
                "back": "",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-From-Memory-to-Device",
                "title": "From Memory to Device",
                "front": "From Memory to Device",
                "back": "1. Data sent from memory in rapid burst\n2. **Buffered in I/O module**\n3. Sent to device at device's slower rate",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-From-Device-to-Memory",
                "title": "From Device to Memory",
                "front": "From Device to Memory",
                "back": "1. Data received from device slowly\n2. **Buffered in I/O module**\n3. Prevents tying up memory in slow transfer\n4. Can accumulate data before transferring to memory",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Speed-Matching",
                "title": "Speed Matching",
                "front": "Speed Matching",
                "back": "1. I/O module must operate at **both** device and memory speeds\n2. Handles speed conversion\n3. Prevents bottlenecks",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Fast-Devices",
                "title": "Fast Devices",
                "front": "Fast Devices",
                "back": "1. Some devices faster than memory\n2. I/O module buffers to prevent memory bottleneck\n3. Manages high-speed data streams",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-5--Error-Detection",
                "title": "5. Error Detection",
                "front": "5. Error Detection",
                "back": "",
                "type": "concept",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Detect and report errors to processor.",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Error-Types",
                "title": "Error Types",
                "front": "Error Types",
                "back": "",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-1--Mechanical-Electrical-Malfunctions",
                "title": "1. Mechanical/Electrical Malfunctions",
                "front": "1. Mechanical/Electrical Malfunctions",
                "back": "1. Reported by device itself\n2. Examples:\n3. Paper jam (printer)\n4. Bad disk track\n5. Device failure",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-2--Transmission-Errors",
                "title": "2. Transmission Errors",
                "front": "2. Transmission Errors",
                "back": "1. Unintentional changes to bit pattern\n2. During transmission from device to I/O module\n3. Need error detection codes",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Error-Detection-Methods",
                "title": "Error Detection Methods",
                "front": "Error Detection Methods",
                "back": "",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Parity-Bit",
                "title": "Parity Bit",
                "front": "Parity Bit",
                "back": "1. Simple example: Parity bit on each character\n2. Example: IRA character code (7 bits) + 1 parity bit\n3. **Even parity:** Total number of 1s is even\n4. **Odd parity:** Total number of 1s is odd\n5. I/O module checks parity on receipt\n6. Detects single-bit errors",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-More-Advanced",
                "title": "More Advanced",
                "front": "More Advanced",
                "back": "1. CRC (Cyclic Redundancy Check)\n2. Checksums\n3. Error-correcting codes",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "Major Functions of I/O Module"
              }
            ]
          },
          {
            "subsection": "I/O Module Block Diagram",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-I-O-Module-Structure-and-Functions-I-O-Module-Block-Diagram-Internal-Structure",
                "title": "Internal Structure",
                "front": "Internal Structure",
                "back": "Interface to System Bus: ├── Address Lines ├── Data Lines └── Control Lines I/O Module: ├── Data Registers ├── Status/Control Registers ├── I/O Logic │ ├── Address Recognition │ ├── Command Decoding │ └── Status Reporting └── Device Interface Logic Interface to External Device: ├── Data Lines ├── Status Lines └── Control Lines",
                "type": "definition",
                "section": "I/O Module Structure and Functions",
                "subsection": "I/O Module Block Diagram"
              },
              {
                "id": "6-I-O-Module-Structure-and-Functions-I-O-Module-Block-Diagram-Registers",
                "title": "Registers",
                "front": "Registers",
                "back": "1. **Data Registers:** Hold data being transferred\n2. **Status/Control Registers:** Device status and control information",
                "type": "list",
                "section": "I/O Module Structure and Functions",
                "subsection": "I/O Module Block Diagram"
              }
            ]
          }
        ]
      },
      {
        "section": "External Devices",
        "subsections": [
          {
            "subsection": "What are External Devices?",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Devices-What-are-External-Devices--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Provide means of exchanging data between external environment and computer.",
                "type": "definition",
                "section": "External Devices",
                "subsection": "What are External Devices?"
              },
              {
                "id": "6-External-Devices-What-are-External-Devices--Connection",
                "title": "Connection",
                "front": "Connection",
                "back": "Attached to computer by link to I/O module.",
                "type": "definition",
                "section": "External Devices",
                "subsection": "What are External Devices?"
              },
              {
                "id": "6-External-Devices-What-are-External-Devices--Link-Purpose",
                "title": "Link Purpose",
                "front": "Link Purpose",
                "back": "Exchange control, status, and data between I/O module and external device.",
                "type": "definition",
                "section": "External Devices",
                "subsection": "What are External Devices?"
              }
            ]
          },
          {
            "subsection": "Categories of External Devices",
            "cardCount": 12,
            "cards": [
              {
                "id": "6-External-Devices-Categories-of-External-Devices-1--Human-Readable",
                "title": "1. Human Readable",
                "front": "1. Human Readable",
                "back": "",
                "type": "concept",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Suitable for communicating with computer user.",
                "type": "definition",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **Video display terminals:** Monitors, screens\n2. **Printers:** Output devices\n3. **Keyboards:** Input devices\n4. **Mice:** Input devices",
                "type": "list",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Designed for human interaction\n2. Text, graphics, audio output\n3. Human-readable input",
                "type": "list",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-2--Machine-Readable",
                "title": "2. Machine Readable",
                "front": "2. Machine Readable",
                "back": "",
                "type": "concept",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Suitable for communicating with equipment.",
                "type": "definition",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **Magnetic disk and tape systems:** Storage devices\n2. **Sensors:** Environmental sensors, temperature, pressure\n3. **Actuators:** Motors, valves, switches",
                "type": "list",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Designed for machine-to-machine communication\n2. Binary data formats\n3. Automated operation",
                "type": "list",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-3--Communication",
                "title": "3. Communication",
                "front": "3. Communication",
                "back": "",
                "type": "concept",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Suitable for communicating with remote devices.",
                "type": "definition",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-Examples",
                "title": "Examples",
                "front": "Examples",
                "back": "1. **Terminals:** Remote terminals\n2. **Machine readable devices:** Remote equipment\n3. **Other computers:** Network communication",
                "type": "list",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              },
              {
                "id": "6-External-Devices-Categories-of-External-Devices-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Network connectivity\n2. Remote access\n3. Protocol-based communication",
                "type": "list",
                "section": "External Devices",
                "subsection": "Categories of External Devices"
              }
            ]
          },
          {
            "subsection": "Block Diagram of External Device",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-External-Devices-Block-Diagram-of-External-Device-Components",
                "title": "Components",
                "front": "Components",
                "back": "1. **Transducer:**\n2. Converts between physical world and electrical signals\n3. Input: Physical → Electrical\n4. Output: Electrical → Physical\n5. **Buffer:**\n6. Temporary storage\n7. Holds data during transfer\n8. Speed matching\n9. **Control Logic:**\n10. Device control functions\n11. Interprets control signals\n12. Manages device operation",
                "type": "list",
                "section": "External Devices",
                "subsection": "Block Diagram of External Device"
              },
              {
                "id": "6-External-Devices-Block-Diagram-of-External-Device-Signals",
                "title": "Signals",
                "front": "Signals",
                "back": "1. **Control signals from I/O module:** Determine device function\n2. **Status signals to I/O module:** Indicate device state\n3. **Data bits:** To and from I/O module\n4. **Data to/from environment:** Device-specific data",
                "type": "list",
                "section": "External Devices",
                "subsection": "Block Diagram of External Device"
              }
            ]
          }
        ]
      },
      {
        "section": "I/O Techniques",
        "subsections": [
          {
            "subsection": "Three I/O Techniques",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-I-O-Techniques-Three-I-O-Techniques-Classification",
                "title": "Classification",
                "front": "Classification",
                "back": "1. **Programmed I/O**\n2. No interrupts\n3. I/O-to-memory transfer through processor\n4. **Interrupt-Driven I/O**\n5. Use of interrupts\n6. I/O-to-memory transfer through processor\n7. **Direct Memory Access (DMA)**\n8. Use of interrupts\n9. Direct I/O-to-memory transfer",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Three I/O Techniques"
              },
              {
                "id": "6-I-O-Techniques-Three-I-O-Techniques-Key-Difference",
                "title": "Key Difference",
                "front": "Key Difference",
                "back": "Role of processor in data transfer.",
                "type": "definition",
                "section": "I/O Techniques",
                "subsection": "Three I/O Techniques"
              }
            ]
          },
          {
            "subsection": "Programmed I/O",
            "cardCount": 11,
            "cards": [
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "",
                "type": "concept",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "Processor directly controls I/O operation.",
                "type": "definition",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Process",
                "title": "Process",
                "front": "Process",
                "back": "1. Processor executes I/O instruction\n2. Issues command to I/O module\n3. I/O module performs action\n4. Sets status bits in status register\n5. **Processor must periodically check status**\n6. Processor waits until operation complete",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Key-Characteristic",
                "title": "Key Characteristic",
                "front": "Key Characteristic",
                "back": "**I/O module does NOT interrupt processor.**",
                "type": "definition",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Processor-Responsibility",
                "title": "Processor Responsibility",
                "front": "Processor Responsibility",
                "back": "1. Must check status repeatedly\n2. Waits for I/O completion\n3. Cannot do other work while waiting",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-I-O-Commands",
                "title": "I/O Commands",
                "front": "I/O Commands",
                "back": "",
                "type": "concept",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Four-Types-of-I-O-Commands",
                "title": "Four Types of I/O Commands",
                "front": "Four Types of I/O Commands",
                "back": "1. **Control:**\n2. Activate peripheral\n3. Tell device what to do\n4. Example: Start printer, seek disk track\n5. **Test:**\n6. Test status conditions\n7. Check I/O module and peripheral status\n8. Example: Check if device ready, check for errors\n9. **Read:**\n10. I/O module obtains data from peripheral\n11. Places data in internal buffer\n12. Processor reads from buffer\n13. **Write:**\n14. I/O module takes data from data bus\n15. Transmits data to peripheral\n16. Processor writes to I/O module",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Programmed-I-O-Flow",
                "title": "Programmed I/O Flow",
                "front": "Programmed I/O Flow",
                "back": "",
                "type": "concept",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Input-of-Block-of-Data",
                "title": "Input of Block of Data",
                "front": "Input of Block of Data",
                "back": "1. Issue Read command to I/O module\n2. Read status of I/O module\n3. Check if ready\n4. If not ready: Loop back to step 2\n5. If ready: Continue\n6. Read word from I/O module\n7. Write word into memory\n8. Check if done\n9. If not done: Go to step 1 (next word)\n10. If done: Next instruction",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **CPU waits:** Processor tied up during I/O\n2. **Polling:** Must check status repeatedly\n3. **Inefficient:** Wastes processor time\n4. **Simple:** Easy to implement",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              },
              {
                "id": "6-I-O-Techniques-Programmed-I-O-Drawbacks",
                "title": "Drawbacks",
                "front": "Drawbacks",
                "back": "1. Processor cannot do other work\n2. Wastes CPU cycles checking status\n3. Slow for slow devices",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Programmed I/O"
              }
            ]
          },
          {
            "subsection": "Interrupt-Driven I/O",
            "cardCount": 9,
            "cards": [
              {
                "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "",
                "type": "concept",
                "section": "I/O Techniques",
                "subsection": "Interrupt-Driven I/O"
              },
              {
                "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "I/O module interrupts processor when ready.",
                "type": "definition",
                "section": "I/O Techniques",
                "subsection": "Interrupt-Driven I/O"
              },
              {
                "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Process",
                "title": "Process",
                "front": "Process",
                "back": "1. Processor issues I/O command\n2. **Processor continues executing other instructions**\n3. I/O module works on I/O operation\n4. When ready, I/O module **interrupts processor**\n5. Processor handles interrupt\n6. Executes data transfer\n7. Resumes former processing",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Interrupt-Driven I/O"
              },
              {
                "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Key-Advantage",
                "title": "Key Advantage",
                "front": "Key Advantage",
                "back": "**Processor can do other work while waiting.**",
                "type": "definition",
                "section": "I/O Techniques",
                "subsection": "Interrupt-Driven I/O"
              },
              {
                "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Interrupt-Driven-I-O-Flow",
                "title": "Interrupt-Driven I/O Flow",
                "front": "Interrupt-Driven I/O Flow",
                "back": "",
                "type": "concept",
                "section": "I/O Techniques",
                "subsection": "Interrupt-Driven I/O"
              },
              {
                "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Input-of-Block-of-Data",
                "title": "Input of Block of Data",
                "front": "Input of Block of Data",
                "back": "1. Issue Read command to I/O module\n2. Do something else (other instructions)\n3. Interrupt occurs (I/O module ready)\n4. Read status of I/O module\n5. Check for error condition\n6. Read word from I/O module\n7. Write word into memory\n8. Check if done\n9. If not done: Go to step 1\n10. If done: Return to interrupted program",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Interrupt-Driven I/O"
              },
              {
                "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **CPU not waiting:** Can do other work\n2. **Asynchronous:** I/O happens in background\n3. **Efficient:** Better CPU utilization\n4. **More complex:** Requires interrupt handling",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Interrupt-Driven I/O"
              },
              {
                "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Better CPU utilization\n2. Can handle multiple I/O operations\n3. More responsive system",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Interrupt-Driven I/O"
              },
              {
                "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Drawbacks",
                "title": "Drawbacks",
                "front": "Drawbacks",
                "back": "1. Still involves processor in each transfer\n2. Interrupt overhead\n3. More complex than programmed I/O",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Interrupt-Driven I/O"
              }
            ]
          },
          {
            "subsection": "Direct Memory Access (DMA)",
            "cardCount": 9,
            "cards": [
              {
                "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "",
                "type": "concept",
                "section": "I/O Techniques",
                "subsection": "Direct Memory Access (DMA)"
              },
              {
                "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "I/O module and memory exchange data directly without processor involvement.",
                "type": "definition",
                "section": "I/O Techniques",
                "subsection": "Direct Memory Access (DMA)"
              },
              {
                "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Process",
                "title": "Process",
                "front": "Process",
                "back": "1. Processor issues block read command to DMA module\n2. **Processor continues executing other instructions**\n3. DMA module transfers entire block directly to/from memory\n4. DMA module interrupts processor when complete",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Direct Memory Access (DMA)"
              },
              {
                "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Key-Advantage",
                "title": "Key Advantage",
                "front": "Key Advantage",
                "back": "**Processor only involved at start and end.**",
                "type": "definition",
                "section": "I/O Techniques",
                "subsection": "Direct Memory Access (DMA)"
              },
              {
                "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--DMA-Flow",
                "title": "DMA Flow",
                "front": "DMA Flow",
                "back": "",
                "type": "concept",
                "section": "I/O Techniques",
                "subsection": "Direct Memory Access (DMA)"
              },
              {
                "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Input-of-Block-of-Data",
                "title": "Input of Block of Data",
                "front": "Input of Block of Data",
                "back": "1. Issue Read block command to DMA module\n2. Do something else (other instructions)\n3. DMA transfers data directly to memory\n4. Interrupt occurs (DMA complete)\n5. Read status of DMA module\n6. Check for error condition\n7. Next instruction",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Direct Memory Access (DMA)"
              },
              {
                "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Minimal CPU involvement:** Only at start and end\n2. **Direct transfer:** I/O to memory, bypassing CPU\n3. **Very efficient:** Best for large transfers\n4. **Most complex:** Requires DMA controller",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Direct Memory Access (DMA)"
              },
              {
                "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Maximum efficiency:** CPU free during transfer\n2. **High throughput:** Can transfer large blocks\n3. **Best for bulk data:** Disk, network transfers",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Direct Memory Access (DMA)"
              },
              {
                "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Drawbacks",
                "title": "Drawbacks",
                "front": "Drawbacks",
                "back": "1. Most complex implementation\n2. Requires DMA controller hardware\n3. Bus arbitration needed",
                "type": "list",
                "section": "I/O Techniques",
                "subsection": "Direct Memory Access (DMA)"
              }
            ]
          },
          {
            "subsection": "Comparison of I/O Techniques",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-I-O-Techniques-Comparison-of-I-O-Techniques-Evolution",
                "title": "Evolution",
                "front": "Evolution",
                "back": "Programmed → Interrupt-Driven → DMA (increasing efficiency and complexity)",
                "type": "definition",
                "section": "I/O Techniques",
                "subsection": "Comparison of I/O Techniques"
              }
            ]
          }
        ]
      },
      {
        "section": "I/O Mapping and Addressing",
        "subsections": [
          {
            "subsection": "The Addressing Problem",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-I-O-Mapping-and-Addressing-The-Addressing-Problem-Question",
                "title": "Question",
                "front": "Question",
                "back": "How does processor identify I/O devices?",
                "type": "definition",
                "section": "I/O Mapping and Addressing",
                "subsection": "The Addressing Problem"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-The-Addressing-Problem-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "Two modes of addressing when processor, memory, and I/O share common bus.",
                "type": "definition",
                "section": "I/O Mapping and Addressing",
                "subsection": "The Addressing Problem"
              }
            ]
          },
          {
            "subsection": "Memory-Mapped I/O",
            "cardCount": 6,
            "cards": [
              {
                "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "I/O devices and memory locations share **single address space**.",
                "type": "definition",
                "section": "I/O Mapping and Addressing",
                "subsection": "Memory-Mapped I/O"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. I/O looks just like memory read/write\n2. **No special commands** for I/O\n3. Processor uses **same machine instructions** for memory and I/O\n4. Status and data registers treated as memory locations",
                "type": "list",
                "section": "I/O Mapping and Addressing",
                "subsection": "Memory-Mapped I/O"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Address-Space",
                "title": "Address Space",
                "front": "Address Space",
                "back": "1. Combined total of memory and I/O addresses\n2. Example: 10 address lines → 2^10 = 1024 locations\n3. Can be any combination (e.g., 512 memory + 512 I/O)",
                "type": "list",
                "section": "I/O Mapping and Addressing",
                "subsection": "Memory-Mapped I/O"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Large selection of memory access commands available**\n2. Can use all memory instructions (load, store, arithmetic)\n3. Simpler instruction set\n4. Flexible addressing",
                "type": "list",
                "section": "I/O Mapping and Addressing",
                "subsection": "Memory-Mapped I/O"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Reduces memory address space**\n2. Memory and I/O compete for addresses\n3. Need to reserve address space for I/O",
                "type": "list",
                "section": "I/O Mapping and Addressing",
                "subsection": "Memory-Mapped I/O"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Example",
                "title": "Example",
                "front": "Example",
                "back": "Address 516: Keyboard input data register Address 517: Keyboard input status register Load AC, 517 ; Get status Branch if Sign = 0, 202 ; Loop until ready Load AC, 516 ; Load data byte",
                "type": "definition",
                "section": "I/O Mapping and Addressing",
                "subsection": "Memory-Mapped I/O"
              }
            ]
          },
          {
            "subsection": "Isolated I/O (Port-Mapped I/O)",
            "cardCount": 6,
            "cards": [
              {
                "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "**Separate address spaces** for memory and I/O.",
                "type": "definition",
                "section": "I/O Mapping and Addressing",
                "subsection": "Isolated I/O (Port-Mapped I/O)"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Need **I/O or memory select lines** on bus\n2. **Special commands** for I/O (IN, OUT, Test I/O)\n3. Limited set of I/O instructions\n4. I/O addresses separate from memory addresses",
                "type": "list",
                "section": "I/O Mapping and Addressing",
                "subsection": "Isolated I/O (Port-Mapped I/O)"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Address-Space",
                "title": "Address Space",
                "front": "Address Space",
                "back": "1. Memory: Full address space (e.g., 1024 locations)\n2. I/O: Separate address space (e.g., 1024 I/O ports)\n3. **Total:** More addressable locations",
                "type": "list",
                "section": "I/O Mapping and Addressing",
                "subsection": "Isolated I/O (Port-Mapped I/O)"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. **Full memory address space** available\n2. Memory and I/O don't compete\n3. Clear separation",
                "type": "list",
                "section": "I/O Mapping and Addressing",
                "subsection": "Isolated I/O (Port-Mapped I/O)"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Limited set of I/O instructions**\n2. Special instructions needed\n3. Less flexible than memory-mapped",
                "type": "list",
                "section": "I/O Mapping and Addressing",
                "subsection": "Isolated I/O (Port-Mapped I/O)"
              },
              {
                "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Example",
                "title": "Example",
                "front": "Example",
                "back": "Load I/O, 5 ; Initiate keyboard read Test I/O, 5 ; Check for completion Branch Not Ready, 201 ; Loop until complete In, 5 ; Load data byte",
                "type": "definition",
                "section": "I/O Mapping and Addressing",
                "subsection": "Isolated I/O (Port-Mapped I/O)"
              }
            ]
          },
          {
            "subsection": "Comparison",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-I-O-Mapping-and-Addressing-Comparison-Modern-Practice",
                "title": "Modern Practice",
                "front": "Modern Practice",
                "back": "Most systems use **memory-mapped I/O** for flexibility.",
                "type": "definition",
                "section": "I/O Mapping and Addressing",
                "subsection": "Comparison"
              }
            ]
          }
        ]
      },
      {
        "section": "Interrupt-Driven I/O",
        "subsections": [
          {
            "subsection": "Why Interrupt-Driven I/O?",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-Interrupt-Driven-I-O-Why-Interrupt-Driven-I-O--Problem-with-Programmed-I-O",
                "title": "Problem with Programmed I/O",
                "front": "Problem with Programmed I/O",
                "back": "1. Processor must wait long time for I/O module\n2. Wastes processor time\n3. Inefficient",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Why Interrupt-Driven I/O?"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Why-Interrupt-Driven-I-O--Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Processor issues I/O command\n2. Goes on to do other useful work\n3. I/O module interrupts when ready\n4. Processor handles transfer and resumes",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Why Interrupt-Driven I/O?"
              }
            ]
          },
          {
            "subsection": "Simple Interrupt Processing",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-Interrupt-Driven-I-O-Simple-Interrupt-Processing-Hardware-Steps",
                "title": "Hardware Steps",
                "front": "Hardware Steps",
                "back": "1. Device controller issues interrupt\n2. Processor finishes current instruction\n3. Processor signals acknowledgment\n4. Processor pushes PSW and PC onto control stack",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Simple Interrupt Processing"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Simple-Interrupt-Processing-Software-Steps",
                "title": "Software Steps",
                "front": "Software Steps",
                "back": "1. Save remainder of process state information\n2. Process interrupt\n3. Restore process state information\n4. Restore old PSW and PC",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Simple Interrupt Processing"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Simple-Interrupt-Processing-Result",
                "title": "Result",
                "front": "Result",
                "back": "Processor loads new PC value based on interrupt, executes interrupt service routine, then returns.",
                "type": "definition",
                "section": "Interrupt-Driven I/O",
                "subsection": "Simple Interrupt Processing"
              }
            ]
          },
          {
            "subsection": "Changes During Interrupt",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-Interrupt-Driven-I-O-Changes-During-Interrupt-Before-Interrupt",
                "title": "Before Interrupt",
                "front": "Before Interrupt",
                "back": "1. Program Counter: N\n2. Stack Pointer: T\n3. General Registers: Various values\n4. User's Program executing",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Changes During Interrupt"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Changes-During-Interrupt-After-Interrupt",
                "title": "After Interrupt",
                "front": "After Interrupt",
                "back": "1. Program Counter: Y (interrupt service routine)\n2. Stack Pointer: T - M (pushed values)\n3. General Registers: Saved on stack\n4. Interrupt Service Routine executing",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Changes During Interrupt"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Changes-During-Interrupt-Return-from-Interrupt",
                "title": "Return from Interrupt",
                "front": "Return from Interrupt",
                "back": "1. Restore PC, PSW, registers from stack\n2. Resume user program at instruction N+1",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Changes During Interrupt"
              }
            ]
          },
          {
            "subsection": "Design Issues",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-Interrupt-Driven-I-O-Design-Issues-Two-Key-Questions",
                "title": "Two Key Questions",
                "front": "Two Key Questions",
                "back": "1. **Device Identification:**\n2. How does processor determine which device issued interrupt?\n3. Multiple I/O modules may interrupt\n4. **Priority:**\n5. If multiple interrupts occur, which to process first?\n6. Need priority system",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Design Issues"
              }
            ]
          },
          {
            "subsection": "Device Identification Techniques",
            "cardCount": 22,
            "cards": [
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Four-Categories",
                "title": "Four Categories",
                "front": "Four Categories",
                "back": "",
                "type": "definition",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-1--Multiple-Interrupt-Lines",
                "title": "1. Multiple Interrupt Lines",
                "front": "1. Multiple Interrupt Lines",
                "back": "",
                "type": "concept",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Separate interrupt line for each I/O module.",
                "type": "definition",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Most straightforward approach\n2. Processor knows device from interrupt line\n3. **Problem:** Limited number of interrupt lines\n4. Even with multiple lines, each line may have multiple modules",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Use",
                "title": "Use",
                "front": "Use",
                "back": "Simple systems, few devices",
                "type": "definition",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-2--Daisy-Chain--Hardware-Poll--Vectored-",
                "title": "2. Daisy Chain (Hardware Poll, Vectored)",
                "front": "2. Daisy Chain (Hardware Poll, Vectored)",
                "back": "",
                "type": "concept",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Interrupt acknowledge line daisy-chained through modules.",
                "type": "definition",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Process",
                "title": "Process",
                "front": "Process",
                "back": "1. Processor detects interrupt\n2. Processor responds on interrupt acknowledge line\n3. Signal passes through daisy chain\n4. First requesting module responds\n5. Module places **vector** (address/identifier) on data lines\n6. Processor uses vector to identify device",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Vector",
                "title": "Vector",
                "front": "Vector",
                "back": "1. Address of I/O module or unique identifier\n2. **Vectored interrupt:** Processor uses vector as pointer to service routine\n3. Avoids need for general interrupt service routine first",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Automatic device identification\n2. Fast (hardware-based)\n3. Vectored interrupts efficient",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. Fixed priority (order in chain)\n2. More complex hardware",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-3--Bus-Arbitration--Vectored-",
                "title": "3. Bus Arbitration (Vectored)",
                "front": "3. Bus Arbitration (Vectored)",
                "back": "",
                "type": "concept",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "I/O module must gain control of bus before raising interrupt.",
                "type": "definition",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Process",
                "title": "Process",
                "front": "Process",
                "back": "1. I/O module requests bus control\n2. Gains bus control\n3. Raises interrupt request line\n4. Processor detects interrupt\n5. Processor responds on interrupt acknowledge\n6. Requesting module places vector on data lines",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Flexible priority (bus arbitration)\n2. Vectored interrupts\n3. Works with bus-based systems",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. Requires bus arbitration\n2. More complex",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-4--Software-Poll",
                "title": "4. Software Poll",
                "front": "4. Software Poll",
                "back": "",
                "type": "concept",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Processor branches to interrupt service routine that polls each I/O module.",
                "type": "definition",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Process",
                "title": "Process",
                "front": "Process",
                "back": "1. Processor detects interrupt\n2. Branches to general interrupt service routine\n3. Routine polls each I/O module\n4. Determines which module caused interrupt\n5. Branches to specific device service routine",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Simple hardware\n2. Flexible (software-controlled)\n3. No special hardware needed",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Disadvantages",
                "title": "Disadvantages",
                "front": "Disadvantages",
                "back": "1. **Time consuming:** Must check each module\n2. Slower than hardware methods\n3. Higher interrupt latency",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Use",
                "title": "Use",
                "front": "Use",
                "back": "Systems with many devices, when hardware cost is concern",
                "type": "definition",
                "section": "Interrupt-Driven I/O",
                "subsection": "Device Identification Techniques"
              }
            ]
          },
          {
            "subsection": "Priority Handling",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-Interrupt-Driven-I-O-Priority-Handling-Problem",
                "title": "Problem",
                "front": "Problem",
                "back": "Multiple interrupts may occur simultaneously.",
                "type": "definition",
                "section": "Interrupt-Driven I/O",
                "subsection": "Priority Handling"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Priority-Handling-Solutions",
                "title": "Solutions",
                "front": "Solutions",
                "back": "1. **Fixed Priority:**\n2. Each device has fixed priority\n3. Higher priority interrupts lower priority\n4. Simple but inflexible\n5. **Programmable Priority:**\n6. Priority can be changed\n7. More flexible\n8. Requires priority controller\n9. **Nested Interrupts:**\n10. Higher priority can interrupt lower priority\n11. Requires interrupt masking\n12. More complex",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Priority Handling"
              },
              {
                "id": "6-Interrupt-Driven-I-O-Priority-Handling-Interrupt-Masking",
                "title": "Interrupt Masking",
                "front": "Interrupt Masking",
                "back": "1. Processor can disable interrupts\n2. Critical sections protected\n3. Interrupt enable/disable flags",
                "type": "list",
                "section": "Interrupt-Driven I/O",
                "subsection": "Priority Handling"
              }
            ]
          }
        ]
      },
      {
        "section": "Direct Memory Access (DMA)",
        "subsections": [
          {
            "subsection": "Why DMA?",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-Direct-Memory-Access--DMA--Why-DMA--Drawbacks-of-Programmed-and-Interrupt-Driven-I-O",
                "title": "Drawbacks of Programmed and Interrupt-Driven I/O",
                "front": "Drawbacks of Programmed and Interrupt-Driven I/O",
                "back": "1. **Transfer Rate Limited:**\n2. Limited by speed processor can test and service device\n3. Processor bottleneck\n4. **Processor Tied Up:**\n5. Processor involved in managing transfer\n6. Multiple instructions per I/O transfer\n7. Wastes processor cycles",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "Why DMA?"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--Why-DMA--Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "**Direct Memory Access (DMA)** for large data volumes.",
                "type": "definition",
                "section": "Direct Memory Access (DMA)",
                "subsection": "Why DMA?"
              }
            ]
          },
          {
            "subsection": "DMA Concept",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Concept-Definition",
                "title": "Definition",
                "front": "Definition",
                "back": "I/O module transfers data directly to/from memory without processor involvement.",
                "type": "definition",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Concept"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Concept-Key-Points",
                "title": "Key Points",
                "front": "Key Points",
                "back": "1. Processor only involved at **start and end**\n2. DMA controller handles transfer\n3. Data bypasses processor\n4. Very efficient for large transfers",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Concept"
              }
            ]
          },
          {
            "subsection": "DMA Block Diagram",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Block-Diagram-Components",
                "title": "Components",
                "front": "Components",
                "back": "1. **Data Count Register:**\n2. Number of bytes/words to transfer\n3. Decremented during transfer\n4. Interrupts when reaches zero\n5. **Data Register:**\n6. Temporary data storage\n7. For some DMA configurations\n8. **Address Register:**\n9. Memory address for transfer\n10. Incremented during transfer\n11. **Control Logic:**\n12. Manages DMA operation\n13. Handles bus requests\n14. Coordinates transfer",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Block Diagram"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Block-Diagram-Signals",
                "title": "Signals",
                "front": "Signals",
                "back": "1. **Request to DMA:** Device requests DMA transfer\n2. **Acknowledge from DMA:** DMA acknowledges request\n3. **Read/Write:** Control signals\n4. **Interrupt:** Signal completion",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Block Diagram"
              }
            ]
          },
          {
            "subsection": "DMA Operation",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Operation-Process",
                "title": "Process",
                "front": "Process",
                "back": "1. **Initialization (Processor):**\n2. Processor sets up DMA:\n3. Starting memory address\n4. Number of bytes to transfer\n5. Direction (read/write)\n6. Processor issues DMA command\n7. **Transfer (DMA Controller):**\n8. DMA controller requests bus\n9. Gains bus control\n10. Transfers data directly:\n11. Read from I/O device\n12. Write to memory (or vice versa)\n13. Increments address, decrements count\n14. Continues until complete\n15. **Completion (DMA Controller):**\n16. DMA controller interrupts processor\n17. Signals completion\n18. Processor checks status",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Operation"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Operation-Key",
                "title": "Key",
                "front": "Key",
                "back": "Processor free during entire transfer!",
                "type": "definition",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Operation"
              }
            ]
          },
          {
            "subsection": "DMA Breakpoints",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Breakpoints-DMA-Breakpoints",
                "title": "DMA Breakpoints",
                "front": "DMA Breakpoints",
                "back": "1. Can interrupt during instruction cycle\n2. Typically between:\n3. Instruction fetch and decode\n4. Operand fetch and execute\n5. Execute and store result",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Breakpoints"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Breakpoints-Interrupt-Breakpoints",
                "title": "Interrupt Breakpoints",
                "front": "Interrupt Breakpoints",
                "back": "1. Typically only between instructions\n2. Must complete current instruction",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Breakpoints"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Breakpoints-DMA-More-Flexible",
                "title": "DMA More Flexible",
                "front": "DMA More Flexible",
                "back": "1. Can interrupt during instruction execution\n2. Steals bus cycles\n3. Processor may need to wait for DMA",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Breakpoints"
              }
            ]
          },
          {
            "subsection": "DMA Configurations",
            "cardCount": 9,
            "cards": [
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-1--Single-Bus--Detached-DMA",
                "title": "1. Single-Bus, Detached DMA",
                "front": "1. Single-Bus, Detached DMA",
                "back": "",
                "type": "concept",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Configurations"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "Processor ──┐ ├── System Bus ── Memory DMA ────────┘ I/O ────────┘",
                "type": "definition",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Configurations"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. DMA on system bus\n2. Competes with processor for bus\n3. Bus arbitration needed\n4. Simple but may cause contention",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Configurations"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-2--Single-Bus--Integrated-DMA-I-O",
                "title": "2. Single-Bus, Integrated DMA-I/O",
                "front": "2. Single-Bus, Integrated DMA-I/O",
                "back": "",
                "type": "concept",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Configurations"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "Processor ──┐ ├── System Bus ── Memory DMA+I/O ────┘",
                "type": "definition",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Configurations"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. DMA integrated with I/O module\n2. Still on system bus\n3. More efficient (no separate DMA module)\n4. Common configuration",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Configurations"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-3--I-O-Bus",
                "title": "3. I/O Bus",
                "front": "3. I/O Bus",
                "back": "",
                "type": "concept",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Configurations"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Structure",
                "title": "Structure",
                "front": "Structure",
                "back": "Processor ── System Bus ── Memory DMA Controller I/O Bus ── I/O ── I/O ── I/O",
                "type": "definition",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Configurations"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Separate I/O bus\n2. DMA controller bridges buses\n3. Reduces system bus load\n4. More complex but better performance",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Configurations"
              }
            ]
          },
          {
            "subsection": "Fly-By DMA Controller",
            "cardCount": 4,
            "cards": [
              {
                "id": "6-Direct-Memory-Access--DMA--Fly-By-DMA-Controller-Concept",
                "title": "Concept",
                "front": "Concept",
                "back": "Data does **not** pass through DMA chip.",
                "type": "definition",
                "section": "Direct Memory Access (DMA)",
                "subsection": "Fly-By DMA Controller"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--Fly-By-DMA-Controller-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. DMA only between I/O port and memory\n2. **Not** between two I/O ports\n3. **Not** between two memory locations\n4. Data flows directly: I/O ↔ Memory",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "Fly-By DMA Controller"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--Fly-By-DMA-Controller-Memory-to-Memory",
                "title": "Memory-to-Memory",
                "front": "Memory-to-Memory",
                "back": "1. Can do via register\n2. Less efficient\n3. Requires two transfers",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "Fly-By DMA Controller"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--Fly-By-DMA-Controller-Example--Intel-8237",
                "title": "Example: Intel 8237",
                "front": "Example: Intel 8237",
                "back": "1. Contains four DMA channels\n2. Each channel programmed independently\n3. Any one channel active at a time\n4. Fly-by operation",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "Fly-By DMA Controller"
              }
            ]
          },
          {
            "subsection": "DMA Usage Example",
            "cardCount": 4,
            "cards": [
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Usage-Example-Intel-8237-DMA-Controller",
                "title": "Intel 8237 DMA Controller",
                "front": "Intel 8237 DMA Controller",
                "back": "",
                "type": "definition",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Usage Example"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Usage-Example-Signals",
                "title": "Signals",
                "front": "Signals",
                "back": "1. **DREQ:** DMA request (from device)\n2. **HRQ:** Hold request (to processor)\n3. **HLDA:** Hold acknowledge (from processor)\n4. **DACK:** DMA acknowledge (to device)",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Usage Example"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Usage-Example-Control-Bus-Signals",
                "title": "Control Bus Signals",
                "front": "Control Bus Signals",
                "back": "1. **IOR:** I/O read\n2. **IOW:** I/O write\n3. **MEMR:** Memory read\n4. **MEMW:** Memory write",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Usage Example"
              },
              {
                "id": "6-Direct-Memory-Access--DMA--DMA-Usage-Example-Operation",
                "title": "Operation",
                "front": "Operation",
                "back": "1. Device requests DMA (DREQ)\n2. DMA requests bus (HRQ)\n3. Processor acknowledges (HLDA)\n4. DMA transfers data using control signals\n5. DMA completes, releases bus",
                "type": "list",
                "section": "Direct Memory Access (DMA)",
                "subsection": "DMA Usage Example"
              }
            ]
          }
        ]
      },
      {
        "section": "I/O Controllers and Interfaces",
        "subsections": [
          {
            "subsection": "82C59A Programmable Interrupt Controller (PIC)",
            "cardCount": 5,
            "cards": [
              {
                "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Manage multiple interrupt sources.",
                "type": "definition",
                "section": "I/O Controllers and Interfaces",
                "subsection": "82C59A Programmable Interrupt Controller (PIC)"
              },
              {
                "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Features",
                "title": "Features",
                "front": "Features",
                "back": "1. **8 interrupt request lines (IR0-IR7)**\n2. Priority management\n3. Interrupt vector generation\n4. Cascading support",
                "type": "list",
                "section": "I/O Controllers and Interfaces",
                "subsection": "82C59A Programmable Interrupt Controller (PIC)"
              },
              {
                "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Cascading",
                "title": "Cascading",
                "front": "Cascading",
                "back": "1. Multiple PICs can be cascaded\n2. Master PIC connects to processor\n3. Slave PICs connect to master\n4. Example: 1 master + 3 slaves = 32 interrupt lines",
                "type": "list",
                "section": "I/O Controllers and Interfaces",
                "subsection": "82C59A Programmable Interrupt Controller (PIC)"
              },
              {
                "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Configuration",
                "title": "Configuration",
                "front": "Configuration",
                "back": "Master 82C59A ── Processor (INTR) ├── IR0-IR7 (8 devices) ├── Slave 82C59A (via IR) │ └── IR0-IR7 (8 devices) ├── Slave 82C59A (via IR) │ └── IR0-IR7 (8 devices) └── Slave 82C59A (via IR) └── IR0-IR7 (8 devices)",
                "type": "definition",
                "section": "I/O Controllers and Interfaces",
                "subsection": "82C59A Programmable Interrupt Controller (PIC)"
              },
              {
                "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Total",
                "title": "Total",
                "front": "Total",
                "back": "Up to 64 interrupt sources (with cascading)",
                "type": "definition",
                "section": "I/O Controllers and Interfaces",
                "subsection": "82C59A Programmable Interrupt Controller (PIC)"
              }
            ]
          },
          {
            "subsection": "8255A Programmable Peripheral Interface (PPI)",
            "cardCount": 5,
            "cards": [
              {
                "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Interface to parallel I/O devices.",
                "type": "definition",
                "section": "I/O Controllers and Interfaces",
                "subsection": "8255A Programmable Peripheral Interface (PPI)"
              },
              {
                "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Features",
                "title": "Features",
                "front": "Features",
                "back": "1. **Three 8-bit ports:** Port A, Port B, Port C\n2. **Port C split:** Upper (PC7-PC4) and Lower (PC3-PC0)\n3. **Multiple modes:** Input, output, bidirectional\n4. **Handshaking:** Control signals for device communication",
                "type": "list",
                "section": "I/O Controllers and Interfaces",
                "subsection": "8255A Programmable Peripheral Interface (PPI)"
              },
              {
                "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Ports",
                "title": "Ports",
                "front": "Ports",
                "back": "1. **Port A:** 8-bit I/O port (Group A)\n2. **Port B:** 8-bit I/O port (Group B)\n3. **Port C:** 8-bit I/O port or control signals",
                "type": "list",
                "section": "I/O Controllers and Interfaces",
                "subsection": "8255A Programmable Peripheral Interface (PPI)"
              },
              {
                "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Modes",
                "title": "Modes",
                "front": "Modes",
                "back": "1. **Mode 0:** Basic input/output\n2. **Mode 1:** Handshaking I/O\n3. **Mode 2:** Bidirectional bus",
                "type": "list",
                "section": "I/O Controllers and Interfaces",
                "subsection": "8255A Programmable Peripheral Interface (PPI)"
              },
              {
                "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Applications",
                "title": "Applications",
                "front": "Applications",
                "back": "1. Keyboard interfaces\n2. Display interfaces\n3. Parallel printer interfaces\n4. General-purpose I/O\n5. Port A: Keyboard input\n6. Port B: Display output\n7. Port C: Control signals (data ready, acknowledge)",
                "type": "list",
                "section": "I/O Controllers and Interfaces",
                "subsection": "8255A Programmable Peripheral Interface (PPI)"
              }
            ]
          }
        ]
      },
      {
        "section": "External Interconnection Standards",
        "subsections": [
          {
            "subsection": "Universal Serial Bus (USB)",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Interconnection-Standards-Universal-Serial-Bus--USB--Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Widely used for peripheral connections.",
                "type": "definition",
                "section": "External Interconnection Standards",
                "subsection": "Universal Serial Bus (USB)"
              },
              {
                "id": "6-External-Interconnection-Standards-Universal-Serial-Bus--USB--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Default interface** for slower speed devices (keyboard, mouse)\n2. **Commonly used** for high-speed I/O (printers, disk drives, network adapters)\n3. **Multiple generations:** USB 1.0, 2.0, 3.0, 3.1, 3.2, USB-C\n4. **Hot-pluggable:** Connect/disconnect without powering down\n5. **Automatic configuration:** Plug and play",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "Universal Serial Bus (USB)"
              },
              {
                "id": "6-External-Interconnection-Standards-Universal-Serial-Bus--USB--Advantages",
                "title": "Advantages",
                "front": "Advantages",
                "back": "1. Universal standard\n2. Easy to use\n3. Hot-pluggable\n4. Power delivery (USB-C)",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "Universal Serial Bus (USB)"
              }
            ]
          },
          {
            "subsection": "FireWire Serial Bus",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Interconnection-Standards-FireWire-Serial-Bus-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "High-speed I/O for smaller systems.",
                "type": "definition",
                "section": "External Interconnection Standards",
                "subsection": "FireWire Serial Bus"
              },
              {
                "id": "6-External-Interconnection-Standards-FireWire-Serial-Bus-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. Alternative to SCSI for personal computers\n2. **Daisy chain configuration:** Up to 63 devices\n3. **Hot plugging:** Connect/disconnect without power down\n4. **Automatic configuration**\n5. High I/O rates",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "FireWire Serial Bus"
              },
              {
                "id": "6-External-Interconnection-Standards-FireWire-Serial-Bus-Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. Video capture\n2. External storage\n3. Professional audio/video equipment",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "FireWire Serial Bus"
              }
            ]
          },
          {
            "subsection": "SCSI (Small Computer System Interface)",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Interconnection-Standards-SCSI--Small-Computer-System-Interface--Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Standard for connecting peripheral devices.",
                "type": "definition",
                "section": "External Interconnection Standards",
                "subsection": "SCSI (Small Computer System Interface)"
              },
              {
                "id": "6-External-Interconnection-Standards-SCSI--Small-Computer-System-Interface--Status",
                "title": "Status",
                "front": "Status",
                "back": "1. **Once common** for disks, modems, printers\n2. **Lost popularity** to USB and FireWire in smaller systems\n3. **High-speed versions** remain popular for enterprise systems\n4. Used in some mainframes",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "SCSI (Small Computer System Interface)"
              },
              {
                "id": "6-External-Interconnection-Standards-SCSI--Small-Computer-System-Interface--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. High performance\n2. Multiple device support\n3. More complex than USB",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "SCSI (Small Computer System Interface)"
              }
            ]
          },
          {
            "subsection": "Thunderbolt",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Interconnection-Standards-Thunderbolt-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Fastest peripheral connection technology.",
                "type": "definition",
                "section": "External Interconnection Standards",
                "subsection": "Thunderbolt"
              },
              {
                "id": "6-External-Interconnection-Standards-Thunderbolt-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Developed by Intel** with Apple collaboration\n2. **Combines:** Data, video, audio, and power\n3. **Single high-speed connection**\n4. Very high data rates",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "Thunderbolt"
              },
              {
                "id": "6-External-Interconnection-Standards-Thunderbolt-Applications",
                "title": "Applications",
                "front": "Applications",
                "back": "1. Hard drives\n2. RAID arrays\n3. Video-capture boxes\n4. Network interfaces",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "Thunderbolt"
              }
            ]
          },
          {
            "subsection": "InfiniBand",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Interconnection-Standards-InfiniBand-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "High-end server market I/O specification.",
                "type": "definition",
                "section": "External Interconnection Standards",
                "subsection": "InfiniBand"
              },
              {
                "id": "6-External-Interconnection-Standards-InfiniBand-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Heavily used** by IBM zEnterprise mainframes\n2. **Architecture** for data flow among processors and I/O devices\n3. **Storage area networking:** Popular for SAN\n4. **Central fabric:** Switches and links\n5. Very high performance",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "InfiniBand"
              },
              {
                "id": "6-External-Interconnection-Standards-InfiniBand-Use-Cases",
                "title": "Use Cases",
                "front": "Use Cases",
                "back": "1. Enterprise servers\n2. Storage area networks\n3. High-performance computing",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "InfiniBand"
              }
            ]
          },
          {
            "subsection": "SATA (Serial Advanced Technology Attachment)",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Interconnection-Standards-SATA--Serial-Advanced-Technology-Attachment--Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Interface for disk storage systems.",
                "type": "definition",
                "section": "External Interconnection Standards",
                "subsection": "SATA (Serial Advanced Technology Attachment)"
              },
              {
                "id": "6-External-Interconnection-Standards-SATA--Serial-Advanced-Technology-Attachment--Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Data rates:** Up to 6 Gbps\n2. **Maximum per device:** 300 Mbps\n3. **Widely used:** Desktop computers, industrial, embedded\n4. Replaced parallel ATA (PATA)",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "SATA (Serial Advanced Technology Attachment)"
              },
              {
                "id": "6-External-Interconnection-Standards-SATA--Serial-Advanced-Technology-Attachment--Generations",
                "title": "Generations",
                "front": "Generations",
                "back": "1. SATA 1.0: 1.5 Gbps\n2. SATA 2.0: 3 Gbps\n3. SATA 3.0: 6 Gbps",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "SATA (Serial Advanced Technology Attachment)"
              }
            ]
          },
          {
            "subsection": "PCI Express",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Interconnection-Standards-PCI-Express-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "High-speed bus system for peripherals.",
                "type": "definition",
                "section": "External Interconnection Standards",
                "subsection": "PCI Express"
              },
              {
                "id": "6-External-Interconnection-Standards-PCI-Express-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Wide variety** of device types and speeds\n2. **Point-to-point** connections\n3. **Scalable:** x1, x4, x8, x16 lanes\n4. Very high bandwidth",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "PCI Express"
              },
              {
                "id": "6-External-Interconnection-Standards-PCI-Express-Applications",
                "title": "Applications",
                "front": "Applications",
                "back": "1. Graphics cards\n2. Network adapters\n3. Storage controllers\n4. High-speed peripherals",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "PCI Express"
              }
            ]
          },
          {
            "subsection": "Ethernet",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Interconnection-Standards-Ethernet-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Predominant wired networking technology.",
                "type": "definition",
                "section": "External Interconnection Standards",
                "subsection": "Ethernet"
              },
              {
                "id": "6-External-Interconnection-Standards-Ethernet-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **Data rates:** Up to 100 Gbps\n2. **Distances:** Few meters to tens of kilometers\n3. **Widely used:** Local area networks\n4. **Standard:** IEEE 802.3",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "Ethernet"
              },
              {
                "id": "6-External-Interconnection-Standards-Ethernet-Evolution",
                "title": "Evolution",
                "front": "Evolution",
                "back": "1. 10 Mbps → 100 Mbps → 1 Gbps → 10 Gbps → 100 Gbps",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "Ethernet"
              }
            ]
          },
          {
            "subsection": "WiFi",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-External-Interconnection-Standards-WiFi-Purpose",
                "title": "Purpose",
                "front": "Purpose",
                "back": "Predominant wireless Internet access technology.",
                "type": "definition",
                "section": "External Interconnection Standards",
                "subsection": "WiFi"
              },
              {
                "id": "6-External-Interconnection-Standards-WiFi-Characteristics",
                "title": "Characteristics",
                "front": "Characteristics",
                "back": "1. **IEEE 802.11** standards\n2. **Multiple versions:** 802.11a/b/g/n/ac/ax\n3. **Increasing speeds** with each generation\n4. **Public hotspots:** Free Internet access",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "WiFi"
              },
              {
                "id": "6-External-Interconnection-Standards-WiFi-Evolution",
                "title": "Evolution",
                "front": "Evolution",
                "back": "1. 802.11: 2 Mbps\n2. 802.11b: 11 Mbps\n3. 802.11g: 54 Mbps\n4. 802.11n: 600 Mbps\n5. 802.11ac: 6.77 Gbps\n6. 802.11ax (WiFi 6): Higher speeds",
                "type": "list",
                "section": "External Interconnection Standards",
                "subsection": "WiFi"
              }
            ]
          }
        ]
      },
      {
        "section": "Evolution of I/O Function",
        "subsections": [
          {
            "subsection": "Six Stages of Evolution",
            "cardCount": 7,
            "cards": [
              {
                "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-1--CPU-Direct-Control",
                "title": "1. CPU Direct Control",
                "front": "1. CPU Direct Control",
                "back": "1. CPU directly controls peripheral device\n2. Simplest but least efficient\n3. CPU tied up during I/O",
                "type": "list",
                "section": "Evolution of I/O Function",
                "subsection": "Six Stages of Evolution"
              },
              {
                "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-2--Controller-I-O-Module-Added--Programmed-I-O-",
                "title": "2. Controller/I/O Module Added (Programmed I/O)",
                "front": "2. Controller/I/O Module Added (Programmed I/O)",
                "back": "1. I/O module added\n2. CPU uses programmed I/O without interrupts\n3. CPU still waits for I/O\n4. Better than direct control",
                "type": "list",
                "section": "Evolution of I/O Function",
                "subsection": "Six Stages of Evolution"
              },
              {
                "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-3--Interrupts-Employed",
                "title": "3. Interrupts Employed",
                "front": "3. Interrupts Employed",
                "back": "1. Same configuration as stage 2\n2. But now interrupts are used\n3. CPU need not wait\n4. **Increases efficiency**",
                "type": "list",
                "section": "Evolution of I/O Function",
                "subsection": "Six Stages of Evolution"
              },
              {
                "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-4--DMA-Added",
                "title": "4. DMA Added",
                "front": "4. DMA Added",
                "back": "1. I/O module given direct access to memory\n2. Can move block of data without CPU involvement\n3. CPU only involved at beginning and end\n4. **Much more efficient** for large transfers",
                "type": "list",
                "section": "Evolution of I/O Function",
                "subsection": "Six Stages of Evolution"
              },
              {
                "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-5--I-O-Module-as-Processor",
                "title": "5. I/O Module as Processor",
                "front": "5. I/O Module as Processor",
                "back": "1. I/O module enhanced to become processor\n2. Specialized instruction set for I/O\n3. Can execute I/O programs\n4. **Reduces CPU involvement further**",
                "type": "list",
                "section": "Evolution of I/O Function",
                "subsection": "Six Stages of Evolution"
              },
              {
                "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-6--I-O-Module-with-Local-Memory",
                "title": "6. I/O Module with Local Memory",
                "front": "6. I/O Module with Local Memory",
                "back": "1. I/O module has local memory\n2. Computer in its own right\n3. Large set of I/O devices controlled with minimal CPU involvement\n4. **Maximum efficiency**",
                "type": "list",
                "section": "Evolution of I/O Function",
                "subsection": "Six Stages of Evolution"
              },
              {
                "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-Trend",
                "title": "Trend",
                "front": "Trend",
                "back": "Increasing autonomy of I/O modules, reducing CPU involvement.",
                "type": "definition",
                "section": "Evolution of I/O Function",
                "subsection": "Six Stages of Evolution"
              }
            ]
          }
        ]
      },
      {
        "section": "Key Concepts Summary",
        "subsections": [
          {
            "subsection": "I/O Module Functions",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-Key-Concepts-Summary-I-O-Module-Functions-I-O-Module-Functions",
                "title": "I/O Module Functions",
                "front": "I/O Module Functions",
                "back": "1. **Control and Timing:** Coordinate traffic flow\n2. **Processor Communication:** Commands, data, status\n3. **Device Communication:** Device-specific protocols\n4. **Data Buffering:** Speed matching\n5. **Error Detection:** Detect and report errors",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "I/O Module Functions"
              }
            ]
          },
          {
            "subsection": "I/O Techniques",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-Key-Concepts-Summary-I-O-Techniques-I-O-Techniques",
                "title": "I/O Techniques",
                "front": "I/O Techniques",
                "back": "1. **Programmed I/O:** CPU waits, simple but inefficient\n2. **Interrupt-Driven I/O:** CPU does other work, more efficient\n3. **DMA:** Direct memory access, most efficient for large transfers",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "I/O Techniques"
              }
            ]
          },
          {
            "subsection": "I/O Addressing",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-Key-Concepts-Summary-I-O-Addressing-I-O-Addressing",
                "title": "I/O Addressing",
                "front": "I/O Addressing",
                "back": "1. **Memory-Mapped I/O:** Shared address space, flexible\n2. **Isolated I/O:** Separate address spaces, full memory space",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "I/O Addressing"
              }
            ]
          },
          {
            "subsection": "Interrupts",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-Key-Concepts-Summary-Interrupts-Interrupts",
                "title": "Interrupts",
                "front": "Interrupts",
                "back": "1. **Device Identification:** Multiple lines, daisy chain, bus arbitration, software poll\n2. **Priority:** Fixed or programmable, nested interrupts\n3. **Processing:** Save state, service interrupt, restore state",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Interrupts"
              }
            ]
          },
          {
            "subsection": "DMA",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-Key-Concepts-Summary-DMA-DMA",
                "title": "DMA",
                "front": "DMA",
                "back": "1. **Purpose:** Direct I/O-to-memory transfer\n2. **Operation:** CPU sets up, DMA transfers, CPU notified\n3. **Configurations:** Single bus, integrated, I/O bus\n4. **Fly-by:** Data doesn't pass through DMA chip",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "DMA"
              }
            ]
          },
          {
            "subsection": "Evolution",
            "cardCount": 1,
            "cards": [
              {
                "id": "6-Key-Concepts-Summary-Evolution-Evolution",
                "title": "Evolution",
                "front": "Evolution",
                "back": "1. **Trend:** Increasing I/O module autonomy\n2. **Goal:** Reduce CPU involvement\n3. **Result:** Better system efficiency",
                "type": "list",
                "section": "Key Concepts Summary",
                "subsection": "Evolution"
              }
            ]
          }
        ]
      },
      {
        "section": "Practice Problems and Examples",
        "subsections": [
          {
            "subsection": "Problem 1: I/O Technique Selection",
            "cardCount": 2,
            "cards": [
              {
                "id": "6-Practice-Problems-and-Examples-Problem-1--I-O-Technique-Selection-Question",
                "title": "Question",
                "front": "Question",
                "back": "Which I/O technique is best for: a) Reading a single byte from keyboard b) Transferring 1 MB file from disk to memory c) Checking printer status",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: I/O Technique Selection"
              },
              {
                "id": "6-Practice-Problems-and-Examples-Problem-1--I-O-Technique-Selection-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "a) **Interrupt-Driven I/O:** Small transfer, device-initiated b) **DMA:** Large transfer, needs efficiency c) **Programmed I/O:** Simple status check",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 1: I/O Technique Selection"
              }
            ]
          },
          {
            "subsection": "Problem 2: Memory-Mapped I/O Address Space",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-Practice-Problems-and-Examples-Problem-2--Memory-Mapped-I-O-Address-Space-Question",
                "title": "Question",
                "front": "Question",
                "back": "System has 16-bit address bus, uses memory-mapped I/O. If 48 KB memory, how many I/O addresses available?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Memory-Mapped I/O Address Space"
              },
              {
                "id": "6-Practice-Problems-and-Examples-Problem-2--Memory-Mapped-I-O-Address-Space-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Total address space: 2^16 = 64 KB Memory: 48 KB = 48,000 bytes I/O addresses: 64 KB - 48 KB = 16 KB = 16,384 addresses",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Memory-Mapped I/O Address Space"
              },
              {
                "id": "6-Practice-Problems-and-Examples-Problem-2--Memory-Mapped-I-O-Address-Space-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "16,384 I/O addresses",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 2: Memory-Mapped I/O Address Space"
              }
            ]
          },
          {
            "subsection": "Problem 3: DMA Transfer Time",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-Practice-Problems-and-Examples-Problem-3--DMA-Transfer-Time-Question",
                "title": "Question",
                "front": "Question",
                "back": "DMA transfers 64 KB block. Memory access time 100 ns, I/O device rate 10 MB/s. How long does transfer take?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: DMA Transfer Time"
              },
              {
                "id": "6-Practice-Problems-and-Examples-Problem-3--DMA-Transfer-Time-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Data size: 64 KB = 65,536 bytes I/O device rate: 10 MB/s = 10,000,000 bytes/s Transfer time = 65,536 / 10,000,000 = 0.0065536 s = 6.55 ms",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: DMA Transfer Time"
              },
              {
                "id": "6-Practice-Problems-and-Examples-Problem-3--DMA-Transfer-Time-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "6.55 ms (CPU free during this time)",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 3: DMA Transfer Time"
              }
            ]
          },
          {
            "subsection": "Problem 4: Interrupt Overhead",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-Practice-Problems-and-Examples-Problem-4--Interrupt-Overhead-Question",
                "title": "Question",
                "front": "Question",
                "back": "Interrupt service routine takes 50 cycles. System has 1000 interrupts/second. What is interrupt overhead?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Interrupt Overhead"
              },
              {
                "id": "6-Practice-Problems-and-Examples-Problem-4--Interrupt-Overhead-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "Interrupts per second: 1000 Cycles per interrupt: 50 Total cycles per second: 1000 × 50 = 50,000 cycles If CPU runs at 1 GHz (1,000,000,000 cycles/s): Overhead = 50,000 / 1,000,000,000 = 0.00005 = 0.005%",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Interrupt Overhead"
              },
              {
                "id": "6-Practice-Problems-and-Examples-Problem-4--Interrupt-Overhead-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "0.005% CPU overhead",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 4: Interrupt Overhead"
              }
            ]
          },
          {
            "subsection": "Problem 5: Programmed vs. Interrupt-Driven I/O",
            "cardCount": 3,
            "cards": [
              {
                "id": "6-Practice-Problems-and-Examples-Problem-5--Programmed-vs--Interrupt-Driven-I-O-Question",
                "title": "Question",
                "front": "Question",
                "back": "Device transfers 1 byte every 10 ms. Programmed I/O: CPU checks every 1 μs. Interrupt-driven: 100 cycle overhead per interrupt. Which is more efficient?",
                "type": "definition",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Programmed vs. Interrupt-Driven I/O"
              },
              {
                "id": "6-Practice-Problems-and-Examples-Problem-5--Programmed-vs--Interrupt-Driven-I-O-Solution",
                "title": "Solution",
                "front": "Solution",
                "back": "1. Checks every 1 μs\n2. 10 ms = 10,000 μs\n3. Number of checks: 10,000\n4. Wastes 10,000 checks\n5. One interrupt per byte\n6. 100 cycles overhead\n7. CPU free for 10 ms - interrupt time\n8. Much more efficient",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Programmed vs. Interrupt-Driven I/O"
              },
              {
                "id": "6-Practice-Problems-and-Examples-Problem-5--Programmed-vs--Interrupt-Driven-I-O-Answer",
                "title": "Answer",
                "front": "Answer",
                "back": "1. **Understand the Evolution:**\n2. Why each technique developed\n3. Trade-offs between techniques\n4. When to use each\n5. **Master DMA Concepts:**\n6. How DMA works\n7. When DMA is beneficial\n8. DMA configurations\n9. **Compare Techniques:**\n10. Programmed vs. Interrupt vs. DMA\n11. Memory-mapped vs. Isolated I/O\n12. Different device identification methods\n13. **Understand Interrupts:**\n14. Interrupt processing flow\n15. Device identification\n16. Priority handling\n17. **Know Standards:**\n18. Common I/O standards\n19. Their characteristics\n20. When each is used\n21. **I/O modules** bridge processor/memory and peripherals\n22. **Three I/O techniques** provide different efficiency levels\n23. **Interrupts** enable asynchronous I/O\n24. **DMA** provides maximum efficiency for large transfers\n25. **I/O standards** enable device connectivity\n26. I/O is often the system bottleneck\n27. I/O design impacts overall performance\n28. I/O completes the communication picture\n29. Modern systems rely heavily on efficient I/O",
                "type": "list",
                "section": "Practice Problems and Examples",
                "subsection": "Problem 5: Programmed vs. Interrupt-Driven I/O"
              }
            ]
          }
        ]
      }
    ],
    "allCards": [
      {
        "id": "6-Detailed-Study-Guide--Detailed-Study-Guide",
        "title": "Detailed Study Guide",
        "front": "Detailed Study Guide",
        "back": "1. [Introduction to I/O Systems](#introduction-to-io-systems)\n2. [I/O Module Structure and Functions](#io-module-structure-and-functions)\n3. [External Devices](#external-devices)\n4. [I/O Techniques](#io-techniques)\n5. [I/O Mapping and Addressing](#io-mapping-and-addressing)\n6. [Interrupt-Driven I/O](#interrupt-driven-io)\n7. [Direct Memory Access (DMA)](#direct-memory-access-dma)\n8. [I/O Controllers and Interfaces](#io-controllers-and-interfaces)\n9. [External Interconnection Standards](#external-interconnection-standards)\n10. [Evolution of I/O Function](#evolution-of-io-function)\n11. [Key Concepts Summary](#key-concepts-summary)\n12. [Practice Problems and Examples](#practice-problems-and-examples)",
        "type": "list",
        "section": "Detailed Study Guide",
        "subsection": ""
      },
      {
        "id": "6-Introduction-to-I-O-Systems-Why-I-O-Modules-are-Needed-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "Why not connect peripherals directly to system bus?",
        "type": "definition",
        "section": "Introduction to I/O Systems",
        "subsection": "Why I/O Modules are Needed"
      },
      {
        "id": "6-Introduction-to-I-O-Systems-Why-I-O-Modules-are-Needed-Reasons",
        "title": "Reasons",
        "front": "Reasons",
        "back": "1. **Wide Variety of Peripherals:**\n2. Different methods of operation\n3. Different data formats\n4. Different speeds\n5. **Impractical** to incorporate control logic within processor\n6. **Speed Mismatch:**\n7. **Peripherals often slower** than memory/processor\n8. Impractical to use high-speed system bus directly\n9. Would waste bus bandwidth\n10. **Some Peripherals Faster:**\n11. Some devices faster than memory/processor\n12. Mismatch leads to inefficiencies if not managed\n13. **Data Format Differences:**\n14. Peripherals use different data formats\n15. Different word lengths\n16. Need conversion/translation",
        "type": "list",
        "section": "Introduction to I/O Systems",
        "subsection": "Why I/O Modules are Needed"
      },
      {
        "id": "6-Introduction-to-I-O-Systems-Why-I-O-Modules-are-Needed-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "**I/O Module** required to interface between processor/memory and peripherals.",
        "type": "definition",
        "section": "Introduction to I/O Systems",
        "subsection": "Why I/O Modules are Needed"
      },
      {
        "id": "6-Introduction-to-I-O-Systems-I-O-Module-Purpose-Two-Major-Functions",
        "title": "Two Major Functions",
        "front": "Two Major Functions",
        "back": "1. **Interface to Processor and Memory:**\n2. Via system bus or central switch\n3. Handles communication with CPU\n4. Manages data transfer to/from memory\n5. **Interface to Peripheral Devices:**\n6. Via data links\n7. Handles device-specific protocols\n8. Manages device control and status",
        "type": "list",
        "section": "Introduction to I/O Systems",
        "subsection": "I/O Module Purpose"
      },
      {
        "id": "6-Introduction-to-I-O-Systems-I-O-Module-Purpose-Result",
        "title": "Result",
        "front": "Result",
        "back": "I/O module acts as **translator** and **buffer** between system and peripherals.",
        "type": "definition",
        "section": "Introduction to I/O Systems",
        "subsection": "I/O Module Purpose"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Generic-I-O-Module-Model-Components",
        "title": "Components",
        "front": "Components",
        "back": "1. **Address Lines:** Identify I/O module and device\n2. **Data Lines:** Transfer data\n3. **Control Lines:** Control and timing signals\n4. **Links to Peripheral Devices:** Device-specific interfaces",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Generic I/O Module Model"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-1--Control-and-Timing",
        "title": "1. Control and Timing",
        "front": "1. Control and Timing",
        "back": "",
        "type": "concept",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Coordinate flow of traffic between internal resources and external devices.",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Responsibilities",
        "title": "Responsibilities",
        "front": "Responsibilities",
        "back": "1. Coordinate processor and I/O module interactions\n2. Manage shared resources (bus, memory)\n3. Handle timing of operations",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Example-Sequence",
        "title": "Example Sequence",
        "front": "Example Sequence",
        "back": "1. Processor interrogates I/O module (check device status)\n2. I/O module returns device status\n3. If device ready, processor requests data transfer\n4. I/O module obtains data from external device\n5. Data transferred from I/O module to processor",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Bus-Arbitration",
        "title": "Bus Arbitration",
        "front": "Bus Arbitration",
        "back": "1. Each interaction may involve bus arbitration\n2. Multiple devices competing for bus access\n3. I/O module must coordinate with bus controller",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-2--Processor-Communication",
        "title": "2. Processor Communication",
        "front": "2. Processor Communication",
        "back": "",
        "type": "concept",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Enable communication between processor and I/O module.",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Components",
        "title": "Components",
        "front": "Components",
        "back": "",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Command-Decoding",
        "title": "Command Decoding",
        "front": "Command Decoding",
        "back": "1. I/O module accepts commands from processor\n2. Commands sent as signals on control bus\n3. Example: Disk drive commands (READ SECTOR, WRITE SECTOR, SEEK)",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Data-Exchange",
        "title": "Data Exchange",
        "front": "Data Exchange",
        "back": "1. Data exchanged over data bus\n2. Bidirectional communication\n3. Handles data format conversion",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Status-Reporting",
        "title": "Status Reporting",
        "front": "Status Reporting",
        "back": "1. **Critical:** Peripherals are slow\n2. I/O module reports status to processor\n3. Common status signals:\n4. **BUSY:** Module working on previous command\n5. **READY:** Module ready for new command\n6. Processor can check status before proceeding",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Address-Recognition",
        "title": "Address Recognition",
        "front": "Address Recognition",
        "back": "1. Each I/O device has unique address\n2. I/O module recognizes address for its peripherals\n3. Similar to memory addressing",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-3--Device-Communication",
        "title": "3. Device Communication",
        "front": "3. Device Communication",
        "back": "",
        "type": "concept",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Enable communication between I/O module and external device.",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Components",
        "title": "Components",
        "front": "Components",
        "back": "1. **Commands:** I/O module sends commands to device\n2. **Status Information:** Device reports status to I/O module\n3. **Data:** Actual data transfer",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Device-Specific",
        "title": "Device-Specific",
        "front": "Device-Specific",
        "back": "1. Each device type has different protocol\n2. I/O module handles device-specific communication\n3. Abstracts device details from processor",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-4--Data-Buffering",
        "title": "4. Data Buffering",
        "front": "4. Data Buffering",
        "back": "",
        "type": "concept",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Balance speed differences between device and memory.",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "1. **Memory/Processor:** Very high transfer rates\n2. **Peripherals:** Often much slower (orders of magnitude)",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Solution---Buffering",
        "title": "Solution - Buffering",
        "front": "Solution - Buffering",
        "back": "",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-From-Memory-to-Device",
        "title": "From Memory to Device",
        "front": "From Memory to Device",
        "back": "1. Data sent from memory in rapid burst\n2. **Buffered in I/O module**\n3. Sent to device at device's slower rate",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-From-Device-to-Memory",
        "title": "From Device to Memory",
        "front": "From Device to Memory",
        "back": "1. Data received from device slowly\n2. **Buffered in I/O module**\n3. Prevents tying up memory in slow transfer\n4. Can accumulate data before transferring to memory",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Speed-Matching",
        "title": "Speed Matching",
        "front": "Speed Matching",
        "back": "1. I/O module must operate at **both** device and memory speeds\n2. Handles speed conversion\n3. Prevents bottlenecks",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Fast-Devices",
        "title": "Fast Devices",
        "front": "Fast Devices",
        "back": "1. Some devices faster than memory\n2. I/O module buffers to prevent memory bottleneck\n3. Manages high-speed data streams",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-5--Error-Detection",
        "title": "5. Error Detection",
        "front": "5. Error Detection",
        "back": "",
        "type": "concept",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Detect and report errors to processor.",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Error-Types",
        "title": "Error Types",
        "front": "Error Types",
        "back": "",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-1--Mechanical-Electrical-Malfunctions",
        "title": "1. Mechanical/Electrical Malfunctions",
        "front": "1. Mechanical/Electrical Malfunctions",
        "back": "1. Reported by device itself\n2. Examples:\n3. Paper jam (printer)\n4. Bad disk track\n5. Device failure",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-2--Transmission-Errors",
        "title": "2. Transmission Errors",
        "front": "2. Transmission Errors",
        "back": "1. Unintentional changes to bit pattern\n2. During transmission from device to I/O module\n3. Need error detection codes",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Error-Detection-Methods",
        "title": "Error Detection Methods",
        "front": "Error Detection Methods",
        "back": "",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-Parity-Bit",
        "title": "Parity Bit",
        "front": "Parity Bit",
        "back": "1. Simple example: Parity bit on each character\n2. Example: IRA character code (7 bits) + 1 parity bit\n3. **Even parity:** Total number of 1s is even\n4. **Odd parity:** Total number of 1s is odd\n5. I/O module checks parity on receipt\n6. Detects single-bit errors",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-Major-Functions-of-I-O-Module-More-Advanced",
        "title": "More Advanced",
        "front": "More Advanced",
        "back": "1. CRC (Cyclic Redundancy Check)\n2. Checksums\n3. Error-correcting codes",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "Major Functions of I/O Module"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-I-O-Module-Block-Diagram-Internal-Structure",
        "title": "Internal Structure",
        "front": "Internal Structure",
        "back": "Interface to System Bus: ├── Address Lines ├── Data Lines └── Control Lines I/O Module: ├── Data Registers ├── Status/Control Registers ├── I/O Logic │ ├── Address Recognition │ ├── Command Decoding │ └── Status Reporting └── Device Interface Logic Interface to External Device: ├── Data Lines ├── Status Lines └── Control Lines",
        "type": "definition",
        "section": "I/O Module Structure and Functions",
        "subsection": "I/O Module Block Diagram"
      },
      {
        "id": "6-I-O-Module-Structure-and-Functions-I-O-Module-Block-Diagram-Registers",
        "title": "Registers",
        "front": "Registers",
        "back": "1. **Data Registers:** Hold data being transferred\n2. **Status/Control Registers:** Device status and control information",
        "type": "list",
        "section": "I/O Module Structure and Functions",
        "subsection": "I/O Module Block Diagram"
      },
      {
        "id": "6-External-Devices-What-are-External-Devices--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Provide means of exchanging data between external environment and computer.",
        "type": "definition",
        "section": "External Devices",
        "subsection": "What are External Devices?"
      },
      {
        "id": "6-External-Devices-What-are-External-Devices--Connection",
        "title": "Connection",
        "front": "Connection",
        "back": "Attached to computer by link to I/O module.",
        "type": "definition",
        "section": "External Devices",
        "subsection": "What are External Devices?"
      },
      {
        "id": "6-External-Devices-What-are-External-Devices--Link-Purpose",
        "title": "Link Purpose",
        "front": "Link Purpose",
        "back": "Exchange control, status, and data between I/O module and external device.",
        "type": "definition",
        "section": "External Devices",
        "subsection": "What are External Devices?"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-1--Human-Readable",
        "title": "1. Human Readable",
        "front": "1. Human Readable",
        "back": "",
        "type": "concept",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Suitable for communicating with computer user.",
        "type": "definition",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **Video display terminals:** Monitors, screens\n2. **Printers:** Output devices\n3. **Keyboards:** Input devices\n4. **Mice:** Input devices",
        "type": "list",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Designed for human interaction\n2. Text, graphics, audio output\n3. Human-readable input",
        "type": "list",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-2--Machine-Readable",
        "title": "2. Machine Readable",
        "front": "2. Machine Readable",
        "back": "",
        "type": "concept",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Suitable for communicating with equipment.",
        "type": "definition",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **Magnetic disk and tape systems:** Storage devices\n2. **Sensors:** Environmental sensors, temperature, pressure\n3. **Actuators:** Motors, valves, switches",
        "type": "list",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Designed for machine-to-machine communication\n2. Binary data formats\n3. Automated operation",
        "type": "list",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-3--Communication",
        "title": "3. Communication",
        "front": "3. Communication",
        "back": "",
        "type": "concept",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Suitable for communicating with remote devices.",
        "type": "definition",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-Examples",
        "title": "Examples",
        "front": "Examples",
        "back": "1. **Terminals:** Remote terminals\n2. **Machine readable devices:** Remote equipment\n3. **Other computers:** Network communication",
        "type": "list",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Categories-of-External-Devices-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Network connectivity\n2. Remote access\n3. Protocol-based communication",
        "type": "list",
        "section": "External Devices",
        "subsection": "Categories of External Devices"
      },
      {
        "id": "6-External-Devices-Block-Diagram-of-External-Device-Components",
        "title": "Components",
        "front": "Components",
        "back": "1. **Transducer:**\n2. Converts between physical world and electrical signals\n3. Input: Physical → Electrical\n4. Output: Electrical → Physical\n5. **Buffer:**\n6. Temporary storage\n7. Holds data during transfer\n8. Speed matching\n9. **Control Logic:**\n10. Device control functions\n11. Interprets control signals\n12. Manages device operation",
        "type": "list",
        "section": "External Devices",
        "subsection": "Block Diagram of External Device"
      },
      {
        "id": "6-External-Devices-Block-Diagram-of-External-Device-Signals",
        "title": "Signals",
        "front": "Signals",
        "back": "1. **Control signals from I/O module:** Determine device function\n2. **Status signals to I/O module:** Indicate device state\n3. **Data bits:** To and from I/O module\n4. **Data to/from environment:** Device-specific data",
        "type": "list",
        "section": "External Devices",
        "subsection": "Block Diagram of External Device"
      },
      {
        "id": "6-I-O-Techniques-Three-I-O-Techniques-Classification",
        "title": "Classification",
        "front": "Classification",
        "back": "1. **Programmed I/O**\n2. No interrupts\n3. I/O-to-memory transfer through processor\n4. **Interrupt-Driven I/O**\n5. Use of interrupts\n6. I/O-to-memory transfer through processor\n7. **Direct Memory Access (DMA)**\n8. Use of interrupts\n9. Direct I/O-to-memory transfer",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Three I/O Techniques"
      },
      {
        "id": "6-I-O-Techniques-Three-I-O-Techniques-Key-Difference",
        "title": "Key Difference",
        "front": "Key Difference",
        "back": "Role of processor in data transfer.",
        "type": "definition",
        "section": "I/O Techniques",
        "subsection": "Three I/O Techniques"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "",
        "type": "concept",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "Processor directly controls I/O operation.",
        "type": "definition",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Process",
        "title": "Process",
        "front": "Process",
        "back": "1. Processor executes I/O instruction\n2. Issues command to I/O module\n3. I/O module performs action\n4. Sets status bits in status register\n5. **Processor must periodically check status**\n6. Processor waits until operation complete",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Key-Characteristic",
        "title": "Key Characteristic",
        "front": "Key Characteristic",
        "back": "**I/O module does NOT interrupt processor.**",
        "type": "definition",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Processor-Responsibility",
        "title": "Processor Responsibility",
        "front": "Processor Responsibility",
        "back": "1. Must check status repeatedly\n2. Waits for I/O completion\n3. Cannot do other work while waiting",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-I-O-Commands",
        "title": "I/O Commands",
        "front": "I/O Commands",
        "back": "",
        "type": "concept",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Four-Types-of-I-O-Commands",
        "title": "Four Types of I/O Commands",
        "front": "Four Types of I/O Commands",
        "back": "1. **Control:**\n2. Activate peripheral\n3. Tell device what to do\n4. Example: Start printer, seek disk track\n5. **Test:**\n6. Test status conditions\n7. Check I/O module and peripheral status\n8. Example: Check if device ready, check for errors\n9. **Read:**\n10. I/O module obtains data from peripheral\n11. Places data in internal buffer\n12. Processor reads from buffer\n13. **Write:**\n14. I/O module takes data from data bus\n15. Transmits data to peripheral\n16. Processor writes to I/O module",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Programmed-I-O-Flow",
        "title": "Programmed I/O Flow",
        "front": "Programmed I/O Flow",
        "back": "",
        "type": "concept",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Input-of-Block-of-Data",
        "title": "Input of Block of Data",
        "front": "Input of Block of Data",
        "back": "1. Issue Read command to I/O module\n2. Read status of I/O module\n3. Check if ready\n4. If not ready: Loop back to step 2\n5. If ready: Continue\n6. Read word from I/O module\n7. Write word into memory\n8. Check if done\n9. If not done: Go to step 1 (next word)\n10. If done: Next instruction",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **CPU waits:** Processor tied up during I/O\n2. **Polling:** Must check status repeatedly\n3. **Inefficient:** Wastes processor time\n4. **Simple:** Easy to implement",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Programmed-I-O-Drawbacks",
        "title": "Drawbacks",
        "front": "Drawbacks",
        "back": "1. Processor cannot do other work\n2. Wastes CPU cycles checking status\n3. Slow for slow devices",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Programmed I/O"
      },
      {
        "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "",
        "type": "concept",
        "section": "I/O Techniques",
        "subsection": "Interrupt-Driven I/O"
      },
      {
        "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "I/O module interrupts processor when ready.",
        "type": "definition",
        "section": "I/O Techniques",
        "subsection": "Interrupt-Driven I/O"
      },
      {
        "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Process",
        "title": "Process",
        "front": "Process",
        "back": "1. Processor issues I/O command\n2. **Processor continues executing other instructions**\n3. I/O module works on I/O operation\n4. When ready, I/O module **interrupts processor**\n5. Processor handles interrupt\n6. Executes data transfer\n7. Resumes former processing",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Interrupt-Driven I/O"
      },
      {
        "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Key-Advantage",
        "title": "Key Advantage",
        "front": "Key Advantage",
        "back": "**Processor can do other work while waiting.**",
        "type": "definition",
        "section": "I/O Techniques",
        "subsection": "Interrupt-Driven I/O"
      },
      {
        "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Interrupt-Driven-I-O-Flow",
        "title": "Interrupt-Driven I/O Flow",
        "front": "Interrupt-Driven I/O Flow",
        "back": "",
        "type": "concept",
        "section": "I/O Techniques",
        "subsection": "Interrupt-Driven I/O"
      },
      {
        "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Input-of-Block-of-Data",
        "title": "Input of Block of Data",
        "front": "Input of Block of Data",
        "back": "1. Issue Read command to I/O module\n2. Do something else (other instructions)\n3. Interrupt occurs (I/O module ready)\n4. Read status of I/O module\n5. Check for error condition\n6. Read word from I/O module\n7. Write word into memory\n8. Check if done\n9. If not done: Go to step 1\n10. If done: Return to interrupted program",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Interrupt-Driven I/O"
      },
      {
        "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **CPU not waiting:** Can do other work\n2. **Asynchronous:** I/O happens in background\n3. **Efficient:** Better CPU utilization\n4. **More complex:** Requires interrupt handling",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Interrupt-Driven I/O"
      },
      {
        "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Better CPU utilization\n2. Can handle multiple I/O operations\n3. More responsive system",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Interrupt-Driven I/O"
      },
      {
        "id": "6-I-O-Techniques-Interrupt-Driven-I-O-Drawbacks",
        "title": "Drawbacks",
        "front": "Drawbacks",
        "back": "1. Still involves processor in each transfer\n2. Interrupt overhead\n3. More complex than programmed I/O",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Interrupt-Driven I/O"
      },
      {
        "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "",
        "type": "concept",
        "section": "I/O Techniques",
        "subsection": "Direct Memory Access (DMA)"
      },
      {
        "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "I/O module and memory exchange data directly without processor involvement.",
        "type": "definition",
        "section": "I/O Techniques",
        "subsection": "Direct Memory Access (DMA)"
      },
      {
        "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Process",
        "title": "Process",
        "front": "Process",
        "back": "1. Processor issues block read command to DMA module\n2. **Processor continues executing other instructions**\n3. DMA module transfers entire block directly to/from memory\n4. DMA module interrupts processor when complete",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Direct Memory Access (DMA)"
      },
      {
        "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Key-Advantage",
        "title": "Key Advantage",
        "front": "Key Advantage",
        "back": "**Processor only involved at start and end.**",
        "type": "definition",
        "section": "I/O Techniques",
        "subsection": "Direct Memory Access (DMA)"
      },
      {
        "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--DMA-Flow",
        "title": "DMA Flow",
        "front": "DMA Flow",
        "back": "",
        "type": "concept",
        "section": "I/O Techniques",
        "subsection": "Direct Memory Access (DMA)"
      },
      {
        "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Input-of-Block-of-Data",
        "title": "Input of Block of Data",
        "front": "Input of Block of Data",
        "back": "1. Issue Read block command to DMA module\n2. Do something else (other instructions)\n3. DMA transfers data directly to memory\n4. Interrupt occurs (DMA complete)\n5. Read status of DMA module\n6. Check for error condition\n7. Next instruction",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Direct Memory Access (DMA)"
      },
      {
        "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Minimal CPU involvement:** Only at start and end\n2. **Direct transfer:** I/O to memory, bypassing CPU\n3. **Very efficient:** Best for large transfers\n4. **Most complex:** Requires DMA controller",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Direct Memory Access (DMA)"
      },
      {
        "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Maximum efficiency:** CPU free during transfer\n2. **High throughput:** Can transfer large blocks\n3. **Best for bulk data:** Disk, network transfers",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Direct Memory Access (DMA)"
      },
      {
        "id": "6-I-O-Techniques-Direct-Memory-Access--DMA--Drawbacks",
        "title": "Drawbacks",
        "front": "Drawbacks",
        "back": "1. Most complex implementation\n2. Requires DMA controller hardware\n3. Bus arbitration needed",
        "type": "list",
        "section": "I/O Techniques",
        "subsection": "Direct Memory Access (DMA)"
      },
      {
        "id": "6-I-O-Techniques-Comparison-of-I-O-Techniques-Evolution",
        "title": "Evolution",
        "front": "Evolution",
        "back": "Programmed → Interrupt-Driven → DMA (increasing efficiency and complexity)",
        "type": "definition",
        "section": "I/O Techniques",
        "subsection": "Comparison of I/O Techniques"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-The-Addressing-Problem-Question",
        "title": "Question",
        "front": "Question",
        "back": "How does processor identify I/O devices?",
        "type": "definition",
        "section": "I/O Mapping and Addressing",
        "subsection": "The Addressing Problem"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-The-Addressing-Problem-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "Two modes of addressing when processor, memory, and I/O share common bus.",
        "type": "definition",
        "section": "I/O Mapping and Addressing",
        "subsection": "The Addressing Problem"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "I/O devices and memory locations share **single address space**.",
        "type": "definition",
        "section": "I/O Mapping and Addressing",
        "subsection": "Memory-Mapped I/O"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. I/O looks just like memory read/write\n2. **No special commands** for I/O\n3. Processor uses **same machine instructions** for memory and I/O\n4. Status and data registers treated as memory locations",
        "type": "list",
        "section": "I/O Mapping and Addressing",
        "subsection": "Memory-Mapped I/O"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Address-Space",
        "title": "Address Space",
        "front": "Address Space",
        "back": "1. Combined total of memory and I/O addresses\n2. Example: 10 address lines → 2^10 = 1024 locations\n3. Can be any combination (e.g., 512 memory + 512 I/O)",
        "type": "list",
        "section": "I/O Mapping and Addressing",
        "subsection": "Memory-Mapped I/O"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Large selection of memory access commands available**\n2. Can use all memory instructions (load, store, arithmetic)\n3. Simpler instruction set\n4. Flexible addressing",
        "type": "list",
        "section": "I/O Mapping and Addressing",
        "subsection": "Memory-Mapped I/O"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Reduces memory address space**\n2. Memory and I/O compete for addresses\n3. Need to reserve address space for I/O",
        "type": "list",
        "section": "I/O Mapping and Addressing",
        "subsection": "Memory-Mapped I/O"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Memory-Mapped-I-O-Example",
        "title": "Example",
        "front": "Example",
        "back": "Address 516: Keyboard input data register Address 517: Keyboard input status register Load AC, 517 ; Get status Branch if Sign = 0, 202 ; Loop until ready Load AC, 516 ; Load data byte",
        "type": "definition",
        "section": "I/O Mapping and Addressing",
        "subsection": "Memory-Mapped I/O"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "**Separate address spaces** for memory and I/O.",
        "type": "definition",
        "section": "I/O Mapping and Addressing",
        "subsection": "Isolated I/O (Port-Mapped I/O)"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Need **I/O or memory select lines** on bus\n2. **Special commands** for I/O (IN, OUT, Test I/O)\n3. Limited set of I/O instructions\n4. I/O addresses separate from memory addresses",
        "type": "list",
        "section": "I/O Mapping and Addressing",
        "subsection": "Isolated I/O (Port-Mapped I/O)"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Address-Space",
        "title": "Address Space",
        "front": "Address Space",
        "back": "1. Memory: Full address space (e.g., 1024 locations)\n2. I/O: Separate address space (e.g., 1024 I/O ports)\n3. **Total:** More addressable locations",
        "type": "list",
        "section": "I/O Mapping and Addressing",
        "subsection": "Isolated I/O (Port-Mapped I/O)"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. **Full memory address space** available\n2. Memory and I/O don't compete\n3. Clear separation",
        "type": "list",
        "section": "I/O Mapping and Addressing",
        "subsection": "Isolated I/O (Port-Mapped I/O)"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Limited set of I/O instructions**\n2. Special instructions needed\n3. Less flexible than memory-mapped",
        "type": "list",
        "section": "I/O Mapping and Addressing",
        "subsection": "Isolated I/O (Port-Mapped I/O)"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Isolated-I-O--Port-Mapped-I-O--Example",
        "title": "Example",
        "front": "Example",
        "back": "Load I/O, 5 ; Initiate keyboard read Test I/O, 5 ; Check for completion Branch Not Ready, 201 ; Loop until complete In, 5 ; Load data byte",
        "type": "definition",
        "section": "I/O Mapping and Addressing",
        "subsection": "Isolated I/O (Port-Mapped I/O)"
      },
      {
        "id": "6-I-O-Mapping-and-Addressing-Comparison-Modern-Practice",
        "title": "Modern Practice",
        "front": "Modern Practice",
        "back": "Most systems use **memory-mapped I/O** for flexibility.",
        "type": "definition",
        "section": "I/O Mapping and Addressing",
        "subsection": "Comparison"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Why-Interrupt-Driven-I-O--Problem-with-Programmed-I-O",
        "title": "Problem with Programmed I/O",
        "front": "Problem with Programmed I/O",
        "back": "1. Processor must wait long time for I/O module\n2. Wastes processor time\n3. Inefficient",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Why Interrupt-Driven I/O?"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Why-Interrupt-Driven-I-O--Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Processor issues I/O command\n2. Goes on to do other useful work\n3. I/O module interrupts when ready\n4. Processor handles transfer and resumes",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Why Interrupt-Driven I/O?"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Simple-Interrupt-Processing-Hardware-Steps",
        "title": "Hardware Steps",
        "front": "Hardware Steps",
        "back": "1. Device controller issues interrupt\n2. Processor finishes current instruction\n3. Processor signals acknowledgment\n4. Processor pushes PSW and PC onto control stack",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Simple Interrupt Processing"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Simple-Interrupt-Processing-Software-Steps",
        "title": "Software Steps",
        "front": "Software Steps",
        "back": "1. Save remainder of process state information\n2. Process interrupt\n3. Restore process state information\n4. Restore old PSW and PC",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Simple Interrupt Processing"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Simple-Interrupt-Processing-Result",
        "title": "Result",
        "front": "Result",
        "back": "Processor loads new PC value based on interrupt, executes interrupt service routine, then returns.",
        "type": "definition",
        "section": "Interrupt-Driven I/O",
        "subsection": "Simple Interrupt Processing"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Changes-During-Interrupt-Before-Interrupt",
        "title": "Before Interrupt",
        "front": "Before Interrupt",
        "back": "1. Program Counter: N\n2. Stack Pointer: T\n3. General Registers: Various values\n4. User's Program executing",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Changes During Interrupt"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Changes-During-Interrupt-After-Interrupt",
        "title": "After Interrupt",
        "front": "After Interrupt",
        "back": "1. Program Counter: Y (interrupt service routine)\n2. Stack Pointer: T - M (pushed values)\n3. General Registers: Saved on stack\n4. Interrupt Service Routine executing",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Changes During Interrupt"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Changes-During-Interrupt-Return-from-Interrupt",
        "title": "Return from Interrupt",
        "front": "Return from Interrupt",
        "back": "1. Restore PC, PSW, registers from stack\n2. Resume user program at instruction N+1",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Changes During Interrupt"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Design-Issues-Two-Key-Questions",
        "title": "Two Key Questions",
        "front": "Two Key Questions",
        "back": "1. **Device Identification:**\n2. How does processor determine which device issued interrupt?\n3. Multiple I/O modules may interrupt\n4. **Priority:**\n5. If multiple interrupts occur, which to process first?\n6. Need priority system",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Design Issues"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Four-Categories",
        "title": "Four Categories",
        "front": "Four Categories",
        "back": "",
        "type": "definition",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-1--Multiple-Interrupt-Lines",
        "title": "1. Multiple Interrupt Lines",
        "front": "1. Multiple Interrupt Lines",
        "back": "",
        "type": "concept",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Separate interrupt line for each I/O module.",
        "type": "definition",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Most straightforward approach\n2. Processor knows device from interrupt line\n3. **Problem:** Limited number of interrupt lines\n4. Even with multiple lines, each line may have multiple modules",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Use",
        "title": "Use",
        "front": "Use",
        "back": "Simple systems, few devices",
        "type": "definition",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-2--Daisy-Chain--Hardware-Poll--Vectored-",
        "title": "2. Daisy Chain (Hardware Poll, Vectored)",
        "front": "2. Daisy Chain (Hardware Poll, Vectored)",
        "back": "",
        "type": "concept",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Interrupt acknowledge line daisy-chained through modules.",
        "type": "definition",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Process",
        "title": "Process",
        "front": "Process",
        "back": "1. Processor detects interrupt\n2. Processor responds on interrupt acknowledge line\n3. Signal passes through daisy chain\n4. First requesting module responds\n5. Module places **vector** (address/identifier) on data lines\n6. Processor uses vector to identify device",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Vector",
        "title": "Vector",
        "front": "Vector",
        "back": "1. Address of I/O module or unique identifier\n2. **Vectored interrupt:** Processor uses vector as pointer to service routine\n3. Avoids need for general interrupt service routine first",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Automatic device identification\n2. Fast (hardware-based)\n3. Vectored interrupts efficient",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. Fixed priority (order in chain)\n2. More complex hardware",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-3--Bus-Arbitration--Vectored-",
        "title": "3. Bus Arbitration (Vectored)",
        "front": "3. Bus Arbitration (Vectored)",
        "back": "",
        "type": "concept",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "I/O module must gain control of bus before raising interrupt.",
        "type": "definition",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Process",
        "title": "Process",
        "front": "Process",
        "back": "1. I/O module requests bus control\n2. Gains bus control\n3. Raises interrupt request line\n4. Processor detects interrupt\n5. Processor responds on interrupt acknowledge\n6. Requesting module places vector on data lines",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Flexible priority (bus arbitration)\n2. Vectored interrupts\n3. Works with bus-based systems",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. Requires bus arbitration\n2. More complex",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-4--Software-Poll",
        "title": "4. Software Poll",
        "front": "4. Software Poll",
        "back": "",
        "type": "concept",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Processor branches to interrupt service routine that polls each I/O module.",
        "type": "definition",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Process",
        "title": "Process",
        "front": "Process",
        "back": "1. Processor detects interrupt\n2. Branches to general interrupt service routine\n3. Routine polls each I/O module\n4. Determines which module caused interrupt\n5. Branches to specific device service routine",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Simple hardware\n2. Flexible (software-controlled)\n3. No special hardware needed",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Disadvantages",
        "title": "Disadvantages",
        "front": "Disadvantages",
        "back": "1. **Time consuming:** Must check each module\n2. Slower than hardware methods\n3. Higher interrupt latency",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Device-Identification-Techniques-Use",
        "title": "Use",
        "front": "Use",
        "back": "Systems with many devices, when hardware cost is concern",
        "type": "definition",
        "section": "Interrupt-Driven I/O",
        "subsection": "Device Identification Techniques"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Priority-Handling-Problem",
        "title": "Problem",
        "front": "Problem",
        "back": "Multiple interrupts may occur simultaneously.",
        "type": "definition",
        "section": "Interrupt-Driven I/O",
        "subsection": "Priority Handling"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Priority-Handling-Solutions",
        "title": "Solutions",
        "front": "Solutions",
        "back": "1. **Fixed Priority:**\n2. Each device has fixed priority\n3. Higher priority interrupts lower priority\n4. Simple but inflexible\n5. **Programmable Priority:**\n6. Priority can be changed\n7. More flexible\n8. Requires priority controller\n9. **Nested Interrupts:**\n10. Higher priority can interrupt lower priority\n11. Requires interrupt masking\n12. More complex",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Priority Handling"
      },
      {
        "id": "6-Interrupt-Driven-I-O-Priority-Handling-Interrupt-Masking",
        "title": "Interrupt Masking",
        "front": "Interrupt Masking",
        "back": "1. Processor can disable interrupts\n2. Critical sections protected\n3. Interrupt enable/disable flags",
        "type": "list",
        "section": "Interrupt-Driven I/O",
        "subsection": "Priority Handling"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--Why-DMA--Drawbacks-of-Programmed-and-Interrupt-Driven-I-O",
        "title": "Drawbacks of Programmed and Interrupt-Driven I/O",
        "front": "Drawbacks of Programmed and Interrupt-Driven I/O",
        "back": "1. **Transfer Rate Limited:**\n2. Limited by speed processor can test and service device\n3. Processor bottleneck\n4. **Processor Tied Up:**\n5. Processor involved in managing transfer\n6. Multiple instructions per I/O transfer\n7. Wastes processor cycles",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "Why DMA?"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--Why-DMA--Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "**Direct Memory Access (DMA)** for large data volumes.",
        "type": "definition",
        "section": "Direct Memory Access (DMA)",
        "subsection": "Why DMA?"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Concept-Definition",
        "title": "Definition",
        "front": "Definition",
        "back": "I/O module transfers data directly to/from memory without processor involvement.",
        "type": "definition",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Concept"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Concept-Key-Points",
        "title": "Key Points",
        "front": "Key Points",
        "back": "1. Processor only involved at **start and end**\n2. DMA controller handles transfer\n3. Data bypasses processor\n4. Very efficient for large transfers",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Concept"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Block-Diagram-Components",
        "title": "Components",
        "front": "Components",
        "back": "1. **Data Count Register:**\n2. Number of bytes/words to transfer\n3. Decremented during transfer\n4. Interrupts when reaches zero\n5. **Data Register:**\n6. Temporary data storage\n7. For some DMA configurations\n8. **Address Register:**\n9. Memory address for transfer\n10. Incremented during transfer\n11. **Control Logic:**\n12. Manages DMA operation\n13. Handles bus requests\n14. Coordinates transfer",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Block Diagram"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Block-Diagram-Signals",
        "title": "Signals",
        "front": "Signals",
        "back": "1. **Request to DMA:** Device requests DMA transfer\n2. **Acknowledge from DMA:** DMA acknowledges request\n3. **Read/Write:** Control signals\n4. **Interrupt:** Signal completion",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Block Diagram"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Operation-Process",
        "title": "Process",
        "front": "Process",
        "back": "1. **Initialization (Processor):**\n2. Processor sets up DMA:\n3. Starting memory address\n4. Number of bytes to transfer\n5. Direction (read/write)\n6. Processor issues DMA command\n7. **Transfer (DMA Controller):**\n8. DMA controller requests bus\n9. Gains bus control\n10. Transfers data directly:\n11. Read from I/O device\n12. Write to memory (or vice versa)\n13. Increments address, decrements count\n14. Continues until complete\n15. **Completion (DMA Controller):**\n16. DMA controller interrupts processor\n17. Signals completion\n18. Processor checks status",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Operation"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Operation-Key",
        "title": "Key",
        "front": "Key",
        "back": "Processor free during entire transfer!",
        "type": "definition",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Operation"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Breakpoints-DMA-Breakpoints",
        "title": "DMA Breakpoints",
        "front": "DMA Breakpoints",
        "back": "1. Can interrupt during instruction cycle\n2. Typically between:\n3. Instruction fetch and decode\n4. Operand fetch and execute\n5. Execute and store result",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Breakpoints"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Breakpoints-Interrupt-Breakpoints",
        "title": "Interrupt Breakpoints",
        "front": "Interrupt Breakpoints",
        "back": "1. Typically only between instructions\n2. Must complete current instruction",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Breakpoints"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Breakpoints-DMA-More-Flexible",
        "title": "DMA More Flexible",
        "front": "DMA More Flexible",
        "back": "1. Can interrupt during instruction execution\n2. Steals bus cycles\n3. Processor may need to wait for DMA",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Breakpoints"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-1--Single-Bus--Detached-DMA",
        "title": "1. Single-Bus, Detached DMA",
        "front": "1. Single-Bus, Detached DMA",
        "back": "",
        "type": "concept",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Configurations"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "Processor ──┐ ├── System Bus ── Memory DMA ────────┘ I/O ────────┘",
        "type": "definition",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Configurations"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. DMA on system bus\n2. Competes with processor for bus\n3. Bus arbitration needed\n4. Simple but may cause contention",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Configurations"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-2--Single-Bus--Integrated-DMA-I-O",
        "title": "2. Single-Bus, Integrated DMA-I/O",
        "front": "2. Single-Bus, Integrated DMA-I/O",
        "back": "",
        "type": "concept",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Configurations"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "Processor ──┐ ├── System Bus ── Memory DMA+I/O ────┘",
        "type": "definition",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Configurations"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. DMA integrated with I/O module\n2. Still on system bus\n3. More efficient (no separate DMA module)\n4. Common configuration",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Configurations"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-3--I-O-Bus",
        "title": "3. I/O Bus",
        "front": "3. I/O Bus",
        "back": "",
        "type": "concept",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Configurations"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Structure",
        "title": "Structure",
        "front": "Structure",
        "back": "Processor ── System Bus ── Memory DMA Controller I/O Bus ── I/O ── I/O ── I/O",
        "type": "definition",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Configurations"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Configurations-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Separate I/O bus\n2. DMA controller bridges buses\n3. Reduces system bus load\n4. More complex but better performance",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Configurations"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--Fly-By-DMA-Controller-Concept",
        "title": "Concept",
        "front": "Concept",
        "back": "Data does **not** pass through DMA chip.",
        "type": "definition",
        "section": "Direct Memory Access (DMA)",
        "subsection": "Fly-By DMA Controller"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--Fly-By-DMA-Controller-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. DMA only between I/O port and memory\n2. **Not** between two I/O ports\n3. **Not** between two memory locations\n4. Data flows directly: I/O ↔ Memory",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "Fly-By DMA Controller"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--Fly-By-DMA-Controller-Memory-to-Memory",
        "title": "Memory-to-Memory",
        "front": "Memory-to-Memory",
        "back": "1. Can do via register\n2. Less efficient\n3. Requires two transfers",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "Fly-By DMA Controller"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--Fly-By-DMA-Controller-Example--Intel-8237",
        "title": "Example: Intel 8237",
        "front": "Example: Intel 8237",
        "back": "1. Contains four DMA channels\n2. Each channel programmed independently\n3. Any one channel active at a time\n4. Fly-by operation",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "Fly-By DMA Controller"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Usage-Example-Intel-8237-DMA-Controller",
        "title": "Intel 8237 DMA Controller",
        "front": "Intel 8237 DMA Controller",
        "back": "",
        "type": "definition",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Usage Example"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Usage-Example-Signals",
        "title": "Signals",
        "front": "Signals",
        "back": "1. **DREQ:** DMA request (from device)\n2. **HRQ:** Hold request (to processor)\n3. **HLDA:** Hold acknowledge (from processor)\n4. **DACK:** DMA acknowledge (to device)",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Usage Example"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Usage-Example-Control-Bus-Signals",
        "title": "Control Bus Signals",
        "front": "Control Bus Signals",
        "back": "1. **IOR:** I/O read\n2. **IOW:** I/O write\n3. **MEMR:** Memory read\n4. **MEMW:** Memory write",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Usage Example"
      },
      {
        "id": "6-Direct-Memory-Access--DMA--DMA-Usage-Example-Operation",
        "title": "Operation",
        "front": "Operation",
        "back": "1. Device requests DMA (DREQ)\n2. DMA requests bus (HRQ)\n3. Processor acknowledges (HLDA)\n4. DMA transfers data using control signals\n5. DMA completes, releases bus",
        "type": "list",
        "section": "Direct Memory Access (DMA)",
        "subsection": "DMA Usage Example"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Manage multiple interrupt sources.",
        "type": "definition",
        "section": "I/O Controllers and Interfaces",
        "subsection": "82C59A Programmable Interrupt Controller (PIC)"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Features",
        "title": "Features",
        "front": "Features",
        "back": "1. **8 interrupt request lines (IR0-IR7)**\n2. Priority management\n3. Interrupt vector generation\n4. Cascading support",
        "type": "list",
        "section": "I/O Controllers and Interfaces",
        "subsection": "82C59A Programmable Interrupt Controller (PIC)"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Cascading",
        "title": "Cascading",
        "front": "Cascading",
        "back": "1. Multiple PICs can be cascaded\n2. Master PIC connects to processor\n3. Slave PICs connect to master\n4. Example: 1 master + 3 slaves = 32 interrupt lines",
        "type": "list",
        "section": "I/O Controllers and Interfaces",
        "subsection": "82C59A Programmable Interrupt Controller (PIC)"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Configuration",
        "title": "Configuration",
        "front": "Configuration",
        "back": "Master 82C59A ── Processor (INTR) ├── IR0-IR7 (8 devices) ├── Slave 82C59A (via IR) │ └── IR0-IR7 (8 devices) ├── Slave 82C59A (via IR) │ └── IR0-IR7 (8 devices) └── Slave 82C59A (via IR) └── IR0-IR7 (8 devices)",
        "type": "definition",
        "section": "I/O Controllers and Interfaces",
        "subsection": "82C59A Programmable Interrupt Controller (PIC)"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-82C59A-Programmable-Interrupt-Controller--PIC--Total",
        "title": "Total",
        "front": "Total",
        "back": "Up to 64 interrupt sources (with cascading)",
        "type": "definition",
        "section": "I/O Controllers and Interfaces",
        "subsection": "82C59A Programmable Interrupt Controller (PIC)"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Interface to parallel I/O devices.",
        "type": "definition",
        "section": "I/O Controllers and Interfaces",
        "subsection": "8255A Programmable Peripheral Interface (PPI)"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Features",
        "title": "Features",
        "front": "Features",
        "back": "1. **Three 8-bit ports:** Port A, Port B, Port C\n2. **Port C split:** Upper (PC7-PC4) and Lower (PC3-PC0)\n3. **Multiple modes:** Input, output, bidirectional\n4. **Handshaking:** Control signals for device communication",
        "type": "list",
        "section": "I/O Controllers and Interfaces",
        "subsection": "8255A Programmable Peripheral Interface (PPI)"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Ports",
        "title": "Ports",
        "front": "Ports",
        "back": "1. **Port A:** 8-bit I/O port (Group A)\n2. **Port B:** 8-bit I/O port (Group B)\n3. **Port C:** 8-bit I/O port or control signals",
        "type": "list",
        "section": "I/O Controllers and Interfaces",
        "subsection": "8255A Programmable Peripheral Interface (PPI)"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Modes",
        "title": "Modes",
        "front": "Modes",
        "back": "1. **Mode 0:** Basic input/output\n2. **Mode 1:** Handshaking I/O\n3. **Mode 2:** Bidirectional bus",
        "type": "list",
        "section": "I/O Controllers and Interfaces",
        "subsection": "8255A Programmable Peripheral Interface (PPI)"
      },
      {
        "id": "6-I-O-Controllers-and-Interfaces-8255A-Programmable-Peripheral-Interface--PPI--Applications",
        "title": "Applications",
        "front": "Applications",
        "back": "1. Keyboard interfaces\n2. Display interfaces\n3. Parallel printer interfaces\n4. General-purpose I/O\n5. Port A: Keyboard input\n6. Port B: Display output\n7. Port C: Control signals (data ready, acknowledge)",
        "type": "list",
        "section": "I/O Controllers and Interfaces",
        "subsection": "8255A Programmable Peripheral Interface (PPI)"
      },
      {
        "id": "6-External-Interconnection-Standards-Universal-Serial-Bus--USB--Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Widely used for peripheral connections.",
        "type": "definition",
        "section": "External Interconnection Standards",
        "subsection": "Universal Serial Bus (USB)"
      },
      {
        "id": "6-External-Interconnection-Standards-Universal-Serial-Bus--USB--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Default interface** for slower speed devices (keyboard, mouse)\n2. **Commonly used** for high-speed I/O (printers, disk drives, network adapters)\n3. **Multiple generations:** USB 1.0, 2.0, 3.0, 3.1, 3.2, USB-C\n4. **Hot-pluggable:** Connect/disconnect without powering down\n5. **Automatic configuration:** Plug and play",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "Universal Serial Bus (USB)"
      },
      {
        "id": "6-External-Interconnection-Standards-Universal-Serial-Bus--USB--Advantages",
        "title": "Advantages",
        "front": "Advantages",
        "back": "1. Universal standard\n2. Easy to use\n3. Hot-pluggable\n4. Power delivery (USB-C)",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "Universal Serial Bus (USB)"
      },
      {
        "id": "6-External-Interconnection-Standards-FireWire-Serial-Bus-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "High-speed I/O for smaller systems.",
        "type": "definition",
        "section": "External Interconnection Standards",
        "subsection": "FireWire Serial Bus"
      },
      {
        "id": "6-External-Interconnection-Standards-FireWire-Serial-Bus-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. Alternative to SCSI for personal computers\n2. **Daisy chain configuration:** Up to 63 devices\n3. **Hot plugging:** Connect/disconnect without power down\n4. **Automatic configuration**\n5. High I/O rates",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "FireWire Serial Bus"
      },
      {
        "id": "6-External-Interconnection-Standards-FireWire-Serial-Bus-Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. Video capture\n2. External storage\n3. Professional audio/video equipment",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "FireWire Serial Bus"
      },
      {
        "id": "6-External-Interconnection-Standards-SCSI--Small-Computer-System-Interface--Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Standard for connecting peripheral devices.",
        "type": "definition",
        "section": "External Interconnection Standards",
        "subsection": "SCSI (Small Computer System Interface)"
      },
      {
        "id": "6-External-Interconnection-Standards-SCSI--Small-Computer-System-Interface--Status",
        "title": "Status",
        "front": "Status",
        "back": "1. **Once common** for disks, modems, printers\n2. **Lost popularity** to USB and FireWire in smaller systems\n3. **High-speed versions** remain popular for enterprise systems\n4. Used in some mainframes",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "SCSI (Small Computer System Interface)"
      },
      {
        "id": "6-External-Interconnection-Standards-SCSI--Small-Computer-System-Interface--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. High performance\n2. Multiple device support\n3. More complex than USB",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "SCSI (Small Computer System Interface)"
      },
      {
        "id": "6-External-Interconnection-Standards-Thunderbolt-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Fastest peripheral connection technology.",
        "type": "definition",
        "section": "External Interconnection Standards",
        "subsection": "Thunderbolt"
      },
      {
        "id": "6-External-Interconnection-Standards-Thunderbolt-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Developed by Intel** with Apple collaboration\n2. **Combines:** Data, video, audio, and power\n3. **Single high-speed connection**\n4. Very high data rates",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "Thunderbolt"
      },
      {
        "id": "6-External-Interconnection-Standards-Thunderbolt-Applications",
        "title": "Applications",
        "front": "Applications",
        "back": "1. Hard drives\n2. RAID arrays\n3. Video-capture boxes\n4. Network interfaces",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "Thunderbolt"
      },
      {
        "id": "6-External-Interconnection-Standards-InfiniBand-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "High-end server market I/O specification.",
        "type": "definition",
        "section": "External Interconnection Standards",
        "subsection": "InfiniBand"
      },
      {
        "id": "6-External-Interconnection-Standards-InfiniBand-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Heavily used** by IBM zEnterprise mainframes\n2. **Architecture** for data flow among processors and I/O devices\n3. **Storage area networking:** Popular for SAN\n4. **Central fabric:** Switches and links\n5. Very high performance",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "InfiniBand"
      },
      {
        "id": "6-External-Interconnection-Standards-InfiniBand-Use-Cases",
        "title": "Use Cases",
        "front": "Use Cases",
        "back": "1. Enterprise servers\n2. Storage area networks\n3. High-performance computing",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "InfiniBand"
      },
      {
        "id": "6-External-Interconnection-Standards-SATA--Serial-Advanced-Technology-Attachment--Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Interface for disk storage systems.",
        "type": "definition",
        "section": "External Interconnection Standards",
        "subsection": "SATA (Serial Advanced Technology Attachment)"
      },
      {
        "id": "6-External-Interconnection-Standards-SATA--Serial-Advanced-Technology-Attachment--Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Data rates:** Up to 6 Gbps\n2. **Maximum per device:** 300 Mbps\n3. **Widely used:** Desktop computers, industrial, embedded\n4. Replaced parallel ATA (PATA)",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "SATA (Serial Advanced Technology Attachment)"
      },
      {
        "id": "6-External-Interconnection-Standards-SATA--Serial-Advanced-Technology-Attachment--Generations",
        "title": "Generations",
        "front": "Generations",
        "back": "1. SATA 1.0: 1.5 Gbps\n2. SATA 2.0: 3 Gbps\n3. SATA 3.0: 6 Gbps",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "SATA (Serial Advanced Technology Attachment)"
      },
      {
        "id": "6-External-Interconnection-Standards-PCI-Express-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "High-speed bus system for peripherals.",
        "type": "definition",
        "section": "External Interconnection Standards",
        "subsection": "PCI Express"
      },
      {
        "id": "6-External-Interconnection-Standards-PCI-Express-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Wide variety** of device types and speeds\n2. **Point-to-point** connections\n3. **Scalable:** x1, x4, x8, x16 lanes\n4. Very high bandwidth",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "PCI Express"
      },
      {
        "id": "6-External-Interconnection-Standards-PCI-Express-Applications",
        "title": "Applications",
        "front": "Applications",
        "back": "1. Graphics cards\n2. Network adapters\n3. Storage controllers\n4. High-speed peripherals",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "PCI Express"
      },
      {
        "id": "6-External-Interconnection-Standards-Ethernet-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Predominant wired networking technology.",
        "type": "definition",
        "section": "External Interconnection Standards",
        "subsection": "Ethernet"
      },
      {
        "id": "6-External-Interconnection-Standards-Ethernet-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **Data rates:** Up to 100 Gbps\n2. **Distances:** Few meters to tens of kilometers\n3. **Widely used:** Local area networks\n4. **Standard:** IEEE 802.3",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "Ethernet"
      },
      {
        "id": "6-External-Interconnection-Standards-Ethernet-Evolution",
        "title": "Evolution",
        "front": "Evolution",
        "back": "1. 10 Mbps → 100 Mbps → 1 Gbps → 10 Gbps → 100 Gbps",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "Ethernet"
      },
      {
        "id": "6-External-Interconnection-Standards-WiFi-Purpose",
        "title": "Purpose",
        "front": "Purpose",
        "back": "Predominant wireless Internet access technology.",
        "type": "definition",
        "section": "External Interconnection Standards",
        "subsection": "WiFi"
      },
      {
        "id": "6-External-Interconnection-Standards-WiFi-Characteristics",
        "title": "Characteristics",
        "front": "Characteristics",
        "back": "1. **IEEE 802.11** standards\n2. **Multiple versions:** 802.11a/b/g/n/ac/ax\n3. **Increasing speeds** with each generation\n4. **Public hotspots:** Free Internet access",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "WiFi"
      },
      {
        "id": "6-External-Interconnection-Standards-WiFi-Evolution",
        "title": "Evolution",
        "front": "Evolution",
        "back": "1. 802.11: 2 Mbps\n2. 802.11b: 11 Mbps\n3. 802.11g: 54 Mbps\n4. 802.11n: 600 Mbps\n5. 802.11ac: 6.77 Gbps\n6. 802.11ax (WiFi 6): Higher speeds",
        "type": "list",
        "section": "External Interconnection Standards",
        "subsection": "WiFi"
      },
      {
        "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-1--CPU-Direct-Control",
        "title": "1. CPU Direct Control",
        "front": "1. CPU Direct Control",
        "back": "1. CPU directly controls peripheral device\n2. Simplest but least efficient\n3. CPU tied up during I/O",
        "type": "list",
        "section": "Evolution of I/O Function",
        "subsection": "Six Stages of Evolution"
      },
      {
        "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-2--Controller-I-O-Module-Added--Programmed-I-O-",
        "title": "2. Controller/I/O Module Added (Programmed I/O)",
        "front": "2. Controller/I/O Module Added (Programmed I/O)",
        "back": "1. I/O module added\n2. CPU uses programmed I/O without interrupts\n3. CPU still waits for I/O\n4. Better than direct control",
        "type": "list",
        "section": "Evolution of I/O Function",
        "subsection": "Six Stages of Evolution"
      },
      {
        "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-3--Interrupts-Employed",
        "title": "3. Interrupts Employed",
        "front": "3. Interrupts Employed",
        "back": "1. Same configuration as stage 2\n2. But now interrupts are used\n3. CPU need not wait\n4. **Increases efficiency**",
        "type": "list",
        "section": "Evolution of I/O Function",
        "subsection": "Six Stages of Evolution"
      },
      {
        "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-4--DMA-Added",
        "title": "4. DMA Added",
        "front": "4. DMA Added",
        "back": "1. I/O module given direct access to memory\n2. Can move block of data without CPU involvement\n3. CPU only involved at beginning and end\n4. **Much more efficient** for large transfers",
        "type": "list",
        "section": "Evolution of I/O Function",
        "subsection": "Six Stages of Evolution"
      },
      {
        "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-5--I-O-Module-as-Processor",
        "title": "5. I/O Module as Processor",
        "front": "5. I/O Module as Processor",
        "back": "1. I/O module enhanced to become processor\n2. Specialized instruction set for I/O\n3. Can execute I/O programs\n4. **Reduces CPU involvement further**",
        "type": "list",
        "section": "Evolution of I/O Function",
        "subsection": "Six Stages of Evolution"
      },
      {
        "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-6--I-O-Module-with-Local-Memory",
        "title": "6. I/O Module with Local Memory",
        "front": "6. I/O Module with Local Memory",
        "back": "1. I/O module has local memory\n2. Computer in its own right\n3. Large set of I/O devices controlled with minimal CPU involvement\n4. **Maximum efficiency**",
        "type": "list",
        "section": "Evolution of I/O Function",
        "subsection": "Six Stages of Evolution"
      },
      {
        "id": "6-Evolution-of-I-O-Function-Six-Stages-of-Evolution-Trend",
        "title": "Trend",
        "front": "Trend",
        "back": "Increasing autonomy of I/O modules, reducing CPU involvement.",
        "type": "definition",
        "section": "Evolution of I/O Function",
        "subsection": "Six Stages of Evolution"
      },
      {
        "id": "6-Key-Concepts-Summary-I-O-Module-Functions-I-O-Module-Functions",
        "title": "I/O Module Functions",
        "front": "I/O Module Functions",
        "back": "1. **Control and Timing:** Coordinate traffic flow\n2. **Processor Communication:** Commands, data, status\n3. **Device Communication:** Device-specific protocols\n4. **Data Buffering:** Speed matching\n5. **Error Detection:** Detect and report errors",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "I/O Module Functions"
      },
      {
        "id": "6-Key-Concepts-Summary-I-O-Techniques-I-O-Techniques",
        "title": "I/O Techniques",
        "front": "I/O Techniques",
        "back": "1. **Programmed I/O:** CPU waits, simple but inefficient\n2. **Interrupt-Driven I/O:** CPU does other work, more efficient\n3. **DMA:** Direct memory access, most efficient for large transfers",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "I/O Techniques"
      },
      {
        "id": "6-Key-Concepts-Summary-I-O-Addressing-I-O-Addressing",
        "title": "I/O Addressing",
        "front": "I/O Addressing",
        "back": "1. **Memory-Mapped I/O:** Shared address space, flexible\n2. **Isolated I/O:** Separate address spaces, full memory space",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "I/O Addressing"
      },
      {
        "id": "6-Key-Concepts-Summary-Interrupts-Interrupts",
        "title": "Interrupts",
        "front": "Interrupts",
        "back": "1. **Device Identification:** Multiple lines, daisy chain, bus arbitration, software poll\n2. **Priority:** Fixed or programmable, nested interrupts\n3. **Processing:** Save state, service interrupt, restore state",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Interrupts"
      },
      {
        "id": "6-Key-Concepts-Summary-DMA-DMA",
        "title": "DMA",
        "front": "DMA",
        "back": "1. **Purpose:** Direct I/O-to-memory transfer\n2. **Operation:** CPU sets up, DMA transfers, CPU notified\n3. **Configurations:** Single bus, integrated, I/O bus\n4. **Fly-by:** Data doesn't pass through DMA chip",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "DMA"
      },
      {
        "id": "6-Key-Concepts-Summary-Evolution-Evolution",
        "title": "Evolution",
        "front": "Evolution",
        "back": "1. **Trend:** Increasing I/O module autonomy\n2. **Goal:** Reduce CPU involvement\n3. **Result:** Better system efficiency",
        "type": "list",
        "section": "Key Concepts Summary",
        "subsection": "Evolution"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-1--I-O-Technique-Selection-Question",
        "title": "Question",
        "front": "Question",
        "back": "Which I/O technique is best for: a) Reading a single byte from keyboard b) Transferring 1 MB file from disk to memory c) Checking printer status",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: I/O Technique Selection"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-1--I-O-Technique-Selection-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "a) **Interrupt-Driven I/O:** Small transfer, device-initiated b) **DMA:** Large transfer, needs efficiency c) **Programmed I/O:** Simple status check",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 1: I/O Technique Selection"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-2--Memory-Mapped-I-O-Address-Space-Question",
        "title": "Question",
        "front": "Question",
        "back": "System has 16-bit address bus, uses memory-mapped I/O. If 48 KB memory, how many I/O addresses available?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Memory-Mapped I/O Address Space"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-2--Memory-Mapped-I-O-Address-Space-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Total address space: 2^16 = 64 KB Memory: 48 KB = 48,000 bytes I/O addresses: 64 KB - 48 KB = 16 KB = 16,384 addresses",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Memory-Mapped I/O Address Space"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-2--Memory-Mapped-I-O-Address-Space-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "16,384 I/O addresses",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 2: Memory-Mapped I/O Address Space"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-3--DMA-Transfer-Time-Question",
        "title": "Question",
        "front": "Question",
        "back": "DMA transfers 64 KB block. Memory access time 100 ns, I/O device rate 10 MB/s. How long does transfer take?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: DMA Transfer Time"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-3--DMA-Transfer-Time-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Data size: 64 KB = 65,536 bytes I/O device rate: 10 MB/s = 10,000,000 bytes/s Transfer time = 65,536 / 10,000,000 = 0.0065536 s = 6.55 ms",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: DMA Transfer Time"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-3--DMA-Transfer-Time-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "6.55 ms (CPU free during this time)",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 3: DMA Transfer Time"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-4--Interrupt-Overhead-Question",
        "title": "Question",
        "front": "Question",
        "back": "Interrupt service routine takes 50 cycles. System has 1000 interrupts/second. What is interrupt overhead?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Interrupt Overhead"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-4--Interrupt-Overhead-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "Interrupts per second: 1000 Cycles per interrupt: 50 Total cycles per second: 1000 × 50 = 50,000 cycles If CPU runs at 1 GHz (1,000,000,000 cycles/s): Overhead = 50,000 / 1,000,000,000 = 0.00005 = 0.005%",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Interrupt Overhead"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-4--Interrupt-Overhead-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "0.005% CPU overhead",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 4: Interrupt Overhead"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-5--Programmed-vs--Interrupt-Driven-I-O-Question",
        "title": "Question",
        "front": "Question",
        "back": "Device transfers 1 byte every 10 ms. Programmed I/O: CPU checks every 1 μs. Interrupt-driven: 100 cycle overhead per interrupt. Which is more efficient?",
        "type": "definition",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Programmed vs. Interrupt-Driven I/O"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-5--Programmed-vs--Interrupt-Driven-I-O-Solution",
        "title": "Solution",
        "front": "Solution",
        "back": "1. Checks every 1 μs\n2. 10 ms = 10,000 μs\n3. Number of checks: 10,000\n4. Wastes 10,000 checks\n5. One interrupt per byte\n6. 100 cycles overhead\n7. CPU free for 10 ms - interrupt time\n8. Much more efficient",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Programmed vs. Interrupt-Driven I/O"
      },
      {
        "id": "6-Practice-Problems-and-Examples-Problem-5--Programmed-vs--Interrupt-Driven-I-O-Answer",
        "title": "Answer",
        "front": "Answer",
        "back": "1. **Understand the Evolution:**\n2. Why each technique developed\n3. Trade-offs between techniques\n4. When to use each\n5. **Master DMA Concepts:**\n6. How DMA works\n7. When DMA is beneficial\n8. DMA configurations\n9. **Compare Techniques:**\n10. Programmed vs. Interrupt vs. DMA\n11. Memory-mapped vs. Isolated I/O\n12. Different device identification methods\n13. **Understand Interrupts:**\n14. Interrupt processing flow\n15. Device identification\n16. Priority handling\n17. **Know Standards:**\n18. Common I/O standards\n19. Their characteristics\n20. When each is used\n21. **I/O modules** bridge processor/memory and peripherals\n22. **Three I/O techniques** provide different efficiency levels\n23. **Interrupts** enable asynchronous I/O\n24. **DMA** provides maximum efficiency for large transfers\n25. **I/O standards** enable device connectivity\n26. I/O is often the system bottleneck\n27. I/O design impacts overall performance\n28. I/O completes the communication picture\n29. Modern systems rely heavily on efficient I/O",
        "type": "list",
        "section": "Practice Problems and Examples",
        "subsection": "Problem 5: Programmed vs. Interrupt-Driven I/O"
      }
    ]
  }
}