{
  "group": 2,
  "totalCards": 207,
  "sections": [
    {
      "section": "Detailed Study Guide",
      "subsections": [
        {
          "subsection": "General",
          "cardCount": 1,
          "cards": [
            {
              "id": "2-Detailed-Study-Guide--Detailed-Study-Guide",
              "title": "Detailed Study Guide",
              "front": "Detailed Study Guide",
              "back": "1. [Introduction: Processor Organization](#introduction-processor-organization)\n2. [CPU Internal Structure](#cpu-internal-structure)\n3. [Register Organization](#register-organization)\n4. [Instruction Cycle Details](#instruction-cycle-details)\n5. [Pipelining Fundamentals](#pipelining-fundamentals)\n6. [MIPS Pipeline Case Study](#mips-pipeline-case-study)\n7. [Pipeline Hazards](#pipeline-hazards)\n8. [Data Hazards and Forwarding](#data-hazards-and-forwarding)\n9. [Control Hazards](#control-hazards)\n10. [Key Concepts Summary](#key-concepts-summary)\n11. [Practice Problems and Examples](#practice-problems-and-examples)",
              "type": "list",
              "section": "Detailed Study Guide",
              "subsection": ""
            }
          ]
        }
      ]
    },
    {
      "section": "Introduction: Processor Organization",
      "subsections": [
        {
          "subsection": "Processor Requirements",
          "cardCount": 5,
          "cards": [
            {
              "id": "2-Introduction--Processor-Organization-Processor-Requirements-1--Fetch-Instruction",
              "title": "1. Fetch Instruction",
              "front": "1. Fetch Instruction",
              "back": "1. **Purpose:** Read the next instruction to execute\n2. **Source:** Memory (register, cache, or main memory)\n3. **Process:**\n4. Read instruction from memory location\n5. Load instruction into processor\n6. Prepare for execution",
              "type": "list",
              "section": "Introduction: Processor Organization",
              "subsection": "Processor Requirements"
            },
            {
              "id": "2-Introduction--Processor-Organization-Processor-Requirements-2--Interpret-Instruction",
              "title": "2. Interpret Instruction",
              "front": "2. Interpret Instruction",
              "back": "1. **Purpose:** Determine what action the instruction requires\n2. **Process:**\n3. Decode the instruction opcode\n4. Identify operation type (ADD, SUB, LOAD, STORE, etc.)\n5. Determine operand locations\n6. Generate control signals",
              "type": "list",
              "section": "Introduction: Processor Organization",
              "subsection": "Processor Requirements"
            },
            {
              "id": "2-Introduction--Processor-Organization-Processor-Requirements-3--Fetch-Data",
              "title": "3. Fetch Data",
              "front": "3. Fetch Data",
              "back": "1. **Purpose:** Retrieve operands needed for instruction execution\n2. **Sources:**\n3. Memory (main memory or cache)\n4. I/O modules (for I/O operations)\n5. Registers (fastest source)\n6. **Note:** Not all instructions require data fetch (some operate on registers only)",
              "type": "list",
              "section": "Introduction: Processor Organization",
              "subsection": "Processor Requirements"
            },
            {
              "id": "2-Introduction--Processor-Organization-Processor-Requirements-4--Process-Data",
              "title": "4. Process Data",
              "front": "4. Process Data",
              "back": "1. **Purpose:** Perform the actual computation\n2. **Operations:**\n3. **Arithmetic:** ADD, SUBTRACT, MULTIPLY, DIVIDE\n4. **Logical:** AND, OR, NOT, XOR, SHIFT, ROTATE\n5. **Comparison:** Compare values, set condition codes\n6. **Location:** Typically performed in ALU (Arithmetic Logic Unit)",
              "type": "list",
              "section": "Introduction: Processor Organization",
              "subsection": "Processor Requirements"
            },
            {
              "id": "2-Introduction--Processor-Organization-Processor-Requirements-5--Write-Data",
              "title": "5. Write Data",
              "front": "5. Write Data",
              "back": "1. **Purpose:** Store results of computation\n2. **Destinations:**\n3. Memory (main memory or cache)\n4. I/O modules (for output operations)\n5. Registers (fastest destination)",
              "type": "list",
              "section": "Introduction: Processor Organization",
              "subsection": "Processor Requirements"
            }
          ]
        },
        {
          "subsection": "Internal Memory Requirement",
          "cardCount": 3,
          "cards": [
            {
              "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Key-Point",
              "title": "Key Point",
              "front": "Key Point",
              "back": "1. Instructions being executed\n2. Operands being processed\n3. Intermediate results\n4. Control information",
              "type": "list",
              "section": "Introduction: Processor Organization",
              "subsection": "Internal Memory Requirement"
            },
            {
              "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Solution",
              "title": "Solution",
              "front": "Solution",
              "back": "**Registers** - fast, small memory locations within the CPU.",
              "type": "definition",
              "section": "Introduction: Processor Organization",
              "subsection": "Internal Memory Requirement"
            },
            {
              "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Memory-Hierarchy--Fastest-to-Slowest-",
              "title": "Memory Hierarchy (Fastest to Slowest)",
              "front": "Memory Hierarchy (Fastest to Slowest)",
              "back": "1. **CPU Registers** (fastest, smallest, most expensive)\n2. **Cache Memory** (very fast, small, expensive)\n3. **Main Memory** (fast, larger, moderate cost)\n4. **Secondary Storage** (slow, very large, cheap)",
              "type": "list",
              "section": "Introduction: Processor Organization",
              "subsection": "Internal Memory Requirement"
            }
          ]
        }
      ]
    },
    {
      "section": "CPU Internal Structure",
      "subsections": [
        {
          "subsection": "CPU-System Bus Connection",
          "cardCount": 2,
          "cards": [
            {
              "id": "2-CPU-Internal-Structure-CPU-System-Bus-Connection-CPU-System-Bus-Connection",
              "title": "CPU-System Bus Connection",
              "front": "CPU-System Bus Connection",
              "back": "1. **Data Bus:** For transferring data and instructions\n2. **Address Bus:** For specifying memory/I/O addresses\n3. **Control Bus:** For control and timing signals",
              "type": "list",
              "section": "CPU Internal Structure",
              "subsection": "CPU-System Bus Connection"
            },
            {
              "id": "2-CPU-Internal-Structure-CPU-System-Bus-Connection-Connection-Points",
              "title": "Connection Points",
              "front": "Connection Points",
              "back": "1. CPU reads instructions from memory via bus\n2. CPU reads/writes data via bus\n3. CPU sends control signals via bus\n4. CPU receives interrupt signals via bus",
              "type": "list",
              "section": "CPU Internal Structure",
              "subsection": "CPU-System Bus Connection"
            }
          ]
        },
        {
          "subsection": "Internal CPU Organization",
          "cardCount": 3,
          "cards": [
            {
              "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Key-Components",
              "title": "Key Components",
              "front": "Key Components",
              "back": "┌─────────────────────────────────────┐ │ CPU INTERNAL │ │ │ │ ┌──────────┐ ┌──────────┐ │ │ │ Control │ │ ALU │ │ │ │ Unit │◄────►│ │ │ │ └────┬─────┘ └────┬─────┘ │ │ │ │ │ │ ┌────┴─────────────────┴─────┐ │ │ │ Register File │ │ │ │ (User-Visible Registers) │ │ │ └─────────────────────────────┘ │ │ │ │ ┌─────────────────────────────┐ │ │ │ Control & Status Registers │ │ │ │ (PC, IR, MAR, MBR, PSW) │ │ │ └─────────────────────────────┘ │ │ │ └─────────────────────────────────────┘",
              "type": "definition",
              "section": "CPU Internal Structure",
              "subsection": "Internal CPU Organization"
            },
            {
              "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Data-Flow",
              "title": "Data Flow",
              "front": "Data Flow",
              "back": "1. **Control Unit:** Generates control signals based on instruction\n2. **ALU:** Performs arithmetic/logical operations\n3. **Registers:** Store operands and results\n4. **Internal Buses:** Connect components within CPU",
              "type": "list",
              "section": "CPU Internal Structure",
              "subsection": "Internal CPU Organization"
            },
            {
              "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Key-Insight",
              "title": "Key Insight",
              "front": "Key Insight",
              "back": "The CPU is a complex system with multiple components working together. Understanding how these components interact is crucial.",
              "type": "definition",
              "section": "CPU Internal Structure",
              "subsection": "Internal CPU Organization"
            }
          ]
        }
      ]
    },
    {
      "section": "Register Organization",
      "subsections": [
        {
          "subsection": "Register Hierarchy",
          "cardCount": 1,
          "cards": [
            {
              "id": "2-Register-Organization-Register-Hierarchy-Purpose",
              "title": "Purpose",
              "front": "Purpose",
              "back": "1. Minimize main memory references\n2. Store frequently accessed data\n3. Hold operands and results\n4. Control processor operation",
              "type": "list",
              "section": "Register Organization",
              "subsection": "Register Hierarchy"
            }
          ]
        },
        {
          "subsection": "Two Categories of Registers",
          "cardCount": 11,
          "cards": [
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-1--User-Visible-Registers",
              "title": "1. User-Visible Registers",
              "front": "1. User-Visible Registers",
              "back": "",
              "type": "concept",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "Registers that can be referenced by machine language or assembly language programs.",
              "type": "definition",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-Purpose",
              "title": "Purpose",
              "front": "Purpose",
              "back": "Enable programmers to optimize code by minimizing memory accesses.",
              "type": "definition",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-Categories",
              "title": "Categories",
              "front": "Categories",
              "back": "1. **Function:** Can be assigned to various functions by the programmer\n2. **Uses:**\n3. Hold operands for arithmetic/logical operations\n4. Hold addresses for memory operations\n5. Hold intermediate results\n6. Hold function parameters and return values\n7. **Examples:**\n8. x86: EAX, EBX, ECX, EDX (and more)\n9. MIPS: $0-$31 (32 general-purpose registers)\n10. ARM: R0-R15 (16 general-purpose registers)",
              "type": "list",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-Advantages",
              "title": "Advantages",
              "front": "Advantages",
              "back": "1. Flexibility: Can be used for any purpose\n2. Efficiency: Fast access, no memory references needed\n3. **Function:** Used only to hold data\n4. **Restriction:** Cannot be used in address calculations\n5. **Use Case:** Specialized registers for data operations\n6. **Example:** Some architectures separate data registers from address registers\n7. **Function:** Used for address calculations and memory addressing\n8. **Types:**\n9. **Segment Pointers:** Hold segment base addresses (x86 architecture)\n10. **Index Registers:** Used in indexed addressing modes\n11. **Stack Pointer (SP):** Points to top of stack\n12. **Base Pointer (BP):** Points to base of stack frame\n13. **Examples:**\n14. x86: ESI (source index), EDI (destination index), ESP (stack pointer), EBP (base pointer)\n15. MIPS: $sp (stack pointer), $fp (frame pointer)\n16. **Function:** Bits set by processor hardware as result of operations\n17. **Common Flags:**\n18. **Zero (Z):** Result is zero\n19. **Sign (S/N):** Result is negative\n20. **Carry (C):** Arithmetic carry occurred\n21. **Overflow (V):** Arithmetic overflow occurred\n22. **Parity (P):** Even/odd parity\n23. **Use:** Control conditional branches and program flow\n24. **Example:**",
              "type": "list",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-2--Control-and-Status-Registers",
              "title": "2. Control and Status Registers",
              "front": "2. Control and Status Registers",
              "back": "",
              "type": "concept",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "Registers used by the control unit and operating system to control processor operation.",
              "type": "definition",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-Purpose",
              "title": "Purpose",
              "front": "Purpose",
              "back": "Manage instruction execution and system state.",
              "type": "definition",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-Essential-Registers",
              "title": "Essential Registers",
              "front": "Essential Registers",
              "back": "1. **Function:** Contains the address of the next instruction to fetch\n2. **Behavior:**\n3. Incremented after each instruction fetch\n4. Updated on branches, jumps, and subroutine calls\n5. Saved on interrupts, restored on return\n6. **Size:** Typically matches address bus width\n7. **Example:**\n8. **Function:** Contains the instruction most recently fetched\n9. **Behavior:**\n10. Loaded during fetch cycle\n11. Used by control unit for decoding\n12. Holds instruction until execution completes\n13. **Size:** Matches instruction width (typically 32 or 64 bits)\n14. **Function:** Contains the address of a location in memory\n15. **Use:**\n16. Holds address for memory read operations\n17. Holds address for memory write operations\n18. Connected to address bus\n19. **Size:** Matches address bus width\n20. **Function:** Contains data to be written to memory or data most recently read\n21. **Also Known As:** Memory Data Register (MDR)\n22. **Use:**\n23. Holds data being written to memory\n24. Holds data read from memory\n25. Connected to data bus\n26. **Size:** Matches data bus width",
              "type": "list",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-Data-Flow-Example--Memory-Read-",
              "title": "Data Flow Example (Memory Read)",
              "front": "Data Flow Example (Memory Read)",
              "back": "1. CPU places address in MAR\n2. CPU asserts Read signal\n3. Memory places data in MBR\n4. CPU reads data from MBR",
              "type": "list",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            },
            {
              "id": "2-Register-Organization-Two-Categories-of-Registers-Data-Flow-Example--Memory-Write-",
              "title": "Data Flow Example (Memory Write)",
              "front": "Data Flow Example (Memory Write)",
              "back": "1. CPU places address in MAR\n2. CPU places data in MBR\n3. CPU asserts Write signal\n4. Memory reads data from MBR and writes to address in MAR",
              "type": "list",
              "section": "Register Organization",
              "subsection": "Two Categories of Registers"
            }
          ]
        },
        {
          "subsection": "Program Status Word (PSW)",
          "cardCount": 4,
          "cards": [
            {
              "id": "2-Register-Organization-Program-Status-Word--PSW--Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "A register (or set of registers) containing condition codes plus other status information.",
              "type": "definition",
              "section": "Register Organization",
              "subsection": "Program Status Word (PSW)"
            },
            {
              "id": "2-Register-Organization-Program-Status-Word--PSW--Common-Fields-Flags",
              "title": "Common Fields/Flags",
              "front": "Common Fields/Flags",
              "back": "1. **Sign (S/N):**\n2. Set when result is negative\n3. Used for signed comparisons\n4. **Zero (Z):**\n5. Set when result is zero\n6. Used for equality comparisons\n7. **Carry (C):**\n8. Set when arithmetic operation produces carry\n9. Used for unsigned arithmetic and multi-precision operations\n10. **Equal:**\n11. Set when two values are equal\n12. Used for comparisons\n13. **Overflow (V):**\n14. Set when signed arithmetic overflow occurs\n15. Used for error detection in signed arithmetic\n16. **Interrupt Enable/Disable:**\n17. Controls whether interrupts are processed\n18. Critical for interrupt handling\n19. **Supervisor (S):**\n20. Indicates processor mode (user vs. supervisor/kernel)\n21. Controls access to privileged instructions",
              "type": "list",
              "section": "Register Organization",
              "subsection": "Program Status Word (PSW)"
            },
            {
              "id": "2-Register-Organization-Program-Status-Word--PSW--PSW-Example",
              "title": "PSW Example",
              "front": "PSW Example",
              "back": "PSW = [S|Z|C|E|V|I|M|...] │ │ │ │ │ │ │ │ │ │ │ │ │ └─ Mode (Supervisor/User) │ │ │ │ │ └─── Interrupt Enable │ │ │ │ └───── Overflow │ │ │ └─────── Equal │ │ └───────── Carry │ └─────────── Zero └───────────── Sign",
              "type": "definition",
              "section": "Register Organization",
              "subsection": "Program Status Word (PSW)"
            },
            {
              "id": "2-Register-Organization-Program-Status-Word--PSW--Usage",
              "title": "Usage",
              "front": "Usage",
              "back": "1. Condition codes set automatically by ALU\n2. Used by conditional branch instructions\n3. Saved/restored on context switches\n4. Critical for program flow control",
              "type": "list",
              "section": "Register Organization",
              "subsection": "Program Status Word (PSW)"
            }
          ]
        }
      ]
    },
    {
      "section": "Instruction Cycle Details",
      "subsections": [
        {
          "subsection": "Complete Instruction Cycle",
          "cardCount": 17,
          "cards": [
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-1--Fetch-Cycle",
              "title": "Phase 1: Fetch Cycle",
              "front": "Phase 1: Fetch Cycle",
              "back": "",
              "type": "concept",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
              "title": "Purpose",
              "front": "Purpose",
              "back": "Retrieve instruction from memory.",
              "type": "definition",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
              "title": "Steps",
              "front": "Steps",
              "back": "1. **PC → MAR:** Transfer program counter to memory address register\n2. **Assert Read:** Signal memory to read\n3. **Memory → MBR:** Memory places instruction in memory buffer register\n4. **MBR → IR:** Transfer instruction to instruction register\n5. **Increment PC:** PC = PC + instruction_size",
              "type": "list",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Data-Flow",
              "title": "Data Flow",
              "front": "Data Flow",
              "back": "PC ──► MAR ──► Address Bus ──► Memory MBR ◄── Data Bus ◄── Memory",
              "type": "definition",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Timing",
              "title": "Timing",
              "front": "Timing",
              "back": "1. Typically takes 1-3 clock cycles\n2. Depends on memory speed and cache hit/miss",
              "type": "list",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-2--Indirect-Cycle",
              "title": "Phase 2: Indirect Cycle",
              "front": "Phase 2: Indirect Cycle",
              "back": "",
              "type": "concept",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
              "title": "Purpose",
              "front": "Purpose",
              "back": "Handle indirect addressing (when instruction specifies indirect address).",
              "type": "definition",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
              "title": "Steps",
              "front": "Steps",
              "back": "1. **IR → MAR:** Address field of instruction to MAR\n2. **Assert Read:** Read indirect address from memory\n3. **Memory → MBR:** Get actual address\n4. **MBR → MAR:** Use actual address for operand fetch",
              "type": "list",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-When-Used",
              "title": "When Used",
              "front": "When Used",
              "back": "1. Indirect addressing mode\n2. Pointer dereferencing\n3. Array indexing through pointers",
              "type": "list",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Example",
              "title": "Example",
              "front": "Example",
              "back": "1. Read address from R1 → MAR\n2. Read value at that address → MBR\n3. Use MBR as operand for ADD",
              "type": "list",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-3--Execute-Cycle",
              "title": "Phase 3: Execute Cycle",
              "front": "Phase 3: Execute Cycle",
              "back": "",
              "type": "concept",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
              "title": "Purpose",
              "front": "Purpose",
              "back": "Perform the actual operation.",
              "type": "definition",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Types-of-Execute-Cycles",
              "title": "Types of Execute Cycles",
              "front": "Types of Execute Cycles",
              "back": "1. Read R2 and R3 from register file\n2. ALU performs R2 + R3\n3. Write result to R1\n4. Address 1000 → MAR\n5. Assert Read\n6. Memory → MBR\n7. MBR → R1\n8. R1 → MBR\n9. Address 1000 → MAR\n10. Assert Write\n11. Memory reads from MBR\n12. R2, R3 → ALU inputs\n13. ALU performs addition\n14. ALU output → R1\n15. Update condition codes (PSW)\n16. Check Z flag in PSW\n17. If Z=1: PC = target\n18. If Z=0: PC = PC + 1 (continue)",
              "type": "list",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-4--Interrupt-Cycle",
              "title": "Phase 4: Interrupt Cycle",
              "front": "Phase 4: Interrupt Cycle",
              "back": "",
              "type": "concept",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
              "title": "Purpose",
              "front": "Purpose",
              "back": "Handle interrupts (covered in detail in Group 1).",
              "type": "definition",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
              "title": "Steps",
              "front": "Steps",
              "back": "1. **Save Context:** PC, PSW, registers → stack or special registers\n2. **Disable Interrupts:** Set interrupt disable flag\n3. **Load Handler Address:** Interrupt vector → PC\n4. **Jump to Handler:** Begin executing interrupt service routine",
              "type": "list",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            },
            {
              "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Data-Flow",
              "title": "Data Flow",
              "front": "Data Flow",
              "back": "Current PC ──► Save to stack Current PSW ──► Save to stack Registers ──► Save to stack Interrupt Vector ──► PC",
              "type": "definition",
              "section": "Instruction Cycle Details",
              "subsection": "Complete Instruction Cycle"
            }
          ]
        },
        {
          "subsection": "Instruction Cycle State Diagram",
          "cardCount": 2,
          "cards": [
            {
              "id": "2-Instruction-Cycle-Details-Instruction-Cycle-State-Diagram-States",
              "title": "States",
              "front": "States",
              "back": "FETCH ──► [Indirect?] ──► EXECUTE ──► [Interrupt?] ──► FETCH │ Yes │ Yes │ │ ▼ ▼ INDIRECT INTERRUPT │ │ └──────── EXECUTE ───────────────┘",
              "type": "definition",
              "section": "Instruction Cycle Details",
              "subsection": "Instruction Cycle State Diagram"
            },
            {
              "id": "2-Instruction-Cycle-Details-Instruction-Cycle-State-Diagram-Key-Points",
              "title": "Key Points",
              "front": "Key Points",
              "back": "1. Fetch always occurs first\n2. Indirect cycle is optional (only for indirect addressing)\n3. Execute always occurs (but varies greatly)\n4. Interrupt check occurs after execute\n5. Cycle repeats indefinitely",
              "type": "list",
              "section": "Instruction Cycle Details",
              "subsection": "Instruction Cycle State Diagram"
            }
          ]
        }
      ]
    },
    {
      "section": "Pipelining Fundamentals",
      "subsections": [
        {
          "subsection": "The Problem: Sequential Execution",
          "cardCount": 4,
          "cards": [
            {
              "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Traditional-Approach--Non-Pipelined-",
              "title": "Traditional Approach (Non-Pipelined)",
              "front": "Traditional Approach (Non-Pipelined)",
              "back": "Instruction 1: [Fetch] [Decode] [Execute] [Write] ──► Complete Instruction 2: [Fetch] [Decode] [Execute] [Write] ──► Complete Instruction 3: [Fetch] [Decode] [Execute] [Write] ──► Complete",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "The Problem: Sequential Execution"
            },
            {
              "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Time-per-instruction",
              "title": "Time per instruction",
              "front": "Time per instruction",
              "back": "Sum of all stages",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "The Problem: Sequential Execution"
            },
            {
              "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Throughput",
              "title": "Throughput",
              "front": "Throughput",
              "back": "1 instruction per (sum of stages)",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "The Problem: Sequential Execution"
            },
            {
              "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Example",
              "title": "Example",
              "front": "Example",
              "back": "1. Fetch: 200ps\n2. Decode: 100ps\n3. Execute: 200ps\n4. Write: 100ps\n5. **Total: 600ps per instruction**",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "The Problem: Sequential Execution"
            }
          ]
        },
        {
          "subsection": "The Solution: Pipelining",
          "cardCount": 4,
          "cards": [
            {
              "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Concept",
              "title": "Concept",
              "front": "Concept",
              "back": "Overlap execution of multiple instructions.",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "The Solution: Pipelining"
            },
            {
              "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Pipelined-Approach",
              "title": "Pipelined Approach",
              "front": "Pipelined Approach",
              "back": "Time: 1 2 3 4 5 6 7 8 Inst 1: [F] [D] [E] [W] Inst 2: [F] [D] [E] [W] Inst 3: [F] [D] [E] [W] Inst 4: [F] [D] [E] [W]",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "The Solution: Pipelining"
            },
            {
              "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Key-Insight",
              "title": "Key Insight",
              "front": "Key Insight",
              "back": "While Instruction 1 is in Execute stage, Instruction 2 can be in Decode stage, and Instruction 3 can be in Fetch stage.",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "The Solution: Pipelining"
            },
            {
              "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Benefits",
              "title": "Benefits",
              "front": "Benefits",
              "back": "1. **Throughput:** Multiple instructions in pipeline simultaneously\n2. **Efficiency:** Better resource utilization\n3. **Performance:** Significant speedup (ideally equal to number of stages)",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "The Solution: Pipelining"
            }
          ]
        },
        {
          "subsection": "Pipelining Analogy: Laundry",
          "cardCount": 4,
          "cards": [
            {
              "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Non-Pipelined-Laundry",
              "title": "Non-Pipelined Laundry",
              "front": "Non-Pipelined Laundry",
              "back": "Load 1: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Load 2: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Load 3: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Total: 240 minutes for 3 loads",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "Pipelining Analogy: Laundry"
            },
            {
              "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Pipelined-Laundry",
              "title": "Pipelined Laundry",
              "front": "Pipelined Laundry",
              "back": "Time: 0-30 30-60 60-80 80-110 110-140 140-160 Load 1: [Wash] [Dry] [Fold] Load 2: [Wash] [Dry] [Fold] Load 3: [Wash] [Dry] [Fold] Total: 160 minutes for 3 loads Speedup: 240/160 = 1.5x",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "Pipelining Analogy: Laundry"
            },
            {
              "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-With-4-Loads",
              "title": "With 4 Loads",
              "front": "With 4 Loads",
              "back": "1. Non-pipelined: 320 minutes\n2. Pipelined: 200 minutes (30 + 30 + 20 + 3×30)\n3. **Speedup: 320/200 = 1.6x**",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "Pipelining Analogy: Laundry"
            },
            {
              "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Ideal-Speedup",
              "title": "Ideal Speedup",
              "front": "Ideal Speedup",
              "back": "If all stages take equal time and there's enough work, speedup = number of stages.",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "Pipelining Analogy: Laundry"
            }
          ]
        },
        {
          "subsection": "Instruction Pipeline Stages",
          "cardCount": 6,
          "cards": [
            {
              "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-1--Fetch-Instruction--FI-",
              "title": "Stage 1: Fetch Instruction (FI)",
              "front": "Stage 1: Fetch Instruction (FI)",
              "back": "1. **Function:** Read the next expected instruction into a buffer\n2. **Operations:**\n3. PC → MAR\n4. Assert Read\n5. Memory → MBR → Instruction Buffer\n6. Increment PC\n7. **Time:** Depends on memory/cache access time",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "Instruction Pipeline Stages"
            },
            {
              "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-2--Decode-Instruction--DI-",
              "title": "Stage 2: Decode Instruction (DI)",
              "front": "Stage 2: Decode Instruction (DI)",
              "back": "1. **Function:** Determine the opcode and operand specifiers\n2. **Operations:**\n3. Extract opcode from instruction\n4. Identify instruction type\n5. Determine operand locations\n6. Generate control signals\n7. **Time:** Typically fast (register access)",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "Instruction Pipeline Stages"
            },
            {
              "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-3--Calculate-Operands--CO-",
              "title": "Stage 3: Calculate Operands (CO)",
              "front": "Stage 3: Calculate Operands (CO)",
              "back": "1. **Function:** Calculate the effective address of each source operand\n2. **Operations:**\n3. Handle addressing modes:\n4. Immediate: Use constant from instruction\n5. Direct: Use address from instruction\n6. Indirect: Read address, then use it\n7. Displacement: Base register + offset\n8. Register indirect: Use register value as address\n9. **Time:** Depends on addressing mode complexity",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "Instruction Pipeline Stages"
            },
            {
              "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-4--Fetch-Operands--FO-",
              "title": "Stage 4: Fetch Operands (FO)",
              "front": "Stage 4: Fetch Operands (FO)",
              "back": "1. **Function:** Fetch each operand from memory (if needed)\n2. **Operations:**\n3. Read operands from memory\n4. Read operands from registers\n5. Note: Register operands don't require memory access\n6. **Time:** Depends on operand location (register = fast, memory = slow)",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "Instruction Pipeline Stages"
            },
            {
              "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-5--Execute-Instruction--EI-",
              "title": "Stage 5: Execute Instruction (EI)",
              "front": "Stage 5: Execute Instruction (EI)",
              "back": "1. **Function:** Perform the indicated operation\n2. **Operations:**\n3. Arithmetic operations in ALU\n4. Logical operations in ALU\n5. Address calculations\n6. Comparisons\n7. **Time:** Depends on operation complexity",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "Instruction Pipeline Stages"
            },
            {
              "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-6--Write-Operand--WO-",
              "title": "Stage 6: Write Operand (WO)",
              "front": "Stage 6: Write Operand (WO)",
              "back": "1. **Function:** Store the result in memory or register\n2. **Operations:**\n3. Write result to destination register\n4. Write result to memory (if needed)\n5. Update condition codes\n6. **Time:** Depends on destination (register = fast, memory = slow)",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "Instruction Pipeline Stages"
            }
          ]
        },
        {
          "subsection": "Pipeline Performance Characteristics",
          "cardCount": 2,
          "cards": [
            {
              "id": "2-Pipelining-Fundamentals-Pipeline-Performance-Characteristics-Key-Metrics",
              "title": "Key Metrics",
              "front": "Key Metrics",
              "back": "1. **Throughput:** Instructions completed per unit time\n2. **Non-pipelined:** 1 instruction per (sum of all stages)\n3. **Pipelined:** 1 instruction per (longest stage time)\n4. **Latency:** Time from start to completion of single instruction\n5. **Non-pipelined:** Sum of all stages\n6. **Pipelined:** Still sum of all stages (not reduced!)\n7. **Speedup:** Ratio of non-pipelined time to pipelined time\n8. **Ideal:** Number of stages (if stages are balanced)\n9. **Actual:** Less than ideal due to hazards and stalls",
              "type": "list",
              "section": "Pipelining Fundamentals",
              "subsection": "Pipeline Performance Characteristics"
            },
            {
              "id": "2-Pipelining-Fundamentals-Pipeline-Performance-Characteristics-Critical-Insight",
              "title": "Critical Insight",
              "front": "Critical Insight",
              "back": "Pipelining improves **throughput** (how many instructions per second), but **not latency** (how long each instruction takes).",
              "type": "definition",
              "section": "Pipelining Fundamentals",
              "subsection": "Pipeline Performance Characteristics"
            }
          ]
        }
      ]
    },
    {
      "section": "MIPS Pipeline Case Study",
      "subsections": [
        {
          "subsection": "MIPS Pipeline Overview",
          "cardCount": 7,
          "cards": [
            {
              "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Architecture",
              "title": "Architecture",
              "front": "Architecture",
              "back": "5-stage pipeline, one step per stage.",
              "type": "definition",
              "section": "MIPS Pipeline Case Study",
              "subsection": "MIPS Pipeline Overview"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stages",
              "title": "Stages",
              "front": "Stages",
              "back": "",
              "type": "definition",
              "section": "MIPS Pipeline Case Study",
              "subsection": "MIPS Pipeline Overview"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-1--IF--Instruction-Fetch-",
              "title": "Stage 1: IF (Instruction Fetch)",
              "front": "Stage 1: IF (Instruction Fetch)",
              "back": "1. Fetch instruction from memory\n2. Update PC\n3. **Time:** 200ps (memory access)",
              "type": "list",
              "section": "MIPS Pipeline Case Study",
              "subsection": "MIPS Pipeline Overview"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-2--ID--Instruction-Decode---Register-Read-",
              "title": "Stage 2: ID (Instruction Decode & Register Read)",
              "front": "Stage 2: ID (Instruction Decode & Register Read)",
              "back": "1. Decode instruction\n2. Read register operands\n3. **Time:** 100ps (register access)",
              "type": "list",
              "section": "MIPS Pipeline Case Study",
              "subsection": "MIPS Pipeline Overview"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-3--EX--Execute-",
              "title": "Stage 3: EX (Execute)",
              "front": "Stage 3: EX (Execute)",
              "back": "1. Perform ALU operation\n2. Calculate address (for load/store)\n3. **Time:** 200ps (ALU operation)",
              "type": "list",
              "section": "MIPS Pipeline Case Study",
              "subsection": "MIPS Pipeline Overview"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-4--MEM--Memory-Access-",
              "title": "Stage 4: MEM (Memory Access)",
              "front": "Stage 4: MEM (Memory Access)",
              "back": "1. Access memory operand (for load/store only)\n2. **Time:** 200ps (memory access)\n3. **Note:** R-format and branch instructions skip this stage",
              "type": "list",
              "section": "MIPS Pipeline Case Study",
              "subsection": "MIPS Pipeline Overview"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-5--WB--Write-Back-",
              "title": "Stage 5: WB (Write Back)",
              "front": "Stage 5: WB (Write Back)",
              "back": "1. Write result back to register\n2. **Time:** 100ps (register write)",
              "type": "list",
              "section": "MIPS Pipeline Case Study",
              "subsection": "MIPS Pipeline Overview"
            }
          ]
        },
        {
          "subsection": "Instruction Types and Pipeline Usage",
          "cardCount": 4,
          "cards": [
            {
              "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Load-Word--lw-",
              "title": "Load Word (lw)",
              "front": "Load Word (lw)",
              "back": "lw $t0, 4($s1) # $t0 = memory[$s1 + 4] IF: Fetch instruction (200ps) ID: Decode, read $s1 (100ps) EX: Calculate address $s1 + 4 (200ps) MEM: Read memory[$s1 + 4] (200ps) WB: Write to $t0 (100ps) Total: 800ps",
              "type": "concept",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Instruction Types and Pipeline Usage"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Store-Word--sw-",
              "title": "Store Word (sw)",
              "front": "Store Word (sw)",
              "back": "sw $t0, 4($s1) # memory[$s1 + 4] = $t0 IF: Fetch instruction (200ps) ID: Decode, read $s1 and $t0 (100ps) EX: Calculate address $s1 + 4 (200ps) MEM: Write memory[$s1 + 4] (200ps) WB: (no write back for store) Total: 700ps (no WB stage needed)",
              "type": "concept",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Instruction Types and Pipeline Usage"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-R-Format--Register-Operations-",
              "title": "R-Format (Register Operations)",
              "front": "R-Format (Register Operations)",
              "back": "add $s0, $t0, $t1 # $s0 = $t0 + $t1 IF: Fetch instruction (200ps) ID: Decode, read $t0 and $t1 (100ps) EX: ALU operation $t0 + $t1 (200ps) MEM: (no memory access) WB: Write to $s0 (100ps) Total: 600ps",
              "type": "concept",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Instruction Types and Pipeline Usage"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Branch--beq-",
              "title": "Branch (beq)",
              "front": "Branch (beq)",
              "back": "beq $t0, $t1, label # if $t0 == $t1, branch to label IF: Fetch instruction (200ps) ID: Decode, read $t0 and $t1 (100ps) EX: Compare $t0 and $t1, calculate target address (200ps) MEM: (no memory access) WB: (no write back) Total: 500ps",
              "type": "concept",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Instruction Types and Pipeline Usage"
            }
          ]
        },
        {
          "subsection": "Pipeline Clock Cycle",
          "cardCount": 4,
          "cards": [
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Critical-Constraint",
              "title": "Critical Constraint",
              "front": "Critical Constraint",
              "back": "Pipeline clock cycle is limited by the **slowest stage**.",
              "type": "definition",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Clock Cycle"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Example",
              "title": "Example",
              "front": "Example",
              "back": "1. IF: 200ps\n2. ID: 100ps\n3. EX: 200ps\n4. MEM: 200ps\n5. WB: 100ps\n6. **Clock cycle = 200ps** (slowest stage)",
              "type": "list",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Clock Cycle"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Implication",
              "title": "Implication",
              "front": "Implication",
              "back": "All stages must complete within one clock cycle, even if they don't need the full time.",
              "type": "definition",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Clock Cycle"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Wasted-Time",
              "title": "Wasted Time",
              "front": "Wasted Time",
              "back": "1. ID stage completes in 100ps but must wait 200ps\n2. WB stage completes in 100ps but must wait 200ps\n3. **Trade-off:** Simpler design vs. efficiency",
              "type": "list",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Clock Cycle"
            }
          ]
        },
        {
          "subsection": "Pipeline Throughput",
          "cardCount": 3,
          "cards": [
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Non-Pipelined",
              "title": "Non-Pipelined",
              "front": "Non-Pipelined",
              "back": "1. Longest instruction: 800ps (lw)\n2. Throughput: 1 instruction per 800ps = 1.25 × 10^9 instructions/second",
              "type": "list",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Throughput"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Pipelined",
              "title": "Pipelined",
              "front": "Pipelined",
              "back": "1. Clock cycle: 200ps (slowest stage)\n2. Throughput: 1 instruction per 200ps = 5 × 10^9 instructions/second\n3. **Speedup: 4x** (close to ideal 5x for 5 stages)",
              "type": "list",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Throughput"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Key-Point",
              "title": "Key Point",
              "front": "Key Point",
              "back": "Even though some instructions take 800ps to complete, the pipeline can start a new instruction every 200ps.",
              "type": "definition",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Throughput"
            }
          ]
        },
        {
          "subsection": "Pipeline Timing Diagram",
          "cardCount": 3,
          "cards": [
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Non-Pipelined-Execution",
              "title": "Non-Pipelined Execution",
              "front": "Non-Pipelined Execution",
              "back": "Time: 0-800 800-1500 1500-2100 2100-2600 Inst 1: [lw] Inst 2: [sw] Inst 3: [add] Inst 4: [beq]",
              "type": "definition",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Timing Diagram"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Pipelined-Execution",
              "title": "Pipelined Execution",
              "front": "Pipelined Execution",
              "back": "Time: 0-200 200-400 400-600 600-800 800-1000 1000-1200 Inst 1: [IF] [ID] [EX] [MEM] [WB] Inst 2: [IF] [ID] [EX] [MEM] [WB] Inst 3: [IF] [ID] [EX] [MEM] [WB] Inst 4: [IF] [ID] [EX] [MEM] [WB]",
              "type": "definition",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Timing Diagram"
            },
            {
              "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Observation",
              "title": "Observation",
              "front": "Observation",
              "back": "At time 800ps, Instruction 1 completes, but Instructions 2, 3, and 4 are already in progress.",
              "type": "definition",
              "section": "MIPS Pipeline Case Study",
              "subsection": "Pipeline Timing Diagram"
            }
          ]
        }
      ]
    },
    {
      "section": "Pipeline Hazards",
      "subsections": [
        {
          "subsection": "What are Hazards?",
          "cardCount": 3,
          "cards": [
            {
              "id": "2-Pipeline-Hazards-What-are-Hazards--Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "Situations that prevent starting the next instruction in the next cycle.",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "What are Hazards?"
            },
            {
              "id": "2-Pipeline-Hazards-What-are-Hazards--Impact",
              "title": "Impact",
              "front": "Impact",
              "back": "Cause pipeline stalls (bubbles), reducing performance.",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "What are Hazards?"
            },
            {
              "id": "2-Pipeline-Hazards-What-are-Hazards--Types",
              "title": "Types",
              "front": "Types",
              "back": "1. **Structure Hazards:** Resource conflicts\n2. **Data Hazards:** Data dependencies\n3. **Control Hazards:** Branch dependencies",
              "type": "list",
              "section": "Pipeline Hazards",
              "subsection": "What are Hazards?"
            }
          ]
        },
        {
          "subsection": "Structure Hazards",
          "cardCount": 6,
          "cards": [
            {
              "id": "2-Pipeline-Hazards-Structure-Hazards-Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "A required resource is busy when needed.",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Structure Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Structure-Hazards-Common-Cause",
              "title": "Common Cause",
              "front": "Common Cause",
              "back": "Multiple instructions need the same hardware resource simultaneously.",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Structure Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Structure-Hazards-Example--Single-Memory-for-Instructions-and-Data",
              "title": "Example: Single Memory for Instructions and Data",
              "front": "Example: Single Memory for Instructions and Data",
              "back": "",
              "type": "concept",
              "section": "Pipeline Hazards",
              "subsection": "Structure Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Structure-Hazards-Problem",
              "title": "Problem",
              "front": "Problem",
              "back": "Cycle 1: Instruction 1 in MEM stage (accessing data memory) Cycle 1: Instruction 2 in IF stage (needs to fetch instruction) └─► CONFLICT! Both need memory access",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Structure Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Structure-Hazards-Solution-Options",
              "title": "Solution Options",
              "front": "Solution Options",
              "back": "1. **Stall Pipeline:**\n2. Insert \"bubble\" (NOP - No Operation)\n3. Performance penalty\n4. **Separate Instruction and Data Memory:**\n5. Harvard Architecture\n6. No conflict possible\n7. More expensive\n8. **Cache with Separate I-Cache and D-Cache:**\n9. Instruction cache for IF stage\n10. Data cache for MEM stage\n11. Modern solution",
              "type": "list",
              "section": "Pipeline Hazards",
              "subsection": "Structure Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Structure-Hazards-Other-Structure-Hazards",
              "title": "Other Structure Hazards",
              "front": "Other Structure Hazards",
              "back": "1. Multiple instructions needing ALU simultaneously\n2. Register file port conflicts (need multiple read/write ports)",
              "type": "list",
              "section": "Pipeline Hazards",
              "subsection": "Structure Hazards"
            }
          ]
        },
        {
          "subsection": "Data Hazards",
          "cardCount": 6,
          "cards": [
            {
              "id": "2-Pipeline-Hazards-Data-Hazards-Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "Attempt to use data before it's ready.",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Data Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Data-Hazards-Cause",
              "title": "Cause",
              "front": "Cause",
              "back": "Instruction depends on result of previous instruction that hasn't completed yet.",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Data Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Data-Hazards-Example-",
              "title": "Example:",
              "front": "Example:",
              "back": "add $s0, $t0, $t1 # I1: $s0 = $t0 + $t1 sub $t2, $s0, $t3 # I2: $t2 = $s0 - $t3 (depends on I1)",
              "type": "concept",
              "section": "Pipeline Hazards",
              "subsection": "Data Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Data-Hazards-Pipeline-Timeline",
              "title": "Pipeline Timeline",
              "front": "Pipeline Timeline",
              "back": "Time: 1 2 3 4 5 6 I1: [IF] [ID] [EX] [MEM] [WB] I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here, but I1 writes in cycle 5!",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Data Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Data-Hazards-Problem",
              "title": "Problem",
              "front": "Problem",
              "back": "I2 needs $s0 in cycle 3 (ID stage), but I1 doesn't write $s0 until cycle 5 (WB stage).",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Data Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Data-Hazards-Solutions",
              "title": "Solutions",
              "front": "Solutions",
              "back": "1. **Stall Pipeline:** Insert bubbles until data is ready\n2. **Forwarding (Bypassing):** Use result directly from EX/MEM stage\n3. **Instruction Reordering:** Compiler reorders instructions to avoid hazard",
              "type": "list",
              "section": "Pipeline Hazards",
              "subsection": "Data Hazards"
            }
          ]
        },
        {
          "subsection": "Control Hazards",
          "cardCount": 6,
          "cards": [
            {
              "id": "2-Pipeline-Hazards-Control-Hazards-Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "Deciding on control action depends on previous instruction.",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Control Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Control-Hazards-Cause",
              "title": "Cause",
              "front": "Cause",
              "back": "Branch instructions determine which instruction to fetch next, but decision isn't known until later in pipeline.",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Control Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Control-Hazards-Example-",
              "title": "Example:",
              "front": "Example:",
              "back": "beq $t0, $t1, label # Branch if $t0 == $t1 add $s0, $s1, $s2 # Next instruction (may or may not execute)",
              "type": "concept",
              "section": "Pipeline Hazards",
              "subsection": "Control Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Control-Hazards-Problem",
              "title": "Problem",
              "front": "Problem",
              "back": "Time: 1 2 3 4 5 beq: [IF] [ID] [EX] [MEM] [WB] add: [IF] [ID] [EX] [MEM] [WB] └─► Branch decision made here But we already fetched 'add'!",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Control Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Control-Hazards-Issue",
              "title": "Issue",
              "front": "Issue",
              "back": "We don't know if branch will be taken until EX stage, but we already fetched the next instruction.",
              "type": "definition",
              "section": "Pipeline Hazards",
              "subsection": "Control Hazards"
            },
            {
              "id": "2-Pipeline-Hazards-Control-Hazards-Solutions",
              "title": "Solutions",
              "front": "Solutions",
              "back": "1. **Stall on Branch:** Wait until branch decision is known\n2. **Branch Prediction:** Predict whether branch will be taken\n3. **Delayed Branch:** Always execute instruction after branch\n4. **Multiple Streams:** Fetch from both possible paths\n5. **Prefetch Branch Target:** Prefetch target instruction",
              "type": "list",
              "section": "Pipeline Hazards",
              "subsection": "Control Hazards"
            }
          ]
        }
      ]
    },
    {
      "section": "Data Hazards and Forwarding",
      "subsections": [
        {
          "subsection": "Types of Data Hazards",
          "cardCount": 24,
          "cards": [
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-1--RAW--Read-After-Write----True-Dependency",
              "title": "1. RAW (Read After Write) - True Dependency",
              "front": "1. RAW (Read After Write) - True Dependency",
              "back": "",
              "type": "concept",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "Instruction 2 tries to read an operand before Instruction 1 writes to it.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
              "title": "Example",
              "front": "Example",
              "back": "I1: add $s0, $t0, $t1 # I1 writes to $s0 I2: sub $t2, $s0, $t3 # I2 reads from $s0",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
              "title": "Timeline",
              "front": "Timeline",
              "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 written here I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here (too early!)",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
              "title": "Frequency",
              "front": "Frequency",
              "back": "Extremely common - most data dependencies are RAW.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Solution",
              "title": "Solution",
              "front": "Solution",
              "back": "Forwarding (bypassing) - use result from EX/MEM stage directly.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-2--WAR--Write-After-Read----Anti-Dependency",
              "title": "2. WAR (Write After Read) - Anti-Dependency",
              "front": "2. WAR (Write After Read) - Anti-Dependency",
              "back": "",
              "type": "concept",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "Instruction 2 tries to write to a destination before Instruction 1 reads from it.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
              "title": "Example",
              "front": "Example",
              "back": "I1: add $t4, $t1, $t5 # I1 reads from $t5 I2: add $t5, $t1, $t2 # I2 writes to $t5",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
              "title": "Timeline",
              "front": "Timeline",
              "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t5 here I2: [IF] [ID] [EX] [MEM] [WB] └─► Writes $t5 here",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
              "title": "Frequency",
              "front": "Frequency",
              "back": "Uncommon/impossible in simple in-order pipelines.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Why",
              "title": "Why",
              "front": "Why",
              "back": "In simple pipelines, instructions execute in order, so I1 always reads before I2 writes.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Occurs-In",
              "title": "Occurs In",
              "front": "Occurs In",
              "back": "Out-of-order execution, superscalar processors.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-3--WAW--Write-After-Write----Output-Dependency",
              "title": "3. WAW (Write After Write) - Output Dependency",
              "front": "3. WAW (Write After Write) - Output Dependency",
              "back": "",
              "type": "concept",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "Instruction 2 tries to write to an operand before Instruction 1 writes to it.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
              "title": "Example",
              "front": "Example",
              "back": "I1: add $s0, $t0, $t1 # I1 writes to $s0 I2: add $s0, $t2, $t3 # I2 writes to $s0",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
              "title": "Timeline",
              "front": "Timeline",
              "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Writes $s0 here I2: [IF] [ID] [EX] [MEM] [WB] └─► Writes $s0 here (must wait)",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
              "title": "Frequency",
              "front": "Frequency",
              "back": "Possible in simple pipelines, but not in the very simple pipeline we're assuming.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Solution",
              "title": "Solution",
              "front": "Solution",
              "back": "Delay I2's write until I1 completes.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-4--RAR--Read-After-Read----Not-a-Hazard",
              "title": "4. RAR (Read After Read) - Not a Hazard",
              "front": "4. RAR (Read After Read) - Not a Hazard",
              "back": "",
              "type": "concept",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
              "title": "Definition",
              "front": "Definition",
              "back": "Both instructions read from the same register.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
              "title": "Example",
              "front": "Example",
              "back": "I1: add $t1, $t2, $t3 # I1 reads from $t2 I2: add $t5, $t4, $t2 # I2 reads from $t2",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Why-Not-a-Hazard",
              "title": "Why Not a Hazard",
              "front": "Why Not a Hazard",
              "back": "Reading doesn't change the register value. Order doesn't matter.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
              "title": "Timeline",
              "front": "Timeline",
              "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t2 I2: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t2 (no problem!)",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Types of Data Hazards"
            }
          ]
        },
        {
          "subsection": "Forwarding (Bypassing)",
          "cardCount": 8,
          "cards": [
            {
              "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Concept",
              "title": "Concept",
              "front": "Concept",
              "back": "Use result directly from pipeline stage where it's computed, without waiting for it to be written to register.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Forwarding (Bypassing)"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Problem-Without-Forwarding",
              "title": "Problem Without Forwarding",
              "front": "Problem Without Forwarding",
              "back": "Time: 1 2 3 4 5 6 7 8 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available here I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0, must wait (stall) [stall] [stall] [EX] [MEM] [WB]",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Forwarding (Bypassing)"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Solution-With-Forwarding",
              "title": "Solution With Forwarding",
              "front": "Solution With Forwarding",
              "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 computed here I2: [IF] [ID] [EX] [MEM] [WB] └─► Forward $s0 directly from I1's EX stage",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Forwarding (Bypassing)"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Implementation",
              "title": "Implementation",
              "front": "Implementation",
              "back": "1. **Extra Connections:** Datapath connections from EX/MEM stage to EX stage inputs\n2. **Forwarding Unit:** Detects data hazards and selects forwarded data\n3. **Multiplexers:** Route forwarded data to ALU inputs",
              "type": "list",
              "section": "Data Hazards and Forwarding",
              "subsection": "Forwarding (Bypassing)"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Forwarding-Paths",
              "title": "Forwarding Paths",
              "front": "Forwarding Paths",
              "back": "1. **EX/MEM → EX:** Forward result from previous instruction's EX stage\n2. **MEM/WB → EX:** Forward result from two instructions ago\n3. **EX/MEM → MEM:** Forward result for store instructions",
              "type": "list",
              "section": "Data Hazards and Forwarding",
              "subsection": "Forwarding (Bypassing)"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Example",
              "title": "Example",
              "front": "Example",
              "back": "add $s0, $t0, $t1 # I1 sub $t2, $s0, $t3 # I2: needs $s0",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Forwarding (Bypassing)"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--With-Forwarding",
              "title": "With Forwarding",
              "front": "With Forwarding",
              "back": "1. I1 computes $s0 in EX stage (cycle 3)\n2. I2 needs $s0 in EX stage (cycle 4)\n3. Forwarding unit detects hazard\n4. Routes I1's EX output directly to I2's EX input\n5. **No stall needed!**",
              "type": "list",
              "section": "Data Hazards and Forwarding",
              "subsection": "Forwarding (Bypassing)"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Limitations",
              "title": "Limitations",
              "front": "Limitations",
              "back": "1. Forwarding can't help if data isn't computed yet\n2. Load instructions: Data only available after MEM stage\n3. May still need 1-cycle stall for load-use hazards",
              "type": "list",
              "section": "Data Hazards and Forwarding",
              "subsection": "Forwarding (Bypassing)"
            }
          ]
        },
        {
          "subsection": "Load-Use Hazard",
          "cardCount": 6,
          "cards": [
            {
              "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Special-Case",
              "title": "Special Case",
              "front": "Special Case",
              "back": "Load instruction followed by instruction using loaded value.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Load-Use Hazard"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Example",
              "title": "Example",
              "front": "Example",
              "back": "lw $s0, 0($t0) # I1: Load from memory add $t2, $s0, $t1 # I2: Use loaded value",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Load-Use Hazard"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Timeline",
              "title": "Timeline",
              "front": "Timeline",
              "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available here (after memory read) I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here (too early!)",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Load-Use Hazard"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Problem",
              "title": "Problem",
              "front": "Problem",
              "back": "$s0 only available after MEM stage, but I2 needs it in EX stage.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Load-Use Hazard"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Solution",
              "title": "Solution",
              "front": "Solution",
              "back": "**1-cycle stall** + forwarding Time: 1 2 3 4 5 6 7 8 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available I2: [IF] [ID] [stall] [EX] [MEM] [WB] └─► Forward $s0 from I1's MEM stage",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Load-Use Hazard"
            },
            {
              "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Key-Point",
              "title": "Key Point",
              "front": "Key Point",
              "back": "Even with forwarding, load-use hazards require at least 1 stall cycle.",
              "type": "definition",
              "section": "Data Hazards and Forwarding",
              "subsection": "Load-Use Hazard"
            }
          ]
        }
      ]
    },
    {
      "section": "Control Hazards",
      "subsections": [
        {
          "subsection": "The Branch Problem",
          "cardCount": 4,
          "cards": [
            {
              "id": "2-Control-Hazards-The-Branch-Problem-Issue",
              "title": "Issue",
              "front": "Issue",
              "back": "Branch instruction determines which instruction to fetch next, but decision isn't known until later in pipeline.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "The Branch Problem"
            },
            {
              "id": "2-Control-Hazards-The-Branch-Problem-Example",
              "title": "Example",
              "front": "Example",
              "back": "beq $t0, $t1, label # Branch if $t0 == $t1 add $s0, $s1, $s2 # Next instruction (may be wrong!) sub $t2, $t3, $t4 # Instruction at label (may be correct)",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "The Branch Problem"
            },
            {
              "id": "2-Control-Hazards-The-Branch-Problem-Pipeline-Timeline",
              "title": "Pipeline Timeline",
              "front": "Pipeline Timeline",
              "back": "Time: 1 2 3 4 5 beq: [IF] [ID] [EX] [MEM] [WB] └─► Branch decision made here add: [IF] [ID] [EX] [MEM] [WB] └─► Already fetched, but may be wrong!",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "The Branch Problem"
            },
            {
              "id": "2-Control-Hazards-The-Branch-Problem-Problem",
              "title": "Problem",
              "front": "Problem",
              "back": "1. Branch decision (taken/not taken) known in EX stage\n2. But we already fetched next instruction in IF stage\n3. If branch is taken, we fetched wrong instruction\n4. Must flush pipeline and fetch correct instruction",
              "type": "list",
              "section": "Control Hazards",
              "subsection": "The Branch Problem"
            }
          ]
        },
        {
          "subsection": "Branch Penalty",
          "cardCount": 2,
          "cards": [
            {
              "id": "2-Control-Hazards-Branch-Penalty-Cost",
              "title": "Cost",
              "front": "Cost",
              "back": "2-3 cycles wasted when branch is taken.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Branch Penalty"
            },
            {
              "id": "2-Control-Hazards-Branch-Penalty-Why",
              "title": "Why",
              "front": "Why",
              "back": "1. Branch decision in EX stage (cycle 3)\n2. Wrong instruction already in pipeline (cycles 2-3)\n3. Must flush and fetch correct instruction\n4. **Total penalty: 2 cycles minimum**",
              "type": "list",
              "section": "Control Hazards",
              "subsection": "Branch Penalty"
            }
          ]
        },
        {
          "subsection": "Solutions to Control Hazards",
          "cardCount": 28,
          "cards": [
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-1--Stall-on-Branch",
              "title": "1. Stall on Branch",
              "front": "1. Stall on Branch",
              "back": "",
              "type": "concept",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
              "title": "Approach",
              "front": "Approach",
              "back": "Don't fetch next instruction until branch decision is known.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
              "title": "Implementation",
              "front": "Implementation",
              "back": "beq: [IF] [ID] [EX] [MEM] [WB] next: [IF] [stall] [stall] [IF] [ID] [EX] [MEM] [WB] └─► Wait for branch decision",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
              "title": "Performance",
              "front": "Performance",
              "back": "2-cycle penalty for every branch (taken or not).",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Advantage",
              "title": "Advantage",
              "front": "Advantage",
              "back": "Simple, always correct.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
              "title": "Disadvantage",
              "front": "Disadvantage",
              "back": "High performance penalty.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-2--Branch-Prediction",
              "title": "2. Branch Prediction",
              "front": "2. Branch Prediction",
              "back": "",
              "type": "concept",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
              "title": "Approach",
              "front": "Approach",
              "back": "Predict whether branch will be taken, fetch predicted instruction.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Predictions",
              "title": "Predictions",
              "front": "Predictions",
              "back": "1. **Always Not Taken:** Assume branch never taken\n2. If correct: No penalty\n3. If wrong: 2-cycle penalty\n4. **Always Taken:** Assume branch always taken\n5. Fetch target immediately\n6. If correct: No penalty\n7. If wrong: 2-cycle penalty\n8. **Dynamic Prediction:** Use history to predict\n9. Branch prediction buffer/cache\n10. Tracks previous branch behavior\n11. More accurate predictions",
              "type": "list",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
              "title": "Performance",
              "front": "Performance",
              "back": "1. Correct prediction: No penalty\n2. Wrong prediction: 2-cycle penalty\n3. **Accuracy matters!**",
              "type": "list",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-3--Delayed-Branch",
              "title": "3. Delayed Branch",
              "front": "3. Delayed Branch",
              "back": "",
              "type": "concept",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
              "title": "Approach",
              "front": "Approach",
              "back": "Always execute instruction immediately after branch.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Example",
              "title": "Example",
              "front": "Example",
              "back": "beq $t0, $t1, label add $s0, $s1, $s2 # Always executes (delay slot) # If branch taken, jump to label # If branch not taken, continue normally",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Compiler-s-Job",
              "title": "Compiler's Job",
              "front": "Compiler's Job",
              "back": "Fill delay slot with useful instruction (or NOP if none available).",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
              "title": "Performance",
              "front": "Performance",
              "back": "No penalty if delay slot filled usefully.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
              "title": "Disadvantage",
              "front": "Disadvantage",
              "back": "Complicates compiler and instruction set.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-4--Multiple-Streams",
              "title": "4. Multiple Streams",
              "front": "4. Multiple Streams",
              "back": "",
              "type": "concept",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
              "title": "Approach",
              "front": "Approach",
              "back": "Fetch from both possible paths (taken and not taken).",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
              "title": "Implementation",
              "front": "Implementation",
              "back": "1. Fetch next sequential instruction\n2. Also fetch branch target instruction\n3. Execute both until branch decision known\n4. Discard wrong path",
              "type": "list",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
              "title": "Disadvantage",
              "front": "Disadvantage",
              "back": "Wastes resources, complex.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-5--Prefetch-Branch-Target",
              "title": "5. Prefetch Branch Target",
              "front": "5. Prefetch Branch Target",
              "back": "",
              "type": "concept",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
              "title": "Approach",
              "front": "Approach",
              "back": "Prefetch instruction at branch target while branch executes.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
              "title": "Implementation",
              "front": "Implementation",
              "back": "1. When branch detected, start fetching target\n2. If branch taken, target already fetched\n3. If branch not taken, discard prefetched instruction",
              "type": "list",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
              "title": "Performance",
              "front": "Performance",
              "back": "Reduces penalty if branch taken.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-6--Loop-Buffer",
              "title": "6. Loop Buffer",
              "front": "6. Loop Buffer",
              "back": "",
              "type": "concept",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
              "title": "Approach",
              "front": "Approach",
              "back": "Small buffer holding recently fetched instructions.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Use-Case",
              "title": "Use Case",
              "front": "Use Case",
              "back": "Small loops that fit in buffer.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            },
            {
              "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Benefit",
              "title": "Benefit",
              "front": "Benefit",
              "back": "If loop branches back, instructions already in buffer (no fetch needed).",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Solutions to Control Hazards"
            }
          ]
        },
        {
          "subsection": "Modern Branch Prediction",
          "cardCount": 2,
          "cards": [
            {
              "id": "2-Control-Hazards-Modern-Branch-Prediction-Techniques",
              "title": "Techniques",
              "front": "Techniques",
              "back": "1. **1-bit Predictor:** Remember last outcome\n2. **2-bit Predictor:** State machine (strong/weak taken/not taken)\n3. **Branch Target Buffer (BTB):** Cache branch targets\n4. **Return Address Stack:** Predict return addresses\n5. **Correlation-based:** Use history of other branches",
              "type": "list",
              "section": "Control Hazards",
              "subsection": "Modern Branch Prediction"
            },
            {
              "id": "2-Control-Hazards-Modern-Branch-Prediction-Performance",
              "title": "Performance",
              "front": "Performance",
              "back": "Modern processors achieve >95% branch prediction accuracy.",
              "type": "definition",
              "section": "Control Hazards",
              "subsection": "Modern Branch Prediction"
            }
          ]
        }
      ]
    },
    {
      "section": "Key Concepts Summary",
      "subsections": [
        {
          "subsection": "Processor Organization Principles",
          "cardCount": 1,
          "cards": [
            {
              "id": "2-Key-Concepts-Summary-Processor-Organization-Principles-Processor-Organization-Principles",
              "title": "Processor Organization Principles",
              "front": "Processor Organization Principles",
              "back": "1. **Five Fundamental Operations:**\n2. Fetch, Interpret, Fetch Data, Process Data, Write Data\n3. All instructions follow this pattern (with variations)\n4. **Register Hierarchy:**\n5. Fastest memory level\n6. Minimize main memory accesses\n7. Two categories: User-visible and Control/Status\n8. **Instruction Cycle:**\n9. Fetch → (Indirect) → Execute → (Interrupt)\n10. Each phase has specific data flow patterns",
              "type": "list",
              "section": "Key Concepts Summary",
              "subsection": "Processor Organization Principles"
            }
          ]
        },
        {
          "subsection": "Pipelining Fundamentals",
          "cardCount": 1,
          "cards": [
            {
              "id": "2-Key-Concepts-Summary-Pipelining-Fundamentals-Pipelining-Fundamentals",
              "title": "Pipelining Fundamentals",
              "front": "Pipelining Fundamentals",
              "back": "1. **Goal:** Improve throughput, not latency\n2. **Method:** Overlap execution of multiple instructions\n3. **Ideal Speedup:** Equal to number of stages (if balanced)\n4. **Clock Cycle:** Limited by slowest stage",
              "type": "list",
              "section": "Key Concepts Summary",
              "subsection": "Pipelining Fundamentals"
            }
          ]
        },
        {
          "subsection": "Pipeline Hazards",
          "cardCount": 1,
          "cards": [
            {
              "id": "2-Key-Concepts-Summary-Pipeline-Hazards-Pipeline-Hazards",
              "title": "Pipeline Hazards",
              "front": "Pipeline Hazards",
              "back": "1. **Structure Hazards:**\n2. Resource conflicts\n3. Solved by: Separate resources, stalling\n4. **Data Hazards:**\n5. Data dependencies\n6. Solved by: Forwarding, stalling, instruction reordering\n7. Types: RAW (common), WAR (rare), WAW (possible), RAR (not a hazard)\n8. **Control Hazards:**\n9. Branch dependencies\n10. Solved by: Prediction, stalling, delayed branch\n11. Penalty: 2-3 cycles typically",
              "type": "list",
              "section": "Key Concepts Summary",
              "subsection": "Pipeline Hazards"
            }
          ]
        },
        {
          "subsection": "Performance Optimization",
          "cardCount": 1,
          "cards": [
            {
              "id": "2-Key-Concepts-Summary-Performance-Optimization-Performance-Optimization",
              "title": "Performance Optimization",
              "front": "Performance Optimization",
              "back": "1. **Forwarding:** Eliminates most data hazard stalls\n2. **Branch Prediction:** Reduces control hazard penalty\n3. **Balanced Pipeline:** Minimize wasted time in stages\n4. **Hazard Detection:** Identify and handle hazards efficiently",
              "type": "list",
              "section": "Key Concepts Summary",
              "subsection": "Performance Optimization"
            }
          ]
        }
      ]
    },
    {
      "section": "Practice Problems and Examples",
      "subsections": [
        {
          "subsection": "Problem 1: Register Organization",
          "cardCount": 2,
          "cards": [
            {
              "id": "2-Practice-Problems-and-Examples-Problem-1--Register-Organization-Question",
              "title": "Question",
              "front": "Question",
              "back": "What is the difference between user-visible registers and control/status registers?",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 1: Register Organization"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-1--Register-Organization-Answer",
              "title": "Answer",
              "front": "Answer",
              "back": "1. **User-Visible Registers:** Can be directly accessed by programs (assembly/machine code). Used for data operations, addresses, condition codes. Examples: General-purpose registers, stack pointer.\n2. **Control/Status Registers:** Used internally by processor and OS. Not directly accessible to user programs. Control instruction execution. Examples: PC, IR, MAR, MBR, PSW.",
              "type": "list",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 1: Register Organization"
            }
          ]
        },
        {
          "subsection": "Problem 2: Pipeline Speedup",
          "cardCount": 3,
          "cards": [
            {
              "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Question",
              "title": "Question",
              "front": "Question",
              "back": "A 5-stage pipeline has stage times: 200ps, 150ps, 200ps, 180ps, 150ps. What is the clock cycle time and ideal speedup?",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 2: Pipeline Speedup"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Solution",
              "title": "Solution",
              "front": "Solution",
              "back": "1. Clock cycle = slowest stage = 200ps\n2. Non-pipelined time = 200 + 150 + 200 + 180 + 150 = 880ps\n3. Pipelined throughput = 1 instruction per 200ps\n4. Ideal speedup = 880/200 = 4.4x\n5. Maximum possible speedup = 5x (number of stages)",
              "type": "list",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 2: Pipeline Speedup"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Answer",
              "title": "Answer",
              "front": "Answer",
              "back": "Clock cycle = 200ps, Ideal speedup ≈ 4.4x",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 2: Pipeline Speedup"
            }
          ]
        },
        {
          "subsection": "Problem 3: Data Hazard Detection",
          "cardCount": 2,
          "cards": [
            {
              "id": "2-Practice-Problems-and-Examples-Problem-3--Data-Hazard-Detection-Question",
              "title": "Question",
              "front": "Question",
              "back": "Identify the data hazard in this code: add $s0, $t0, $t1 sub $t2, $s0, $t3 mul $s1, $s0, $t4",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 3: Data Hazard Detection"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-3--Data-Hazard-Detection-Answer",
              "title": "Answer",
              "front": "Answer",
              "back": "1. **RAW Hazard 1:** `sub` reads $s0 before `add` writes it\n2. **RAW Hazard 2:** `mul` reads $s0 before `add` writes it\n3. **Solution:** Forwarding can handle both (if $s0 available in time)",
              "type": "list",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 3: Data Hazard Detection"
            }
          ]
        },
        {
          "subsection": "Problem 4: Control Hazard Penalty",
          "cardCount": 3,
          "cards": [
            {
              "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Question",
              "title": "Question",
              "front": "Question",
              "back": "In a 5-stage pipeline, a branch instruction makes its decision in the EX stage. What is the minimum branch penalty?",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 4: Control Hazard Penalty"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Solution",
              "title": "Solution",
              "front": "Solution",
              "back": "1. Branch decision in EX stage (cycle 3)\n2. Wrong instruction already fetched in IF stage (cycle 2)\n3. Must flush wrong instruction and fetch correct one\n4. **Minimum penalty: 2 cycles** (cycles 2-3 wasted)",
              "type": "list",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 4: Control Hazard Penalty"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Answer",
              "title": "Answer",
              "front": "Answer",
              "back": "2 cycles minimum",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 4: Control Hazard Penalty"
            }
          ]
        },
        {
          "subsection": "Problem 5: Forwarding Analysis",
          "cardCount": 2,
          "cards": [
            {
              "id": "2-Practice-Problems-and-Examples-Problem-5--Forwarding-Analysis-Question",
              "title": "Question",
              "front": "Question",
              "back": "Can forwarding eliminate the stall in this sequence? lw $s0, 0($t0) add $t2, $s0, $t1",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 5: Forwarding Analysis"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-5--Forwarding-Analysis-Answer",
              "title": "Answer",
              "front": "Answer",
              "back": "1. **No, cannot completely eliminate stall**\n2. $s0 only available after MEM stage of `lw`\n3. `add` needs $s0 in EX stage\n4. **1-cycle stall required** (load-use hazard)\n5. Forwarding can be used after the stall to avoid additional delays",
              "type": "list",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 5: Forwarding Analysis"
            }
          ]
        },
        {
          "subsection": "Problem 6: Pipeline Efficiency",
          "cardCount": 3,
          "cards": [
            {
              "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Question",
              "title": "Question",
              "front": "Question",
              "back": "A pipeline has 5 stages, each taking 100ps. If 20% of instructions cause 1-cycle stalls, what is the average CPI (Cycles Per Instruction)?",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 6: Pipeline Efficiency"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Solution",
              "title": "Solution",
              "front": "Solution",
              "back": "1. Ideal CPI = 1 (one instruction per cycle in steady state)\n2. 20% of instructions cause 1 extra cycle\n3. Average CPI = 1 + 0.2 × 1 = 1.2",
              "type": "list",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 6: Pipeline Efficiency"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Answer",
              "title": "Answer",
              "front": "Answer",
              "back": "Average CPI = 1.2",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 6: Pipeline Efficiency"
            }
          ]
        },
        {
          "subsection": "Problem 7: Branch Prediction Impact",
          "cardCount": 3,
          "cards": [
            {
              "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Question",
              "title": "Question",
              "front": "Question",
              "back": "A program has 20% branch instructions. With 80% prediction accuracy, what is the average branch penalty?",
              "type": "definition",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 7: Branch Prediction Impact"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Solution",
              "title": "Solution",
              "front": "Solution",
              "back": "1. 20% of instructions are branches\n2. 80% predicted correctly → 0 penalty\n3. 20% predicted incorrectly → 2-cycle penalty\n4. Average penalty per branch = 0.8 × 0 + 0.2 × 2 = 0.4 cycles\n5. Average penalty per instruction = 0.2 × 0.4 = 0.08 cycles",
              "type": "list",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 7: Branch Prediction Impact"
            },
            {
              "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Answer",
              "title": "Answer",
              "front": "Answer",
              "back": "1. **Understand Data Flow:**\n2. Trace how data moves through pipeline stages\n3. Understand register usage and memory access patterns\n4. Visualize instruction execution step-by-step\n5. **Master Hazard Types:**\n6. Structure: Resource conflicts\n7. Data: Dependencies (RAW most important)\n8. Control: Branches\n9. **Practice Pipeline Diagrams:**\n10. Draw pipeline timing diagrams\n11. Identify hazards visually\n12. Show forwarding paths\n13. **Calculate Performance:**\n14. Throughput vs. latency\n15. Speedup calculations\n16. CPI and performance impact\n17. **Compare Solutions:**\n18. Forwarding vs. stalling\n19. Branch prediction strategies\n20. Pipeline design trade-offs\n21. **Relate to Real Processors:**\n22. MIPS pipeline as concrete example\n23. Modern processors use similar concepts\n24. Understand why certain designs are used\n25. **Processors are complex:** Multiple components working together\n26. **Registers are critical:** Fastest memory, essential for performance\n27. **Pipelining improves throughput:** Overlap execution for speed\n28. **Hazards limit performance:** Must be detected and handled\n29. **Forwarding is powerful:** Eliminates most data hazard stalls\n30. **Branches are expensive:** Control hazards require sophisticated solutions\n31. Instruction sets (Group 3) - what instructions look like\n32. Memory systems (Group 4) - how data is stored and retrieved\n33. I/O systems (Group 6) - how external communication works",
              "type": "list",
              "section": "Practice Problems and Examples",
              "subsection": "Problem 7: Branch Prediction Impact"
            }
          ]
        }
      ]
    }
  ],
  "allCards": [
    {
      "id": "2-Detailed-Study-Guide--Detailed-Study-Guide",
      "title": "Detailed Study Guide",
      "front": "Detailed Study Guide",
      "back": "1. [Introduction: Processor Organization](#introduction-processor-organization)\n2. [CPU Internal Structure](#cpu-internal-structure)\n3. [Register Organization](#register-organization)\n4. [Instruction Cycle Details](#instruction-cycle-details)\n5. [Pipelining Fundamentals](#pipelining-fundamentals)\n6. [MIPS Pipeline Case Study](#mips-pipeline-case-study)\n7. [Pipeline Hazards](#pipeline-hazards)\n8. [Data Hazards and Forwarding](#data-hazards-and-forwarding)\n9. [Control Hazards](#control-hazards)\n10. [Key Concepts Summary](#key-concepts-summary)\n11. [Practice Problems and Examples](#practice-problems-and-examples)",
      "type": "list",
      "section": "Detailed Study Guide",
      "subsection": ""
    },
    {
      "id": "2-Introduction--Processor-Organization-Processor-Requirements-1--Fetch-Instruction",
      "title": "1. Fetch Instruction",
      "front": "1. Fetch Instruction",
      "back": "1. **Purpose:** Read the next instruction to execute\n2. **Source:** Memory (register, cache, or main memory)\n3. **Process:**\n4. Read instruction from memory location\n5. Load instruction into processor\n6. Prepare for execution",
      "type": "list",
      "section": "Introduction: Processor Organization",
      "subsection": "Processor Requirements"
    },
    {
      "id": "2-Introduction--Processor-Organization-Processor-Requirements-2--Interpret-Instruction",
      "title": "2. Interpret Instruction",
      "front": "2. Interpret Instruction",
      "back": "1. **Purpose:** Determine what action the instruction requires\n2. **Process:**\n3. Decode the instruction opcode\n4. Identify operation type (ADD, SUB, LOAD, STORE, etc.)\n5. Determine operand locations\n6. Generate control signals",
      "type": "list",
      "section": "Introduction: Processor Organization",
      "subsection": "Processor Requirements"
    },
    {
      "id": "2-Introduction--Processor-Organization-Processor-Requirements-3--Fetch-Data",
      "title": "3. Fetch Data",
      "front": "3. Fetch Data",
      "back": "1. **Purpose:** Retrieve operands needed for instruction execution\n2. **Sources:**\n3. Memory (main memory or cache)\n4. I/O modules (for I/O operations)\n5. Registers (fastest source)\n6. **Note:** Not all instructions require data fetch (some operate on registers only)",
      "type": "list",
      "section": "Introduction: Processor Organization",
      "subsection": "Processor Requirements"
    },
    {
      "id": "2-Introduction--Processor-Organization-Processor-Requirements-4--Process-Data",
      "title": "4. Process Data",
      "front": "4. Process Data",
      "back": "1. **Purpose:** Perform the actual computation\n2. **Operations:**\n3. **Arithmetic:** ADD, SUBTRACT, MULTIPLY, DIVIDE\n4. **Logical:** AND, OR, NOT, XOR, SHIFT, ROTATE\n5. **Comparison:** Compare values, set condition codes\n6. **Location:** Typically performed in ALU (Arithmetic Logic Unit)",
      "type": "list",
      "section": "Introduction: Processor Organization",
      "subsection": "Processor Requirements"
    },
    {
      "id": "2-Introduction--Processor-Organization-Processor-Requirements-5--Write-Data",
      "title": "5. Write Data",
      "front": "5. Write Data",
      "back": "1. **Purpose:** Store results of computation\n2. **Destinations:**\n3. Memory (main memory or cache)\n4. I/O modules (for output operations)\n5. Registers (fastest destination)",
      "type": "list",
      "section": "Introduction: Processor Organization",
      "subsection": "Processor Requirements"
    },
    {
      "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Key-Point",
      "title": "Key Point",
      "front": "Key Point",
      "back": "1. Instructions being executed\n2. Operands being processed\n3. Intermediate results\n4. Control information",
      "type": "list",
      "section": "Introduction: Processor Organization",
      "subsection": "Internal Memory Requirement"
    },
    {
      "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Solution",
      "title": "Solution",
      "front": "Solution",
      "back": "**Registers** - fast, small memory locations within the CPU.",
      "type": "definition",
      "section": "Introduction: Processor Organization",
      "subsection": "Internal Memory Requirement"
    },
    {
      "id": "2-Introduction--Processor-Organization-Internal-Memory-Requirement-Memory-Hierarchy--Fastest-to-Slowest-",
      "title": "Memory Hierarchy (Fastest to Slowest)",
      "front": "Memory Hierarchy (Fastest to Slowest)",
      "back": "1. **CPU Registers** (fastest, smallest, most expensive)\n2. **Cache Memory** (very fast, small, expensive)\n3. **Main Memory** (fast, larger, moderate cost)\n4. **Secondary Storage** (slow, very large, cheap)",
      "type": "list",
      "section": "Introduction: Processor Organization",
      "subsection": "Internal Memory Requirement"
    },
    {
      "id": "2-CPU-Internal-Structure-CPU-System-Bus-Connection-CPU-System-Bus-Connection",
      "title": "CPU-System Bus Connection",
      "front": "CPU-System Bus Connection",
      "back": "1. **Data Bus:** For transferring data and instructions\n2. **Address Bus:** For specifying memory/I/O addresses\n3. **Control Bus:** For control and timing signals",
      "type": "list",
      "section": "CPU Internal Structure",
      "subsection": "CPU-System Bus Connection"
    },
    {
      "id": "2-CPU-Internal-Structure-CPU-System-Bus-Connection-Connection-Points",
      "title": "Connection Points",
      "front": "Connection Points",
      "back": "1. CPU reads instructions from memory via bus\n2. CPU reads/writes data via bus\n3. CPU sends control signals via bus\n4. CPU receives interrupt signals via bus",
      "type": "list",
      "section": "CPU Internal Structure",
      "subsection": "CPU-System Bus Connection"
    },
    {
      "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Key-Components",
      "title": "Key Components",
      "front": "Key Components",
      "back": "┌─────────────────────────────────────┐ │ CPU INTERNAL │ │ │ │ ┌──────────┐ ┌──────────┐ │ │ │ Control │ │ ALU │ │ │ │ Unit │◄────►│ │ │ │ └────┬─────┘ └────┬─────┘ │ │ │ │ │ │ ┌────┴─────────────────┴─────┐ │ │ │ Register File │ │ │ │ (User-Visible Registers) │ │ │ └─────────────────────────────┘ │ │ │ │ ┌─────────────────────────────┐ │ │ │ Control & Status Registers │ │ │ │ (PC, IR, MAR, MBR, PSW) │ │ │ └─────────────────────────────┘ │ │ │ └─────────────────────────────────────┘",
      "type": "definition",
      "section": "CPU Internal Structure",
      "subsection": "Internal CPU Organization"
    },
    {
      "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Data-Flow",
      "title": "Data Flow",
      "front": "Data Flow",
      "back": "1. **Control Unit:** Generates control signals based on instruction\n2. **ALU:** Performs arithmetic/logical operations\n3. **Registers:** Store operands and results\n4. **Internal Buses:** Connect components within CPU",
      "type": "list",
      "section": "CPU Internal Structure",
      "subsection": "Internal CPU Organization"
    },
    {
      "id": "2-CPU-Internal-Structure-Internal-CPU-Organization-Key-Insight",
      "title": "Key Insight",
      "front": "Key Insight",
      "back": "The CPU is a complex system with multiple components working together. Understanding how these components interact is crucial.",
      "type": "definition",
      "section": "CPU Internal Structure",
      "subsection": "Internal CPU Organization"
    },
    {
      "id": "2-Register-Organization-Register-Hierarchy-Purpose",
      "title": "Purpose",
      "front": "Purpose",
      "back": "1. Minimize main memory references\n2. Store frequently accessed data\n3. Hold operands and results\n4. Control processor operation",
      "type": "list",
      "section": "Register Organization",
      "subsection": "Register Hierarchy"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-1--User-Visible-Registers",
      "title": "1. User-Visible Registers",
      "front": "1. User-Visible Registers",
      "back": "",
      "type": "concept",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "Registers that can be referenced by machine language or assembly language programs.",
      "type": "definition",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-Purpose",
      "title": "Purpose",
      "front": "Purpose",
      "back": "Enable programmers to optimize code by minimizing memory accesses.",
      "type": "definition",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-Categories",
      "title": "Categories",
      "front": "Categories",
      "back": "1. **Function:** Can be assigned to various functions by the programmer\n2. **Uses:**\n3. Hold operands for arithmetic/logical operations\n4. Hold addresses for memory operations\n5. Hold intermediate results\n6. Hold function parameters and return values\n7. **Examples:**\n8. x86: EAX, EBX, ECX, EDX (and more)\n9. MIPS: $0-$31 (32 general-purpose registers)\n10. ARM: R0-R15 (16 general-purpose registers)",
      "type": "list",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-Advantages",
      "title": "Advantages",
      "front": "Advantages",
      "back": "1. Flexibility: Can be used for any purpose\n2. Efficiency: Fast access, no memory references needed\n3. **Function:** Used only to hold data\n4. **Restriction:** Cannot be used in address calculations\n5. **Use Case:** Specialized registers for data operations\n6. **Example:** Some architectures separate data registers from address registers\n7. **Function:** Used for address calculations and memory addressing\n8. **Types:**\n9. **Segment Pointers:** Hold segment base addresses (x86 architecture)\n10. **Index Registers:** Used in indexed addressing modes\n11. **Stack Pointer (SP):** Points to top of stack\n12. **Base Pointer (BP):** Points to base of stack frame\n13. **Examples:**\n14. x86: ESI (source index), EDI (destination index), ESP (stack pointer), EBP (base pointer)\n15. MIPS: $sp (stack pointer), $fp (frame pointer)\n16. **Function:** Bits set by processor hardware as result of operations\n17. **Common Flags:**\n18. **Zero (Z):** Result is zero\n19. **Sign (S/N):** Result is negative\n20. **Carry (C):** Arithmetic carry occurred\n21. **Overflow (V):** Arithmetic overflow occurred\n22. **Parity (P):** Even/odd parity\n23. **Use:** Control conditional branches and program flow\n24. **Example:**",
      "type": "list",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-2--Control-and-Status-Registers",
      "title": "2. Control and Status Registers",
      "front": "2. Control and Status Registers",
      "back": "",
      "type": "concept",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "Registers used by the control unit and operating system to control processor operation.",
      "type": "definition",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-Purpose",
      "title": "Purpose",
      "front": "Purpose",
      "back": "Manage instruction execution and system state.",
      "type": "definition",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-Essential-Registers",
      "title": "Essential Registers",
      "front": "Essential Registers",
      "back": "1. **Function:** Contains the address of the next instruction to fetch\n2. **Behavior:**\n3. Incremented after each instruction fetch\n4. Updated on branches, jumps, and subroutine calls\n5. Saved on interrupts, restored on return\n6. **Size:** Typically matches address bus width\n7. **Example:**\n8. **Function:** Contains the instruction most recently fetched\n9. **Behavior:**\n10. Loaded during fetch cycle\n11. Used by control unit for decoding\n12. Holds instruction until execution completes\n13. **Size:** Matches instruction width (typically 32 or 64 bits)\n14. **Function:** Contains the address of a location in memory\n15. **Use:**\n16. Holds address for memory read operations\n17. Holds address for memory write operations\n18. Connected to address bus\n19. **Size:** Matches address bus width\n20. **Function:** Contains data to be written to memory or data most recently read\n21. **Also Known As:** Memory Data Register (MDR)\n22. **Use:**\n23. Holds data being written to memory\n24. Holds data read from memory\n25. Connected to data bus\n26. **Size:** Matches data bus width",
      "type": "list",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-Data-Flow-Example--Memory-Read-",
      "title": "Data Flow Example (Memory Read)",
      "front": "Data Flow Example (Memory Read)",
      "back": "1. CPU places address in MAR\n2. CPU asserts Read signal\n3. Memory places data in MBR\n4. CPU reads data from MBR",
      "type": "list",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Two-Categories-of-Registers-Data-Flow-Example--Memory-Write-",
      "title": "Data Flow Example (Memory Write)",
      "front": "Data Flow Example (Memory Write)",
      "back": "1. CPU places address in MAR\n2. CPU places data in MBR\n3. CPU asserts Write signal\n4. Memory reads data from MBR and writes to address in MAR",
      "type": "list",
      "section": "Register Organization",
      "subsection": "Two Categories of Registers"
    },
    {
      "id": "2-Register-Organization-Program-Status-Word--PSW--Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "A register (or set of registers) containing condition codes plus other status information.",
      "type": "definition",
      "section": "Register Organization",
      "subsection": "Program Status Word (PSW)"
    },
    {
      "id": "2-Register-Organization-Program-Status-Word--PSW--Common-Fields-Flags",
      "title": "Common Fields/Flags",
      "front": "Common Fields/Flags",
      "back": "1. **Sign (S/N):**\n2. Set when result is negative\n3. Used for signed comparisons\n4. **Zero (Z):**\n5. Set when result is zero\n6. Used for equality comparisons\n7. **Carry (C):**\n8. Set when arithmetic operation produces carry\n9. Used for unsigned arithmetic and multi-precision operations\n10. **Equal:**\n11. Set when two values are equal\n12. Used for comparisons\n13. **Overflow (V):**\n14. Set when signed arithmetic overflow occurs\n15. Used for error detection in signed arithmetic\n16. **Interrupt Enable/Disable:**\n17. Controls whether interrupts are processed\n18. Critical for interrupt handling\n19. **Supervisor (S):**\n20. Indicates processor mode (user vs. supervisor/kernel)\n21. Controls access to privileged instructions",
      "type": "list",
      "section": "Register Organization",
      "subsection": "Program Status Word (PSW)"
    },
    {
      "id": "2-Register-Organization-Program-Status-Word--PSW--PSW-Example",
      "title": "PSW Example",
      "front": "PSW Example",
      "back": "PSW = [S|Z|C|E|V|I|M|...] │ │ │ │ │ │ │ │ │ │ │ │ │ └─ Mode (Supervisor/User) │ │ │ │ │ └─── Interrupt Enable │ │ │ │ └───── Overflow │ │ │ └─────── Equal │ │ └───────── Carry │ └─────────── Zero └───────────── Sign",
      "type": "definition",
      "section": "Register Organization",
      "subsection": "Program Status Word (PSW)"
    },
    {
      "id": "2-Register-Organization-Program-Status-Word--PSW--Usage",
      "title": "Usage",
      "front": "Usage",
      "back": "1. Condition codes set automatically by ALU\n2. Used by conditional branch instructions\n3. Saved/restored on context switches\n4. Critical for program flow control",
      "type": "list",
      "section": "Register Organization",
      "subsection": "Program Status Word (PSW)"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-1--Fetch-Cycle",
      "title": "Phase 1: Fetch Cycle",
      "front": "Phase 1: Fetch Cycle",
      "back": "",
      "type": "concept",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
      "title": "Purpose",
      "front": "Purpose",
      "back": "Retrieve instruction from memory.",
      "type": "definition",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
      "title": "Steps",
      "front": "Steps",
      "back": "1. **PC → MAR:** Transfer program counter to memory address register\n2. **Assert Read:** Signal memory to read\n3. **Memory → MBR:** Memory places instruction in memory buffer register\n4. **MBR → IR:** Transfer instruction to instruction register\n5. **Increment PC:** PC = PC + instruction_size",
      "type": "list",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Data-Flow",
      "title": "Data Flow",
      "front": "Data Flow",
      "back": "PC ──► MAR ──► Address Bus ──► Memory MBR ◄── Data Bus ◄── Memory",
      "type": "definition",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Timing",
      "title": "Timing",
      "front": "Timing",
      "back": "1. Typically takes 1-3 clock cycles\n2. Depends on memory speed and cache hit/miss",
      "type": "list",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-2--Indirect-Cycle",
      "title": "Phase 2: Indirect Cycle",
      "front": "Phase 2: Indirect Cycle",
      "back": "",
      "type": "concept",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
      "title": "Purpose",
      "front": "Purpose",
      "back": "Handle indirect addressing (when instruction specifies indirect address).",
      "type": "definition",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
      "title": "Steps",
      "front": "Steps",
      "back": "1. **IR → MAR:** Address field of instruction to MAR\n2. **Assert Read:** Read indirect address from memory\n3. **Memory → MBR:** Get actual address\n4. **MBR → MAR:** Use actual address for operand fetch",
      "type": "list",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-When-Used",
      "title": "When Used",
      "front": "When Used",
      "back": "1. Indirect addressing mode\n2. Pointer dereferencing\n3. Array indexing through pointers",
      "type": "list",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Example",
      "title": "Example",
      "front": "Example",
      "back": "1. Read address from R1 → MAR\n2. Read value at that address → MBR\n3. Use MBR as operand for ADD",
      "type": "list",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-3--Execute-Cycle",
      "title": "Phase 3: Execute Cycle",
      "front": "Phase 3: Execute Cycle",
      "back": "",
      "type": "concept",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
      "title": "Purpose",
      "front": "Purpose",
      "back": "Perform the actual operation.",
      "type": "definition",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Types-of-Execute-Cycles",
      "title": "Types of Execute Cycles",
      "front": "Types of Execute Cycles",
      "back": "1. Read R2 and R3 from register file\n2. ALU performs R2 + R3\n3. Write result to R1\n4. Address 1000 → MAR\n5. Assert Read\n6. Memory → MBR\n7. MBR → R1\n8. R1 → MBR\n9. Address 1000 → MAR\n10. Assert Write\n11. Memory reads from MBR\n12. R2, R3 → ALU inputs\n13. ALU performs addition\n14. ALU output → R1\n15. Update condition codes (PSW)\n16. Check Z flag in PSW\n17. If Z=1: PC = target\n18. If Z=0: PC = PC + 1 (continue)",
      "type": "list",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Phase-4--Interrupt-Cycle",
      "title": "Phase 4: Interrupt Cycle",
      "front": "Phase 4: Interrupt Cycle",
      "back": "",
      "type": "concept",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Purpose",
      "title": "Purpose",
      "front": "Purpose",
      "back": "Handle interrupts (covered in detail in Group 1).",
      "type": "definition",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Steps",
      "title": "Steps",
      "front": "Steps",
      "back": "1. **Save Context:** PC, PSW, registers → stack or special registers\n2. **Disable Interrupts:** Set interrupt disable flag\n3. **Load Handler Address:** Interrupt vector → PC\n4. **Jump to Handler:** Begin executing interrupt service routine",
      "type": "list",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Complete-Instruction-Cycle-Data-Flow",
      "title": "Data Flow",
      "front": "Data Flow",
      "back": "Current PC ──► Save to stack Current PSW ──► Save to stack Registers ──► Save to stack Interrupt Vector ──► PC",
      "type": "definition",
      "section": "Instruction Cycle Details",
      "subsection": "Complete Instruction Cycle"
    },
    {
      "id": "2-Instruction-Cycle-Details-Instruction-Cycle-State-Diagram-States",
      "title": "States",
      "front": "States",
      "back": "FETCH ──► [Indirect?] ──► EXECUTE ──► [Interrupt?] ──► FETCH │ Yes │ Yes │ │ ▼ ▼ INDIRECT INTERRUPT │ │ └──────── EXECUTE ───────────────┘",
      "type": "definition",
      "section": "Instruction Cycle Details",
      "subsection": "Instruction Cycle State Diagram"
    },
    {
      "id": "2-Instruction-Cycle-Details-Instruction-Cycle-State-Diagram-Key-Points",
      "title": "Key Points",
      "front": "Key Points",
      "back": "1. Fetch always occurs first\n2. Indirect cycle is optional (only for indirect addressing)\n3. Execute always occurs (but varies greatly)\n4. Interrupt check occurs after execute\n5. Cycle repeats indefinitely",
      "type": "list",
      "section": "Instruction Cycle Details",
      "subsection": "Instruction Cycle State Diagram"
    },
    {
      "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Traditional-Approach--Non-Pipelined-",
      "title": "Traditional Approach (Non-Pipelined)",
      "front": "Traditional Approach (Non-Pipelined)",
      "back": "Instruction 1: [Fetch] [Decode] [Execute] [Write] ──► Complete Instruction 2: [Fetch] [Decode] [Execute] [Write] ──► Complete Instruction 3: [Fetch] [Decode] [Execute] [Write] ──► Complete",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "The Problem: Sequential Execution"
    },
    {
      "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Time-per-instruction",
      "title": "Time per instruction",
      "front": "Time per instruction",
      "back": "Sum of all stages",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "The Problem: Sequential Execution"
    },
    {
      "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Throughput",
      "title": "Throughput",
      "front": "Throughput",
      "back": "1 instruction per (sum of stages)",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "The Problem: Sequential Execution"
    },
    {
      "id": "2-Pipelining-Fundamentals-The-Problem--Sequential-Execution-Example",
      "title": "Example",
      "front": "Example",
      "back": "1. Fetch: 200ps\n2. Decode: 100ps\n3. Execute: 200ps\n4. Write: 100ps\n5. **Total: 600ps per instruction**",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "The Problem: Sequential Execution"
    },
    {
      "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Concept",
      "title": "Concept",
      "front": "Concept",
      "back": "Overlap execution of multiple instructions.",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "The Solution: Pipelining"
    },
    {
      "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Pipelined-Approach",
      "title": "Pipelined Approach",
      "front": "Pipelined Approach",
      "back": "Time: 1 2 3 4 5 6 7 8 Inst 1: [F] [D] [E] [W] Inst 2: [F] [D] [E] [W] Inst 3: [F] [D] [E] [W] Inst 4: [F] [D] [E] [W]",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "The Solution: Pipelining"
    },
    {
      "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Key-Insight",
      "title": "Key Insight",
      "front": "Key Insight",
      "back": "While Instruction 1 is in Execute stage, Instruction 2 can be in Decode stage, and Instruction 3 can be in Fetch stage.",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "The Solution: Pipelining"
    },
    {
      "id": "2-Pipelining-Fundamentals-The-Solution--Pipelining-Benefits",
      "title": "Benefits",
      "front": "Benefits",
      "back": "1. **Throughput:** Multiple instructions in pipeline simultaneously\n2. **Efficiency:** Better resource utilization\n3. **Performance:** Significant speedup (ideally equal to number of stages)",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "The Solution: Pipelining"
    },
    {
      "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Non-Pipelined-Laundry",
      "title": "Non-Pipelined Laundry",
      "front": "Non-Pipelined Laundry",
      "back": "Load 1: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Load 2: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Load 3: [Wash 30min] [Dry 30min] [Fold 20min] = 80min Total: 240 minutes for 3 loads",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "Pipelining Analogy: Laundry"
    },
    {
      "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Pipelined-Laundry",
      "title": "Pipelined Laundry",
      "front": "Pipelined Laundry",
      "back": "Time: 0-30 30-60 60-80 80-110 110-140 140-160 Load 1: [Wash] [Dry] [Fold] Load 2: [Wash] [Dry] [Fold] Load 3: [Wash] [Dry] [Fold] Total: 160 minutes for 3 loads Speedup: 240/160 = 1.5x",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "Pipelining Analogy: Laundry"
    },
    {
      "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-With-4-Loads",
      "title": "With 4 Loads",
      "front": "With 4 Loads",
      "back": "1. Non-pipelined: 320 minutes\n2. Pipelined: 200 minutes (30 + 30 + 20 + 3×30)\n3. **Speedup: 320/200 = 1.6x**",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "Pipelining Analogy: Laundry"
    },
    {
      "id": "2-Pipelining-Fundamentals-Pipelining-Analogy--Laundry-Ideal-Speedup",
      "title": "Ideal Speedup",
      "front": "Ideal Speedup",
      "back": "If all stages take equal time and there's enough work, speedup = number of stages.",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "Pipelining Analogy: Laundry"
    },
    {
      "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-1--Fetch-Instruction--FI-",
      "title": "Stage 1: Fetch Instruction (FI)",
      "front": "Stage 1: Fetch Instruction (FI)",
      "back": "1. **Function:** Read the next expected instruction into a buffer\n2. **Operations:**\n3. PC → MAR\n4. Assert Read\n5. Memory → MBR → Instruction Buffer\n6. Increment PC\n7. **Time:** Depends on memory/cache access time",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "Instruction Pipeline Stages"
    },
    {
      "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-2--Decode-Instruction--DI-",
      "title": "Stage 2: Decode Instruction (DI)",
      "front": "Stage 2: Decode Instruction (DI)",
      "back": "1. **Function:** Determine the opcode and operand specifiers\n2. **Operations:**\n3. Extract opcode from instruction\n4. Identify instruction type\n5. Determine operand locations\n6. Generate control signals\n7. **Time:** Typically fast (register access)",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "Instruction Pipeline Stages"
    },
    {
      "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-3--Calculate-Operands--CO-",
      "title": "Stage 3: Calculate Operands (CO)",
      "front": "Stage 3: Calculate Operands (CO)",
      "back": "1. **Function:** Calculate the effective address of each source operand\n2. **Operations:**\n3. Handle addressing modes:\n4. Immediate: Use constant from instruction\n5. Direct: Use address from instruction\n6. Indirect: Read address, then use it\n7. Displacement: Base register + offset\n8. Register indirect: Use register value as address\n9. **Time:** Depends on addressing mode complexity",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "Instruction Pipeline Stages"
    },
    {
      "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-4--Fetch-Operands--FO-",
      "title": "Stage 4: Fetch Operands (FO)",
      "front": "Stage 4: Fetch Operands (FO)",
      "back": "1. **Function:** Fetch each operand from memory (if needed)\n2. **Operations:**\n3. Read operands from memory\n4. Read operands from registers\n5. Note: Register operands don't require memory access\n6. **Time:** Depends on operand location (register = fast, memory = slow)",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "Instruction Pipeline Stages"
    },
    {
      "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-5--Execute-Instruction--EI-",
      "title": "Stage 5: Execute Instruction (EI)",
      "front": "Stage 5: Execute Instruction (EI)",
      "back": "1. **Function:** Perform the indicated operation\n2. **Operations:**\n3. Arithmetic operations in ALU\n4. Logical operations in ALU\n5. Address calculations\n6. Comparisons\n7. **Time:** Depends on operation complexity",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "Instruction Pipeline Stages"
    },
    {
      "id": "2-Pipelining-Fundamentals-Instruction-Pipeline-Stages-Stage-6--Write-Operand--WO-",
      "title": "Stage 6: Write Operand (WO)",
      "front": "Stage 6: Write Operand (WO)",
      "back": "1. **Function:** Store the result in memory or register\n2. **Operations:**\n3. Write result to destination register\n4. Write result to memory (if needed)\n5. Update condition codes\n6. **Time:** Depends on destination (register = fast, memory = slow)",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "Instruction Pipeline Stages"
    },
    {
      "id": "2-Pipelining-Fundamentals-Pipeline-Performance-Characteristics-Key-Metrics",
      "title": "Key Metrics",
      "front": "Key Metrics",
      "back": "1. **Throughput:** Instructions completed per unit time\n2. **Non-pipelined:** 1 instruction per (sum of all stages)\n3. **Pipelined:** 1 instruction per (longest stage time)\n4. **Latency:** Time from start to completion of single instruction\n5. **Non-pipelined:** Sum of all stages\n6. **Pipelined:** Still sum of all stages (not reduced!)\n7. **Speedup:** Ratio of non-pipelined time to pipelined time\n8. **Ideal:** Number of stages (if stages are balanced)\n9. **Actual:** Less than ideal due to hazards and stalls",
      "type": "list",
      "section": "Pipelining Fundamentals",
      "subsection": "Pipeline Performance Characteristics"
    },
    {
      "id": "2-Pipelining-Fundamentals-Pipeline-Performance-Characteristics-Critical-Insight",
      "title": "Critical Insight",
      "front": "Critical Insight",
      "back": "Pipelining improves **throughput** (how many instructions per second), but **not latency** (how long each instruction takes).",
      "type": "definition",
      "section": "Pipelining Fundamentals",
      "subsection": "Pipeline Performance Characteristics"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Architecture",
      "title": "Architecture",
      "front": "Architecture",
      "back": "5-stage pipeline, one step per stage.",
      "type": "definition",
      "section": "MIPS Pipeline Case Study",
      "subsection": "MIPS Pipeline Overview"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stages",
      "title": "Stages",
      "front": "Stages",
      "back": "",
      "type": "definition",
      "section": "MIPS Pipeline Case Study",
      "subsection": "MIPS Pipeline Overview"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-1--IF--Instruction-Fetch-",
      "title": "Stage 1: IF (Instruction Fetch)",
      "front": "Stage 1: IF (Instruction Fetch)",
      "back": "1. Fetch instruction from memory\n2. Update PC\n3. **Time:** 200ps (memory access)",
      "type": "list",
      "section": "MIPS Pipeline Case Study",
      "subsection": "MIPS Pipeline Overview"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-2--ID--Instruction-Decode---Register-Read-",
      "title": "Stage 2: ID (Instruction Decode & Register Read)",
      "front": "Stage 2: ID (Instruction Decode & Register Read)",
      "back": "1. Decode instruction\n2. Read register operands\n3. **Time:** 100ps (register access)",
      "type": "list",
      "section": "MIPS Pipeline Case Study",
      "subsection": "MIPS Pipeline Overview"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-3--EX--Execute-",
      "title": "Stage 3: EX (Execute)",
      "front": "Stage 3: EX (Execute)",
      "back": "1. Perform ALU operation\n2. Calculate address (for load/store)\n3. **Time:** 200ps (ALU operation)",
      "type": "list",
      "section": "MIPS Pipeline Case Study",
      "subsection": "MIPS Pipeline Overview"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-4--MEM--Memory-Access-",
      "title": "Stage 4: MEM (Memory Access)",
      "front": "Stage 4: MEM (Memory Access)",
      "back": "1. Access memory operand (for load/store only)\n2. **Time:** 200ps (memory access)\n3. **Note:** R-format and branch instructions skip this stage",
      "type": "list",
      "section": "MIPS Pipeline Case Study",
      "subsection": "MIPS Pipeline Overview"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-MIPS-Pipeline-Overview-Stage-5--WB--Write-Back-",
      "title": "Stage 5: WB (Write Back)",
      "front": "Stage 5: WB (Write Back)",
      "back": "1. Write result back to register\n2. **Time:** 100ps (register write)",
      "type": "list",
      "section": "MIPS Pipeline Case Study",
      "subsection": "MIPS Pipeline Overview"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Load-Word--lw-",
      "title": "Load Word (lw)",
      "front": "Load Word (lw)",
      "back": "lw $t0, 4($s1) # $t0 = memory[$s1 + 4] IF: Fetch instruction (200ps) ID: Decode, read $s1 (100ps) EX: Calculate address $s1 + 4 (200ps) MEM: Read memory[$s1 + 4] (200ps) WB: Write to $t0 (100ps) Total: 800ps",
      "type": "concept",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Instruction Types and Pipeline Usage"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Store-Word--sw-",
      "title": "Store Word (sw)",
      "front": "Store Word (sw)",
      "back": "sw $t0, 4($s1) # memory[$s1 + 4] = $t0 IF: Fetch instruction (200ps) ID: Decode, read $s1 and $t0 (100ps) EX: Calculate address $s1 + 4 (200ps) MEM: Write memory[$s1 + 4] (200ps) WB: (no write back for store) Total: 700ps (no WB stage needed)",
      "type": "concept",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Instruction Types and Pipeline Usage"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-R-Format--Register-Operations-",
      "title": "R-Format (Register Operations)",
      "front": "R-Format (Register Operations)",
      "back": "add $s0, $t0, $t1 # $s0 = $t0 + $t1 IF: Fetch instruction (200ps) ID: Decode, read $t0 and $t1 (100ps) EX: ALU operation $t0 + $t1 (200ps) MEM: (no memory access) WB: Write to $s0 (100ps) Total: 600ps",
      "type": "concept",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Instruction Types and Pipeline Usage"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Instruction-Types-and-Pipeline-Usage-Branch--beq-",
      "title": "Branch (beq)",
      "front": "Branch (beq)",
      "back": "beq $t0, $t1, label # if $t0 == $t1, branch to label IF: Fetch instruction (200ps) ID: Decode, read $t0 and $t1 (100ps) EX: Compare $t0 and $t1, calculate target address (200ps) MEM: (no memory access) WB: (no write back) Total: 500ps",
      "type": "concept",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Instruction Types and Pipeline Usage"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Critical-Constraint",
      "title": "Critical Constraint",
      "front": "Critical Constraint",
      "back": "Pipeline clock cycle is limited by the **slowest stage**.",
      "type": "definition",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Clock Cycle"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Example",
      "title": "Example",
      "front": "Example",
      "back": "1. IF: 200ps\n2. ID: 100ps\n3. EX: 200ps\n4. MEM: 200ps\n5. WB: 100ps\n6. **Clock cycle = 200ps** (slowest stage)",
      "type": "list",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Clock Cycle"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Implication",
      "title": "Implication",
      "front": "Implication",
      "back": "All stages must complete within one clock cycle, even if they don't need the full time.",
      "type": "definition",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Clock Cycle"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Clock-Cycle-Wasted-Time",
      "title": "Wasted Time",
      "front": "Wasted Time",
      "back": "1. ID stage completes in 100ps but must wait 200ps\n2. WB stage completes in 100ps but must wait 200ps\n3. **Trade-off:** Simpler design vs. efficiency",
      "type": "list",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Clock Cycle"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Non-Pipelined",
      "title": "Non-Pipelined",
      "front": "Non-Pipelined",
      "back": "1. Longest instruction: 800ps (lw)\n2. Throughput: 1 instruction per 800ps = 1.25 × 10^9 instructions/second",
      "type": "list",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Throughput"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Pipelined",
      "title": "Pipelined",
      "front": "Pipelined",
      "back": "1. Clock cycle: 200ps (slowest stage)\n2. Throughput: 1 instruction per 200ps = 5 × 10^9 instructions/second\n3. **Speedup: 4x** (close to ideal 5x for 5 stages)",
      "type": "list",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Throughput"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Throughput-Key-Point",
      "title": "Key Point",
      "front": "Key Point",
      "back": "Even though some instructions take 800ps to complete, the pipeline can start a new instruction every 200ps.",
      "type": "definition",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Throughput"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Non-Pipelined-Execution",
      "title": "Non-Pipelined Execution",
      "front": "Non-Pipelined Execution",
      "back": "Time: 0-800 800-1500 1500-2100 2100-2600 Inst 1: [lw] Inst 2: [sw] Inst 3: [add] Inst 4: [beq]",
      "type": "definition",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Timing Diagram"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Pipelined-Execution",
      "title": "Pipelined Execution",
      "front": "Pipelined Execution",
      "back": "Time: 0-200 200-400 400-600 600-800 800-1000 1000-1200 Inst 1: [IF] [ID] [EX] [MEM] [WB] Inst 2: [IF] [ID] [EX] [MEM] [WB] Inst 3: [IF] [ID] [EX] [MEM] [WB] Inst 4: [IF] [ID] [EX] [MEM] [WB]",
      "type": "definition",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Timing Diagram"
    },
    {
      "id": "2-MIPS-Pipeline-Case-Study-Pipeline-Timing-Diagram-Observation",
      "title": "Observation",
      "front": "Observation",
      "back": "At time 800ps, Instruction 1 completes, but Instructions 2, 3, and 4 are already in progress.",
      "type": "definition",
      "section": "MIPS Pipeline Case Study",
      "subsection": "Pipeline Timing Diagram"
    },
    {
      "id": "2-Pipeline-Hazards-What-are-Hazards--Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "Situations that prevent starting the next instruction in the next cycle.",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "What are Hazards?"
    },
    {
      "id": "2-Pipeline-Hazards-What-are-Hazards--Impact",
      "title": "Impact",
      "front": "Impact",
      "back": "Cause pipeline stalls (bubbles), reducing performance.",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "What are Hazards?"
    },
    {
      "id": "2-Pipeline-Hazards-What-are-Hazards--Types",
      "title": "Types",
      "front": "Types",
      "back": "1. **Structure Hazards:** Resource conflicts\n2. **Data Hazards:** Data dependencies\n3. **Control Hazards:** Branch dependencies",
      "type": "list",
      "section": "Pipeline Hazards",
      "subsection": "What are Hazards?"
    },
    {
      "id": "2-Pipeline-Hazards-Structure-Hazards-Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "A required resource is busy when needed.",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Structure Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Structure-Hazards-Common-Cause",
      "title": "Common Cause",
      "front": "Common Cause",
      "back": "Multiple instructions need the same hardware resource simultaneously.",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Structure Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Structure-Hazards-Example--Single-Memory-for-Instructions-and-Data",
      "title": "Example: Single Memory for Instructions and Data",
      "front": "Example: Single Memory for Instructions and Data",
      "back": "",
      "type": "concept",
      "section": "Pipeline Hazards",
      "subsection": "Structure Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Structure-Hazards-Problem",
      "title": "Problem",
      "front": "Problem",
      "back": "Cycle 1: Instruction 1 in MEM stage (accessing data memory) Cycle 1: Instruction 2 in IF stage (needs to fetch instruction) └─► CONFLICT! Both need memory access",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Structure Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Structure-Hazards-Solution-Options",
      "title": "Solution Options",
      "front": "Solution Options",
      "back": "1. **Stall Pipeline:**\n2. Insert \"bubble\" (NOP - No Operation)\n3. Performance penalty\n4. **Separate Instruction and Data Memory:**\n5. Harvard Architecture\n6. No conflict possible\n7. More expensive\n8. **Cache with Separate I-Cache and D-Cache:**\n9. Instruction cache for IF stage\n10. Data cache for MEM stage\n11. Modern solution",
      "type": "list",
      "section": "Pipeline Hazards",
      "subsection": "Structure Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Structure-Hazards-Other-Structure-Hazards",
      "title": "Other Structure Hazards",
      "front": "Other Structure Hazards",
      "back": "1. Multiple instructions needing ALU simultaneously\n2. Register file port conflicts (need multiple read/write ports)",
      "type": "list",
      "section": "Pipeline Hazards",
      "subsection": "Structure Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Data-Hazards-Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "Attempt to use data before it's ready.",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Data Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Data-Hazards-Cause",
      "title": "Cause",
      "front": "Cause",
      "back": "Instruction depends on result of previous instruction that hasn't completed yet.",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Data Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Data-Hazards-Example-",
      "title": "Example:",
      "front": "Example:",
      "back": "add $s0, $t0, $t1 # I1: $s0 = $t0 + $t1 sub $t2, $s0, $t3 # I2: $t2 = $s0 - $t3 (depends on I1)",
      "type": "concept",
      "section": "Pipeline Hazards",
      "subsection": "Data Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Data-Hazards-Pipeline-Timeline",
      "title": "Pipeline Timeline",
      "front": "Pipeline Timeline",
      "back": "Time: 1 2 3 4 5 6 I1: [IF] [ID] [EX] [MEM] [WB] I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here, but I1 writes in cycle 5!",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Data Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Data-Hazards-Problem",
      "title": "Problem",
      "front": "Problem",
      "back": "I2 needs $s0 in cycle 3 (ID stage), but I1 doesn't write $s0 until cycle 5 (WB stage).",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Data Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Data-Hazards-Solutions",
      "title": "Solutions",
      "front": "Solutions",
      "back": "1. **Stall Pipeline:** Insert bubbles until data is ready\n2. **Forwarding (Bypassing):** Use result directly from EX/MEM stage\n3. **Instruction Reordering:** Compiler reorders instructions to avoid hazard",
      "type": "list",
      "section": "Pipeline Hazards",
      "subsection": "Data Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Control-Hazards-Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "Deciding on control action depends on previous instruction.",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Control Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Control-Hazards-Cause",
      "title": "Cause",
      "front": "Cause",
      "back": "Branch instructions determine which instruction to fetch next, but decision isn't known until later in pipeline.",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Control Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Control-Hazards-Example-",
      "title": "Example:",
      "front": "Example:",
      "back": "beq $t0, $t1, label # Branch if $t0 == $t1 add $s0, $s1, $s2 # Next instruction (may or may not execute)",
      "type": "concept",
      "section": "Pipeline Hazards",
      "subsection": "Control Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Control-Hazards-Problem",
      "title": "Problem",
      "front": "Problem",
      "back": "Time: 1 2 3 4 5 beq: [IF] [ID] [EX] [MEM] [WB] add: [IF] [ID] [EX] [MEM] [WB] └─► Branch decision made here But we already fetched 'add'!",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Control Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Control-Hazards-Issue",
      "title": "Issue",
      "front": "Issue",
      "back": "We don't know if branch will be taken until EX stage, but we already fetched the next instruction.",
      "type": "definition",
      "section": "Pipeline Hazards",
      "subsection": "Control Hazards"
    },
    {
      "id": "2-Pipeline-Hazards-Control-Hazards-Solutions",
      "title": "Solutions",
      "front": "Solutions",
      "back": "1. **Stall on Branch:** Wait until branch decision is known\n2. **Branch Prediction:** Predict whether branch will be taken\n3. **Delayed Branch:** Always execute instruction after branch\n4. **Multiple Streams:** Fetch from both possible paths\n5. **Prefetch Branch Target:** Prefetch target instruction",
      "type": "list",
      "section": "Pipeline Hazards",
      "subsection": "Control Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-1--RAW--Read-After-Write----True-Dependency",
      "title": "1. RAW (Read After Write) - True Dependency",
      "front": "1. RAW (Read After Write) - True Dependency",
      "back": "",
      "type": "concept",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "Instruction 2 tries to read an operand before Instruction 1 writes to it.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
      "title": "Example",
      "front": "Example",
      "back": "I1: add $s0, $t0, $t1 # I1 writes to $s0 I2: sub $t2, $s0, $t3 # I2 reads from $s0",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
      "title": "Timeline",
      "front": "Timeline",
      "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 written here I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here (too early!)",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
      "title": "Frequency",
      "front": "Frequency",
      "back": "Extremely common - most data dependencies are RAW.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Solution",
      "title": "Solution",
      "front": "Solution",
      "back": "Forwarding (bypassing) - use result from EX/MEM stage directly.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-2--WAR--Write-After-Read----Anti-Dependency",
      "title": "2. WAR (Write After Read) - Anti-Dependency",
      "front": "2. WAR (Write After Read) - Anti-Dependency",
      "back": "",
      "type": "concept",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "Instruction 2 tries to write to a destination before Instruction 1 reads from it.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
      "title": "Example",
      "front": "Example",
      "back": "I1: add $t4, $t1, $t5 # I1 reads from $t5 I2: add $t5, $t1, $t2 # I2 writes to $t5",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
      "title": "Timeline",
      "front": "Timeline",
      "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t5 here I2: [IF] [ID] [EX] [MEM] [WB] └─► Writes $t5 here",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
      "title": "Frequency",
      "front": "Frequency",
      "back": "Uncommon/impossible in simple in-order pipelines.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Why",
      "title": "Why",
      "front": "Why",
      "back": "In simple pipelines, instructions execute in order, so I1 always reads before I2 writes.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Occurs-In",
      "title": "Occurs In",
      "front": "Occurs In",
      "back": "Out-of-order execution, superscalar processors.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-3--WAW--Write-After-Write----Output-Dependency",
      "title": "3. WAW (Write After Write) - Output Dependency",
      "front": "3. WAW (Write After Write) - Output Dependency",
      "back": "",
      "type": "concept",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "Instruction 2 tries to write to an operand before Instruction 1 writes to it.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
      "title": "Example",
      "front": "Example",
      "back": "I1: add $s0, $t0, $t1 # I1 writes to $s0 I2: add $s0, $t2, $t3 # I2 writes to $s0",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
      "title": "Timeline",
      "front": "Timeline",
      "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Writes $s0 here I2: [IF] [ID] [EX] [MEM] [WB] └─► Writes $s0 here (must wait)",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Frequency",
      "title": "Frequency",
      "front": "Frequency",
      "back": "Possible in simple pipelines, but not in the very simple pipeline we're assuming.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Solution",
      "title": "Solution",
      "front": "Solution",
      "back": "Delay I2's write until I1 completes.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-4--RAR--Read-After-Read----Not-a-Hazard",
      "title": "4. RAR (Read After Read) - Not a Hazard",
      "front": "4. RAR (Read After Read) - Not a Hazard",
      "back": "",
      "type": "concept",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Definition",
      "title": "Definition",
      "front": "Definition",
      "back": "Both instructions read from the same register.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Example",
      "title": "Example",
      "front": "Example",
      "back": "I1: add $t1, $t2, $t3 # I1 reads from $t2 I2: add $t5, $t4, $t2 # I2 reads from $t2",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Why-Not-a-Hazard",
      "title": "Why Not a Hazard",
      "front": "Why Not a Hazard",
      "back": "Reading doesn't change the register value. Order doesn't matter.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Types-of-Data-Hazards-Timeline",
      "title": "Timeline",
      "front": "Timeline",
      "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t2 I2: [IF] [ID] [EX] [MEM] [WB] └─► Reads $t2 (no problem!)",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Types of Data Hazards"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Concept",
      "title": "Concept",
      "front": "Concept",
      "back": "Use result directly from pipeline stage where it's computed, without waiting for it to be written to register.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Forwarding (Bypassing)"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Problem-Without-Forwarding",
      "title": "Problem Without Forwarding",
      "front": "Problem Without Forwarding",
      "back": "Time: 1 2 3 4 5 6 7 8 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available here I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0, must wait (stall) [stall] [stall] [EX] [MEM] [WB]",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Forwarding (Bypassing)"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Solution-With-Forwarding",
      "title": "Solution With Forwarding",
      "front": "Solution With Forwarding",
      "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 computed here I2: [IF] [ID] [EX] [MEM] [WB] └─► Forward $s0 directly from I1's EX stage",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Forwarding (Bypassing)"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Implementation",
      "title": "Implementation",
      "front": "Implementation",
      "back": "1. **Extra Connections:** Datapath connections from EX/MEM stage to EX stage inputs\n2. **Forwarding Unit:** Detects data hazards and selects forwarded data\n3. **Multiplexers:** Route forwarded data to ALU inputs",
      "type": "list",
      "section": "Data Hazards and Forwarding",
      "subsection": "Forwarding (Bypassing)"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Forwarding-Paths",
      "title": "Forwarding Paths",
      "front": "Forwarding Paths",
      "back": "1. **EX/MEM → EX:** Forward result from previous instruction's EX stage\n2. **MEM/WB → EX:** Forward result from two instructions ago\n3. **EX/MEM → MEM:** Forward result for store instructions",
      "type": "list",
      "section": "Data Hazards and Forwarding",
      "subsection": "Forwarding (Bypassing)"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Example",
      "title": "Example",
      "front": "Example",
      "back": "add $s0, $t0, $t1 # I1 sub $t2, $s0, $t3 # I2: needs $s0",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Forwarding (Bypassing)"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--With-Forwarding",
      "title": "With Forwarding",
      "front": "With Forwarding",
      "back": "1. I1 computes $s0 in EX stage (cycle 3)\n2. I2 needs $s0 in EX stage (cycle 4)\n3. Forwarding unit detects hazard\n4. Routes I1's EX output directly to I2's EX input\n5. **No stall needed!**",
      "type": "list",
      "section": "Data Hazards and Forwarding",
      "subsection": "Forwarding (Bypassing)"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Forwarding--Bypassing--Limitations",
      "title": "Limitations",
      "front": "Limitations",
      "back": "1. Forwarding can't help if data isn't computed yet\n2. Load instructions: Data only available after MEM stage\n3. May still need 1-cycle stall for load-use hazards",
      "type": "list",
      "section": "Data Hazards and Forwarding",
      "subsection": "Forwarding (Bypassing)"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Special-Case",
      "title": "Special Case",
      "front": "Special Case",
      "back": "Load instruction followed by instruction using loaded value.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Load-Use Hazard"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Example",
      "title": "Example",
      "front": "Example",
      "back": "lw $s0, 0($t0) # I1: Load from memory add $t2, $s0, $t1 # I2: Use loaded value",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Load-Use Hazard"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Timeline",
      "title": "Timeline",
      "front": "Timeline",
      "back": "Time: 1 2 3 4 5 6 7 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available here (after memory read) I2: [IF] [ID] [EX] [MEM] [WB] └─► Needs $s0 here (too early!)",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Load-Use Hazard"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Problem",
      "title": "Problem",
      "front": "Problem",
      "back": "$s0 only available after MEM stage, but I2 needs it in EX stage.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Load-Use Hazard"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Solution",
      "title": "Solution",
      "front": "Solution",
      "back": "**1-cycle stall** + forwarding Time: 1 2 3 4 5 6 7 8 I1: [IF] [ID] [EX] [MEM] [WB] └─► $s0 available I2: [IF] [ID] [stall] [EX] [MEM] [WB] └─► Forward $s0 from I1's MEM stage",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Load-Use Hazard"
    },
    {
      "id": "2-Data-Hazards-and-Forwarding-Load-Use-Hazard-Key-Point",
      "title": "Key Point",
      "front": "Key Point",
      "back": "Even with forwarding, load-use hazards require at least 1 stall cycle.",
      "type": "definition",
      "section": "Data Hazards and Forwarding",
      "subsection": "Load-Use Hazard"
    },
    {
      "id": "2-Control-Hazards-The-Branch-Problem-Issue",
      "title": "Issue",
      "front": "Issue",
      "back": "Branch instruction determines which instruction to fetch next, but decision isn't known until later in pipeline.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "The Branch Problem"
    },
    {
      "id": "2-Control-Hazards-The-Branch-Problem-Example",
      "title": "Example",
      "front": "Example",
      "back": "beq $t0, $t1, label # Branch if $t0 == $t1 add $s0, $s1, $s2 # Next instruction (may be wrong!) sub $t2, $t3, $t4 # Instruction at label (may be correct)",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "The Branch Problem"
    },
    {
      "id": "2-Control-Hazards-The-Branch-Problem-Pipeline-Timeline",
      "title": "Pipeline Timeline",
      "front": "Pipeline Timeline",
      "back": "Time: 1 2 3 4 5 beq: [IF] [ID] [EX] [MEM] [WB] └─► Branch decision made here add: [IF] [ID] [EX] [MEM] [WB] └─► Already fetched, but may be wrong!",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "The Branch Problem"
    },
    {
      "id": "2-Control-Hazards-The-Branch-Problem-Problem",
      "title": "Problem",
      "front": "Problem",
      "back": "1. Branch decision (taken/not taken) known in EX stage\n2. But we already fetched next instruction in IF stage\n3. If branch is taken, we fetched wrong instruction\n4. Must flush pipeline and fetch correct instruction",
      "type": "list",
      "section": "Control Hazards",
      "subsection": "The Branch Problem"
    },
    {
      "id": "2-Control-Hazards-Branch-Penalty-Cost",
      "title": "Cost",
      "front": "Cost",
      "back": "2-3 cycles wasted when branch is taken.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Branch Penalty"
    },
    {
      "id": "2-Control-Hazards-Branch-Penalty-Why",
      "title": "Why",
      "front": "Why",
      "back": "1. Branch decision in EX stage (cycle 3)\n2. Wrong instruction already in pipeline (cycles 2-3)\n3. Must flush and fetch correct instruction\n4. **Total penalty: 2 cycles minimum**",
      "type": "list",
      "section": "Control Hazards",
      "subsection": "Branch Penalty"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-1--Stall-on-Branch",
      "title": "1. Stall on Branch",
      "front": "1. Stall on Branch",
      "back": "",
      "type": "concept",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
      "title": "Approach",
      "front": "Approach",
      "back": "Don't fetch next instruction until branch decision is known.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
      "title": "Implementation",
      "front": "Implementation",
      "back": "beq: [IF] [ID] [EX] [MEM] [WB] next: [IF] [stall] [stall] [IF] [ID] [EX] [MEM] [WB] └─► Wait for branch decision",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
      "title": "Performance",
      "front": "Performance",
      "back": "2-cycle penalty for every branch (taken or not).",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Advantage",
      "title": "Advantage",
      "front": "Advantage",
      "back": "Simple, always correct.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
      "title": "Disadvantage",
      "front": "Disadvantage",
      "back": "High performance penalty.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-2--Branch-Prediction",
      "title": "2. Branch Prediction",
      "front": "2. Branch Prediction",
      "back": "",
      "type": "concept",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
      "title": "Approach",
      "front": "Approach",
      "back": "Predict whether branch will be taken, fetch predicted instruction.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Predictions",
      "title": "Predictions",
      "front": "Predictions",
      "back": "1. **Always Not Taken:** Assume branch never taken\n2. If correct: No penalty\n3. If wrong: 2-cycle penalty\n4. **Always Taken:** Assume branch always taken\n5. Fetch target immediately\n6. If correct: No penalty\n7. If wrong: 2-cycle penalty\n8. **Dynamic Prediction:** Use history to predict\n9. Branch prediction buffer/cache\n10. Tracks previous branch behavior\n11. More accurate predictions",
      "type": "list",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
      "title": "Performance",
      "front": "Performance",
      "back": "1. Correct prediction: No penalty\n2. Wrong prediction: 2-cycle penalty\n3. **Accuracy matters!**",
      "type": "list",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-3--Delayed-Branch",
      "title": "3. Delayed Branch",
      "front": "3. Delayed Branch",
      "back": "",
      "type": "concept",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
      "title": "Approach",
      "front": "Approach",
      "back": "Always execute instruction immediately after branch.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Example",
      "title": "Example",
      "front": "Example",
      "back": "beq $t0, $t1, label add $s0, $s1, $s2 # Always executes (delay slot) # If branch taken, jump to label # If branch not taken, continue normally",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Compiler-s-Job",
      "title": "Compiler's Job",
      "front": "Compiler's Job",
      "back": "Fill delay slot with useful instruction (or NOP if none available).",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
      "title": "Performance",
      "front": "Performance",
      "back": "No penalty if delay slot filled usefully.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
      "title": "Disadvantage",
      "front": "Disadvantage",
      "back": "Complicates compiler and instruction set.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-4--Multiple-Streams",
      "title": "4. Multiple Streams",
      "front": "4. Multiple Streams",
      "back": "",
      "type": "concept",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
      "title": "Approach",
      "front": "Approach",
      "back": "Fetch from both possible paths (taken and not taken).",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
      "title": "Implementation",
      "front": "Implementation",
      "back": "1. Fetch next sequential instruction\n2. Also fetch branch target instruction\n3. Execute both until branch decision known\n4. Discard wrong path",
      "type": "list",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Disadvantage",
      "title": "Disadvantage",
      "front": "Disadvantage",
      "back": "Wastes resources, complex.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-5--Prefetch-Branch-Target",
      "title": "5. Prefetch Branch Target",
      "front": "5. Prefetch Branch Target",
      "back": "",
      "type": "concept",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
      "title": "Approach",
      "front": "Approach",
      "back": "Prefetch instruction at branch target while branch executes.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Implementation",
      "title": "Implementation",
      "front": "Implementation",
      "back": "1. When branch detected, start fetching target\n2. If branch taken, target already fetched\n3. If branch not taken, discard prefetched instruction",
      "type": "list",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Performance",
      "title": "Performance",
      "front": "Performance",
      "back": "Reduces penalty if branch taken.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-6--Loop-Buffer",
      "title": "6. Loop Buffer",
      "front": "6. Loop Buffer",
      "back": "",
      "type": "concept",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Approach",
      "title": "Approach",
      "front": "Approach",
      "back": "Small buffer holding recently fetched instructions.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Use-Case",
      "title": "Use Case",
      "front": "Use Case",
      "back": "Small loops that fit in buffer.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Solutions-to-Control-Hazards-Benefit",
      "title": "Benefit",
      "front": "Benefit",
      "back": "If loop branches back, instructions already in buffer (no fetch needed).",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Solutions to Control Hazards"
    },
    {
      "id": "2-Control-Hazards-Modern-Branch-Prediction-Techniques",
      "title": "Techniques",
      "front": "Techniques",
      "back": "1. **1-bit Predictor:** Remember last outcome\n2. **2-bit Predictor:** State machine (strong/weak taken/not taken)\n3. **Branch Target Buffer (BTB):** Cache branch targets\n4. **Return Address Stack:** Predict return addresses\n5. **Correlation-based:** Use history of other branches",
      "type": "list",
      "section": "Control Hazards",
      "subsection": "Modern Branch Prediction"
    },
    {
      "id": "2-Control-Hazards-Modern-Branch-Prediction-Performance",
      "title": "Performance",
      "front": "Performance",
      "back": "Modern processors achieve >95% branch prediction accuracy.",
      "type": "definition",
      "section": "Control Hazards",
      "subsection": "Modern Branch Prediction"
    },
    {
      "id": "2-Key-Concepts-Summary-Processor-Organization-Principles-Processor-Organization-Principles",
      "title": "Processor Organization Principles",
      "front": "Processor Organization Principles",
      "back": "1. **Five Fundamental Operations:**\n2. Fetch, Interpret, Fetch Data, Process Data, Write Data\n3. All instructions follow this pattern (with variations)\n4. **Register Hierarchy:**\n5. Fastest memory level\n6. Minimize main memory accesses\n7. Two categories: User-visible and Control/Status\n8. **Instruction Cycle:**\n9. Fetch → (Indirect) → Execute → (Interrupt)\n10. Each phase has specific data flow patterns",
      "type": "list",
      "section": "Key Concepts Summary",
      "subsection": "Processor Organization Principles"
    },
    {
      "id": "2-Key-Concepts-Summary-Pipelining-Fundamentals-Pipelining-Fundamentals",
      "title": "Pipelining Fundamentals",
      "front": "Pipelining Fundamentals",
      "back": "1. **Goal:** Improve throughput, not latency\n2. **Method:** Overlap execution of multiple instructions\n3. **Ideal Speedup:** Equal to number of stages (if balanced)\n4. **Clock Cycle:** Limited by slowest stage",
      "type": "list",
      "section": "Key Concepts Summary",
      "subsection": "Pipelining Fundamentals"
    },
    {
      "id": "2-Key-Concepts-Summary-Pipeline-Hazards-Pipeline-Hazards",
      "title": "Pipeline Hazards",
      "front": "Pipeline Hazards",
      "back": "1. **Structure Hazards:**\n2. Resource conflicts\n3. Solved by: Separate resources, stalling\n4. **Data Hazards:**\n5. Data dependencies\n6. Solved by: Forwarding, stalling, instruction reordering\n7. Types: RAW (common), WAR (rare), WAW (possible), RAR (not a hazard)\n8. **Control Hazards:**\n9. Branch dependencies\n10. Solved by: Prediction, stalling, delayed branch\n11. Penalty: 2-3 cycles typically",
      "type": "list",
      "section": "Key Concepts Summary",
      "subsection": "Pipeline Hazards"
    },
    {
      "id": "2-Key-Concepts-Summary-Performance-Optimization-Performance-Optimization",
      "title": "Performance Optimization",
      "front": "Performance Optimization",
      "back": "1. **Forwarding:** Eliminates most data hazard stalls\n2. **Branch Prediction:** Reduces control hazard penalty\n3. **Balanced Pipeline:** Minimize wasted time in stages\n4. **Hazard Detection:** Identify and handle hazards efficiently",
      "type": "list",
      "section": "Key Concepts Summary",
      "subsection": "Performance Optimization"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-1--Register-Organization-Question",
      "title": "Question",
      "front": "Question",
      "back": "What is the difference between user-visible registers and control/status registers?",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 1: Register Organization"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-1--Register-Organization-Answer",
      "title": "Answer",
      "front": "Answer",
      "back": "1. **User-Visible Registers:** Can be directly accessed by programs (assembly/machine code). Used for data operations, addresses, condition codes. Examples: General-purpose registers, stack pointer.\n2. **Control/Status Registers:** Used internally by processor and OS. Not directly accessible to user programs. Control instruction execution. Examples: PC, IR, MAR, MBR, PSW.",
      "type": "list",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 1: Register Organization"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Question",
      "title": "Question",
      "front": "Question",
      "back": "A 5-stage pipeline has stage times: 200ps, 150ps, 200ps, 180ps, 150ps. What is the clock cycle time and ideal speedup?",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 2: Pipeline Speedup"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Solution",
      "title": "Solution",
      "front": "Solution",
      "back": "1. Clock cycle = slowest stage = 200ps\n2. Non-pipelined time = 200 + 150 + 200 + 180 + 150 = 880ps\n3. Pipelined throughput = 1 instruction per 200ps\n4. Ideal speedup = 880/200 = 4.4x\n5. Maximum possible speedup = 5x (number of stages)",
      "type": "list",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 2: Pipeline Speedup"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-2--Pipeline-Speedup-Answer",
      "title": "Answer",
      "front": "Answer",
      "back": "Clock cycle = 200ps, Ideal speedup ≈ 4.4x",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 2: Pipeline Speedup"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-3--Data-Hazard-Detection-Question",
      "title": "Question",
      "front": "Question",
      "back": "Identify the data hazard in this code: add $s0, $t0, $t1 sub $t2, $s0, $t3 mul $s1, $s0, $t4",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 3: Data Hazard Detection"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-3--Data-Hazard-Detection-Answer",
      "title": "Answer",
      "front": "Answer",
      "back": "1. **RAW Hazard 1:** `sub` reads $s0 before `add` writes it\n2. **RAW Hazard 2:** `mul` reads $s0 before `add` writes it\n3. **Solution:** Forwarding can handle both (if $s0 available in time)",
      "type": "list",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 3: Data Hazard Detection"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Question",
      "title": "Question",
      "front": "Question",
      "back": "In a 5-stage pipeline, a branch instruction makes its decision in the EX stage. What is the minimum branch penalty?",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 4: Control Hazard Penalty"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Solution",
      "title": "Solution",
      "front": "Solution",
      "back": "1. Branch decision in EX stage (cycle 3)\n2. Wrong instruction already fetched in IF stage (cycle 2)\n3. Must flush wrong instruction and fetch correct one\n4. **Minimum penalty: 2 cycles** (cycles 2-3 wasted)",
      "type": "list",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 4: Control Hazard Penalty"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-4--Control-Hazard-Penalty-Answer",
      "title": "Answer",
      "front": "Answer",
      "back": "2 cycles minimum",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 4: Control Hazard Penalty"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-5--Forwarding-Analysis-Question",
      "title": "Question",
      "front": "Question",
      "back": "Can forwarding eliminate the stall in this sequence? lw $s0, 0($t0) add $t2, $s0, $t1",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 5: Forwarding Analysis"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-5--Forwarding-Analysis-Answer",
      "title": "Answer",
      "front": "Answer",
      "back": "1. **No, cannot completely eliminate stall**\n2. $s0 only available after MEM stage of `lw`\n3. `add` needs $s0 in EX stage\n4. **1-cycle stall required** (load-use hazard)\n5. Forwarding can be used after the stall to avoid additional delays",
      "type": "list",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 5: Forwarding Analysis"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Question",
      "title": "Question",
      "front": "Question",
      "back": "A pipeline has 5 stages, each taking 100ps. If 20% of instructions cause 1-cycle stalls, what is the average CPI (Cycles Per Instruction)?",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 6: Pipeline Efficiency"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Solution",
      "title": "Solution",
      "front": "Solution",
      "back": "1. Ideal CPI = 1 (one instruction per cycle in steady state)\n2. 20% of instructions cause 1 extra cycle\n3. Average CPI = 1 + 0.2 × 1 = 1.2",
      "type": "list",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 6: Pipeline Efficiency"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-6--Pipeline-Efficiency-Answer",
      "title": "Answer",
      "front": "Answer",
      "back": "Average CPI = 1.2",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 6: Pipeline Efficiency"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Question",
      "title": "Question",
      "front": "Question",
      "back": "A program has 20% branch instructions. With 80% prediction accuracy, what is the average branch penalty?",
      "type": "definition",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 7: Branch Prediction Impact"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Solution",
      "title": "Solution",
      "front": "Solution",
      "back": "1. 20% of instructions are branches\n2. 80% predicted correctly → 0 penalty\n3. 20% predicted incorrectly → 2-cycle penalty\n4. Average penalty per branch = 0.8 × 0 + 0.2 × 2 = 0.4 cycles\n5. Average penalty per instruction = 0.2 × 0.4 = 0.08 cycles",
      "type": "list",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 7: Branch Prediction Impact"
    },
    {
      "id": "2-Practice-Problems-and-Examples-Problem-7--Branch-Prediction-Impact-Answer",
      "title": "Answer",
      "front": "Answer",
      "back": "1. **Understand Data Flow:**\n2. Trace how data moves through pipeline stages\n3. Understand register usage and memory access patterns\n4. Visualize instruction execution step-by-step\n5. **Master Hazard Types:**\n6. Structure: Resource conflicts\n7. Data: Dependencies (RAW most important)\n8. Control: Branches\n9. **Practice Pipeline Diagrams:**\n10. Draw pipeline timing diagrams\n11. Identify hazards visually\n12. Show forwarding paths\n13. **Calculate Performance:**\n14. Throughput vs. latency\n15. Speedup calculations\n16. CPI and performance impact\n17. **Compare Solutions:**\n18. Forwarding vs. stalling\n19. Branch prediction strategies\n20. Pipeline design trade-offs\n21. **Relate to Real Processors:**\n22. MIPS pipeline as concrete example\n23. Modern processors use similar concepts\n24. Understand why certain designs are used\n25. **Processors are complex:** Multiple components working together\n26. **Registers are critical:** Fastest memory, essential for performance\n27. **Pipelining improves throughput:** Overlap execution for speed\n28. **Hazards limit performance:** Must be detected and handled\n29. **Forwarding is powerful:** Eliminates most data hazard stalls\n30. **Branches are expensive:** Control hazards require sophisticated solutions\n31. Instruction sets (Group 3) - what instructions look like\n32. Memory systems (Group 4) - how data is stored and retrieved\n33. I/O systems (Group 6) - how external communication works",
      "type": "list",
      "section": "Practice Problems and Examples",
      "subsection": "Problem 7: Branch Prediction Impact"
    }
  ]
}